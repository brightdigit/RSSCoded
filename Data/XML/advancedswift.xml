<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:media="http://search.yahoo.com/mrss/"><channel><title><![CDATA[Advanced Swift]]></title><description><![CDATA[by Robert Pieta]]></description><link>https://www.advancedswift.com/</link><image><url>https://www.advancedswift.com/favicon.png</url><title>Advanced Swift</title><link>https://www.advancedswift.com/</link></image><generator>Ghost 4.7</generator><lastBuildDate>Mon, 21 Jun 2021 05:44:54 GMT</lastBuildDate><atom:link href="https://www.advancedswift.com/rss/" rel="self" type="application/rss+xml"/><ttl>60</ttl><item><title><![CDATA[Secure Random Numbers and Data in Swift]]></title><description><![CDATA[Learn how to generate secure random data and numbers in Swift using the Security framework.]]></description><link>https://www.advancedswift.com/secure-random-number-swift/</link><guid isPermaLink="false">60d0240468b770003e9ef0c2</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Mon, 21 Jun 2021 05:38:44 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1618588845382-4267677cfc11?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDh8fGxvY2t8ZW58MHx8fHwxNjI0MjUzNDk3&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1618588845382-4267677cfc11?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDh8fGxvY2t8ZW58MHx8fHwxNjI0MjUzNDk3&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Secure Random Numbers and Data in Swift"><p>Some iOS and macOS applications require secure random numbers to create secrets and make an app harder to exploit. This post presents examples of generating secure random numbers and data using the Security framework in Swift:</p>
<ol>
<li><a href="#secrandomcopybytes">SecRandomCopyBytes</a></li>
<li><a href="#secure-random-bytes">Secure Random Bytes</a></li>
<li><a href="#secure-random-data">Secure Random Data</a></li>
<li><a href="#secure-random-int">Secure Random Int</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Secure Random Numbers and Data in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="secrandomcopybytes">SecRandomCopyBytes</h2><!--kg-card-begin: markdown--><p>Swift provides a number of interfaces for generating random numbers. However, most Swift interfaces for random do not use secure random algorithms. The Security framework in Swift provides a function <code>SecRandomCopyBytes</code> specifically for generating random numbers using a secure algorithm.</p>
<p>Calling <code>SecRandomCopyBytes</code> copies one or more securely and randomly generated bytes into a byte array. <code>SecRandomCopyBytes</code> takes three arguments:</p>
<pre><code class="language-swift">// kSecRandomDefault specifies the default 
//     random number generator
// count is the number of bytes to generate
// bytes is a byte array
SecRandomCopyBytes(kSecRandomDefault, count, &amp;bytes) 
</code></pre>
<!--kg-card-end: markdown--><h2 id="secure-random-bytes">Secure Random Bytes</h2><!--kg-card-begin: markdown--><p>Use <code>SecRandomCopyBytes</code> to generate secure random bytes:</p>
<pre><code class="language-swift">func secureRandomBytes(count: Int) throws -&gt; [Int8] {
    var bytes = [Int8](repeating: 0, count: count)

    // Fill bytes with secure random data
    let status = SecRandomCopyBytes(
        kSecRandomDefault, 
        count, 
        &amp;bytes
    )

    // A status of errSecSuccess indicates success
    if status == errSecSuccess {
        return bytes
    }
    else {
        // Handle error
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="secure-random-data">Secure Random Data</h2><!--kg-card-begin: markdown--><p>To generate secure random data, use <code>SecRandomCopyBytes</code> to generate secure random bytes and convert the secure random bytes into <code>Data</code>:</p>
<pre><code class="language-swift">func secureRandomData(count: Int) throws -&gt; Data {
    var bytes = [Int8](repeating: 0, count: count)

    // Fill bytes with secure random data
    let status = SecRandomCopyBytes(
        kSecRandomDefault, 
        count, 
        &amp;bytes
    )
    
    // A status of errSecSuccess indicates success
    if status == errSecSuccess {
        // Convert bytes to Data
        let data = Data(bytes: bytes, count: count)
        return data
    }
    else {
        // Handle error
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="secure-random-int">Secure Random Int</h2><!--kg-card-begin: markdown--><p>To generate a secure random Int, use <code>SecRandomCopyBytes</code> to generate secure random bytes and convert the secure random bytes into an <code>Int</code>:</p>
<pre><code class="language-swift">func secureRandomInt() throws -&gt; Int {
    let count = MemoryLayout&lt;Int&gt;.size
    var bytes = [Int8](repeating: 0, count: count)

    // Fill bytes with secure random data
    let status = SecRandomCopyBytes(
        kSecRandomDefault, 
        count, 
        &amp;bytes
    )
    
    // A status of errSecSuccess indicates success
    if status == errSecSuccess {
        // Convert bytes to Int
        let int = bytes.withUnsafeBytes { pointer in
            return pointer.load(as: Int.self)
        }

        return int
    }
    else {
        // Handle error
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="secure-random-in-swift">Secure Random in Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>SecRandomCopyBytes</code> and the Security framework you can generate secure bytes, data, and integers in Swift.</p>
<!--kg-card-end: markdown--><p></p>]]></content:encoded></item><item><title><![CDATA[Getters and Setters in Swift]]></title><description><![CDATA[Learn how to implement getters and setters for Swift properties, and learn about Swift 5.5 support for getters that can throw an error.]]></description><link>https://www.advancedswift.com/getters-setters-swift/</link><guid isPermaLink="false">60bd68f72a935b003edb559f</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Mon, 07 Jun 2021 00:56:50 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1611635395922-31a9afa796ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDIzfHx2b2xsZXliYWxsJTIwc2V0fGVufDB8fHx8MTYyMzAyNjIwNg&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1611635395922-31a9afa796ee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDIzfHx2b2xsZXliYWxsJTIwc2V0fGVufDB8fHx8MTYyMzAyNjIwNg&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Getters and Setters in Swift"><p>A getter in Swift allows access to a property, and a setter allows a property to be set. This post presents an overview of getters and setters, and examples of some Swift features related to getters and setters:</p>
<ol>
<li><a href="#automatically-generated-getters-and-setters">Automatically Generated Getters and Setters</a></li>
<li><a href="#get-getter">get Getter</a><br>
a. <a href="#get-throws-new-in-swift-55">get throws (new in Swift 5.5)</a></li>
<li><a href="#set-setter">set Setter</a></li>
<li><a href="#willset">willSet</a></li>
<li><a href="#didset">didSet</a><br>
a. <a href="#didset-cannot-be-provided-together-with-a-getter">&#x2018;didSet&#x2019; cannot be provided together with a getter</a><br>
b. <a href="#willset-cannot-be-provided-together-with-a-getter">&#x2018;willSet&#x2019; cannot be provided together with a getter</a><br>
c. <a href="#didset-cannot-be-provided-together-with-a-setter">&#x2018;didSet&#x2019; cannot be provided together with a setter</a><br>
d. <a href="#willset-cannot-be-provided-together-with-a-setter">&#x2018;willSet&#x2019; cannot be provided together with a setter</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Getters and Setters in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="automatically-generated-getters-and-setters">Automatically Generated Getters and Setters</h2><!--kg-card-begin: markdown--><p>When an instance property is defined in Swift using <code>var</code>, a getter and setter is automatically generated:</p>
<pre><code class="language-swift">class Notes {
     var canSave = false
}

notes = Notes()
notes.canSave // Getter is available
notes.canSave = true // Setter is available
</code></pre>
<p>When an instance property is defined in Swift using <code>let</code>, only a getter is available:</p>
<pre><code class="language-swift">class Store {
     let canOrder = false
}

store = Store()
store.canOrder // Getter is available

// This will not compile and cause the error:
// &quot;Cannot assign to property &apos;canSave&apos; 
//  is a &apos;let&apos; constant&quot;
store.canOrder = true
</code></pre>
<!--kg-card-end: markdown--><h2 id="get-getter">get Getter</h2><!--kg-card-begin: markdown--><p>One way to implement a variable property without an exposed setter is to indicate a variable as <code>private(set)</code>:</p>
<pre><code class="language-swift">class Store {
    private(set) var canOrder = false
}

// Create a store instance
store = Store()
store.canOrder // Getter is available

// This will not compile and cause the error:
// &quot;Cannot assign to property: &apos;canOrder&apos; 
//  setter is inaccessible&quot;
store.canOrder = true
</code></pre>
<p>Another way to implement a variable property without an exposed setter is to use <code>get</code>. Often <code>get</code> is used to expose a getter to a private property:</p>
<pre><code class="language-swift">class Store {
    private var _canOrder = false
    var canOrder: Bool {
        get { return _canOrder }
    }
}

// Create a store instance
store = Store()
store.canOrder // Getter is available

// This will not compile and cause the error:
// &quot;Cannot assign to property: &apos;canOrder&apos; 
//  is a get-only property&quot;
store.canOrder = true
</code></pre>
<!--kg-card-end: markdown--><h3 id="get-throws-new-in-swift-55">get throws (new in Swift 5.5)</h3><!--kg-card-begin: markdown--><p>Starting in Swift 5.5, <code>throws</code> is available for getters defined with <code>get</code>:</p>
<pre><code class="language-swift">class Notes {
    func isDatabaseAvailable() throws -&gt; Bool { 
        /* ... */ 
    }

    var canSave: Bool {
        get throws {
            return try isDatabaseAvailable()
        }
    }
}

notes = Notes()

do {
    if try notes.canSave {
        // Handle logic
    }
}
catch {
    // Handle error
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="set-setter">set Setter</h2><!--kg-card-begin: markdown--><p>The <code>set</code> keyword can be used to implement an explicit setter in Swift. Often <code>set</code> is used to expose a setter for a private property and apply additional logic:</p>
<pre><code class="language-swift">class Notes {
    func isDatabaseAvailable() -&gt; Bool { 
        /* ... */ 
    }

    private var _canSave = false
    var canSave: Bool {
        get { return _canSave }
        set { 
            if isDatabaseAvailable() { 
                _canSave = newValue
            }
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="willset">willSet</h2><!--kg-card-begin: markdown--><p>If explicit getters and setters using <code>get</code> and <code>set</code> are not defined, <code>willSet</code> can be used to take action <strong>before</strong> a new value is set for a property:</p>
<pre><code class="language-swift">class Notes {
    func storePreviousSaveValue(_ canSave: Bool) {}
    var canSave = false {
        willSet {
            // Inside of willSet, the property 
            // canSave will be the old value,
            // before a new one is set
            storePreviousSaveValue(canSave)
        }
    }
}

// Creates an instance of notes with
// notes.canSave initialized to false
notes = Notes()

// willSet will be called while notes.canSave is
// false, so storePreviousSaveValue is called 
// with false, then notes.canSave is set to true
notes.canSave = true
</code></pre>
<!--kg-card-end: markdown--><h2 id="didset">didSet</h2><!--kg-card-begin: markdown--><p>If explicit getters and setters using <code>get</code> and <code>set</code> are not defined, <code>didSet</code> can be used to take action <strong>after</strong> a new value is set for a property:</p>
<pre><code class="language-swift">class Notes {
    @IBOutlet var saveButton: UIButton?

    var canSave = false {
        didSet {
            // Inside of didSet, the property 
            // canSave will have the new value
            saveButton?.userInteractionEnabled = canSave
        }
    }
}

// Creates an instance of notes with
// notes.canSave initialized to false
notes = Notes()

// didSet will be called after notes.canSave is
// set to true, so saveButton?.userInteractionEnabled
// will be set to true
notes.canSave = true
</code></pre>
<!--kg-card-end: markdown--><h3 id="didset-cannot-be-provided-together-with-a-getter">&apos;didSet&apos; cannot be provided together with a getter</h3><!--kg-card-begin: markdown--><p>If only <code>didSet</code> and <code>get</code> are implemented, <code>didSet</code> will never be called because a get-only property cannot be set:</p>
<pre><code class="language-swift">var canSave: Bool {
    // This causes the compiler error:
    // &quot;&#x2018;didSet&#x2019; cannot be provided 
    //  together with a getter&quot;
    get { /* ... */ }
    didSet { /* ... */ }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="willset-cannot-be-provided-together-with-a-getter">&apos;willSet&apos; cannot be provided together with a getter</h3><!--kg-card-begin: markdown--><p>If only <code>willSet</code> and <code>get</code> are implemented, <code>willSet</code> will never be called because a get-only property cannot be set:</p>
<pre><code class="language-swift">var canSave: Bool {
    // This causes a compiler error:
    // &quot;&apos;willSet&apos; cannot be provided 
    //  together with a getter&quot;
    get { /* ... */ }
    willSet { /* ... */ }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="didset-cannot-be-provided-together-with-a-setter">&apos;didSet&apos; cannot be provided together with a setter</h3><!--kg-card-begin: markdown--><p>If only <code>didSet</code> and <code>set</code> are implemented, <code>didSet</code> should instead be implemented inside of the <code>set</code> setter:</p>
<pre><code class="language-swift">var canSave: Bool {
    // This causes a compiler error:
    // &quot;&apos;didSet&apos; cannot be provided 
    //  together with a setter&quot;
    set { /* ... */ }
    didSet { /* ... */ }
}

// This is a better alternative:
var canSave: Bool {
    set { 
        canSave = newValue

        // Add code for didSet here,
        // after a new value is set
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="willset-cannot-be-provided-together-with-a-setter">&apos;willSet&apos; cannot be provided together with a setter</h3><!--kg-card-begin: markdown--><p>If only <code>willSet</code> and <code>set</code> are implemented, <code>willSet</code> should instead be implemented inside of the <code>set</code> setter:</p>
<pre><code class="language-swift">var canSave: Bool {
    // This causes a compiler error:
    // &quot;&apos;willSet&apos; cannot be provided 
    //  together with a setter&quot;
    set { /* ... */ }
    willSet { /* ... */ }
}

// This is a better alternative:
var canSave: Bool {
    set { 
        // Add code for willSet here,
        // before a new value is set

        canSave = newValue
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="swift-getters-and-setters">Swift Getters and Setters</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>get</code>, <code>set</code>, <code>willSet</code>, and <code>didSet</code> you can implement getters and setters in Swift.</p>
<!--kg-card-end: markdown--><p></p>]]></content:encoded></item><item><title><![CDATA[Comments in Swift]]></title><description><![CDATA[Learn how to add single line, multi-line, and markdown comments in Swift, and how to add Quick Help documentation in Xcode.]]></description><link>https://www.advancedswift.com/comments-documentation-swift/</link><guid isPermaLink="false">60bd64802a935b003edb553a</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Mon, 07 Jun 2021 00:30:40 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1532594722383-b75fb8381b55?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDE1NHx8bm90ZXxlbnwwfHx8fDE2MjMwMjQ5ODc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1532594722383-b75fb8381b55?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDE1NHx8bm90ZXxlbnwwfHx8fDE2MjMwMjQ5ODc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Comments in Swift"><p>Documentation is an important part of the software development process for iOS and macOS apps. This post presents examples of the different types of comments in Swift, and an example of how to add Quick Help documentation in Xcode:</p>
<ol>
<li><a href="#single-line-comments">Single Line Comments</a></li>
<li><a href="#multi-line-comments">Multi-line Comments</a></li>
<li><a href="#markdown-comments">Markdown Comments</a><br>
a. <a href="#comparison-of-multi-line-and-markdown-comments">Comparison of Multi-line and Markdown Comments</a></li>
<li><a href="#swift-documentation-markup">Swift Documentation Markup</a></li>
<li><a href="#xcode-quick-help-documentation">Xcode Quick Help Documentation</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Comments in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="single-line-comments">Single Line Comments</h2><!--kg-card-begin: markdown--><p>A single line Swift comment is added using a <code>//</code> prefix:</p>
<pre><code class="language-swift">// Saves changes to the persistent store
func save() throws {
    try managedObjectContext.save()
}
</code></pre>
<p>Comments can be added at any level of indentation:</p>
<pre><code class="language-swift">func save() throws {
    // Saves changes to the persistent store
    try managedObjectContext.save()
}
</code></pre>
<p>Single line comments can also be added after a line of code:</p>
<pre><code class="language-swift">func save() throws {
    try managedObjectContext.save() // Saves changes
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="multi-line-comments">Multi-line Comments</h2><!--kg-card-begin: markdown--><p>One way of adding multi-line comments in Swift is the <code>/* ... */</code> syntax. The <code>/*</code> starts the multi-line comment, and the <code>*/</code> ends the multi-line comment:</p>
<pre><code class="language-swift">/* Saves changes to the persistent store
 if the context has uncommitted changes */
func save() throws {
    if managedObjectContext.hasChanges {
        try managedObjectContext.save()
    }
}
</code></pre>
<p>A multi-line comment can also be added as a combination of <code>//</code> single line comments:</p>
<pre><code class="language-swift">// Saves changes to the persistent store
// if the context has uncommitted changes
func save() throws {
    if managedObjectContext.hasChanges {
        try managedObjectContext.save()
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="markdown-comments">Markdown Comments</h2><!--kg-card-begin: markdown--><p>Xcode will render markdown comments in Swift with markdown styling applied, allowing richer details to be added to Swift documentation. Use <code>///</code> to indicate a comment with markdown styling:</p>
<pre><code class="language-swift">/// # Save
/// Saves changes to the persistent store if 
/// the context has uncommitted changes
func save() throws {
    if managedObjectContext.hasChanges {
        try managedObjectContext.save()
    }
}
</code></pre>
<p>Xcode will also parse comments using <code>/** ... */</code> syntax as markdown comments. The <code>/**</code> starts the multi-line markdown comment and the <code>*/</code> ends the multi-line markdown comment:</p>
<pre><code class="language-swift">/**
# Save
Saves changes to the persistent store if 
the context has uncommitted changes
*/
func save() throws {
    if managedObjectContext.hasChanges {
        try managedObjectContext.save()
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="comparison-of-multi-line-and-markdown-comments">Comparison of Multi-line and Markdown Comments</h3><!--kg-card-begin: markdown--><p>Markdown comment styling allows for richer documentation formatting right in Xcode:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/06/CommentStyleComparison_AdvancedSwift.png" class="kg-image" alt="Comments in Swift" loading="lazy" width="824" height="328" srcset="https://www.advancedswift.com/content/images/size/w600/2021/06/CommentStyleComparison_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/2021/06/CommentStyleComparison_AdvancedSwift.png 824w" sizes="(min-width: 720px) 720px"><figcaption>Swift Markdown Comment Style Compared To Default Comment Style</figcaption></figure><h2 id="swift-documentation-markup">Swift Documentation Markup</h2><!--kg-card-begin: markdown--><p>The Swift project includes support for documentation comments using <a href="https://github.com/apple/swift/blob/main/docs/DocumentationComments.md">Swift Markup</a>. Swift Markup defines a number of special prefixes that are used when generating Swift documentation:</p>
<ul>
<li><code>parameter x: Parameter description</code> is used to describe parameters</li>
<li><code>returns: Return description</code> is used to describe a function&#x2019;s return value</li>
<li><code>throws: Condition description</code> is used to describe under what circumstances a function will throw an error</li>
</ul>
<p>To learn about all the options available in Swift Markup, check out the <a href="https://github.com/apple/swift/blob/main/docs/DocumentationComments.md#field-extensions">Field Extensions section</a> of the Documentation Comment Syntax description in the Swift repository.</p>
<!--kg-card-end: markdown--><h2 id="xcode-quick-help-documentation">Xcode Quick Help Documentation</h2><!--kg-card-begin: markdown--><p>In Xcode, right-clicking on a function presents a <code>&#x201C;Show Quick Help&#x201D;</code> option. For many types and functions that are part of Apple frameworks, Quick Help displays a popup with useful information about the type or function:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/06/DateQuickHelp_AdvancedSwift.png" class="kg-image" alt="Comments in Swift" loading="lazy" width="1016" height="652" srcset="https://www.advancedswift.com/content/images/size/w600/2021/06/DateQuickHelp_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/06/DateQuickHelp_AdvancedSwift.png 1000w, https://www.advancedswift.com/content/images/2021/06/DateQuickHelp_AdvancedSwift.png 1016w" sizes="(min-width: 720px) 720px"><figcaption>Date Quick Help Documentation Popup</figcaption></figure><!--kg-card-begin: markdown--><p>Using Swift markdown comments and Swift Markup allows Xcode to generate Quick Help documentation for your code. For example, by using <code>///</code> to add markdown comments and Swift Markup <code>-parameter lastAPISync:</code>, <code>-throws:</code>, and <code>-returns:</code>  a Quick Help popup can be generated for the <code>save()</code> function:</p>
<pre><code class="language-swift">/// Saves changes to the persistent store if the context has uncommitted changes
///
/// - parameter lastAPISync: Date data from the API was last synced.
/// - throws: An error is thrown if unsaved context changes cannot be committed to the persistent store
/// - returns: None
///
///# Notes: #
/// 1.  If a lastAPISync Date is provided, the lastAPISync date will be added and saved to the managedObjectContext
/// 2.  If there are no unsaved changes and no lastAPISync date is provided, this function does nothing.
///
/// # Example #
/// ```
/// // Save after an API sync
/// let lastAPISync = Date()
/// save(lastAPISync: lastAPISync)
/// // Save local changes
/// save(lastAPISync: nil)
/// ```
func save(lastAPISync: Date?) throws {
    if let lastAPISync = lastAPISync {
        // ... Save last sync date to Core Data ...
    }

    if managedObjectContext.hasChanges {
        try managedObjectContext.save()
    }
}
</code></pre>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/06/CustomQuickHelp_AdvancedSwift.png" class="kg-image" alt="Comments in Swift" loading="lazy" width="1060" height="1257" srcset="https://www.advancedswift.com/content/images/size/w600/2021/06/CustomQuickHelp_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/06/CustomQuickHelp_AdvancedSwift.png 1000w, https://www.advancedswift.com/content/images/2021/06/CustomQuickHelp_AdvancedSwift.png 1060w" sizes="(min-width: 720px) 720px"><figcaption>Custom Quick Help Documentation Popup</figcaption></figure><!--kg-card-begin: markdown--><p>Similarly, the same Quick Help tooltip can also be added by defining markdown comments using <code>/** ... */</code>:</p>
<pre><code class="language-swift">/**
 Saves changes to the persistent store if the context has uncommitted changes

- parameter lastAPISync: Date data from the API was last synced.
- throws: An error is thrown if unsaved context changes cannot be committed to the persistent store
- returns: None

 # Notes: #
 1.  If a lastAPISync Date is provided, the lastAPISync date will be added and saved to the managedObjectContext
 2.  If there are no unsaved changes and no lastAPISync date is provided, this function does nothing.

 # Example #
```
 // Save after an API sync
 let lastAPISync = Date()
 save(lastAPISync: lastAPISync)
 
 // Save local changes
 save(lastAPISync: nil)
```
*/
func save(lastAPISync: Date?) throws {
    if let lastAPISync = lastAPISync {
        // ... Save last sync date to Core Data ...
    }

    if managedObjectContext.hasChanges {
        try managedObjectContext.save()
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="documentation-markup-in-swift">Documentation Markup In Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using Swift Markup and single line, multi-line, and markdown comments you can document your code and add Xcode Quick Help to your Swift project.</p>
<!--kg-card-end: markdown--><p></p>]]></content:encoded></item><item><title><![CDATA[Async / Await in Swift]]></title><description><![CDATA[Learn how to use async and await in Swift by example. Async and await are new Swift 5.5 keywords to help implement asynchronous programming.]]></description><link>https://www.advancedswift.com/async-await/</link><guid isPermaLink="false">60b31f8c2a935b003edb53b7</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 30 May 2021 05:43:32 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1595265616410-a6119ff0c87e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDEwMHx8bWFpbHxlbnwwfHx8fDE2MjIzNTE5MjA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1595265616410-a6119ff0c87e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDEwMHx8bWFpbHxlbnwwfHx8fDE2MjIzNTE5MjA&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Async / Await in Swift"><p>Rich iOS and macOS experiences often perform asynchronous tasks, like getting data from a remote server. New in Swift 5.5, the <code>async</code> and <code>await</code> keywords enable developers to simplify asynchronous code and make it easier to implement asynchronous tasks. This post presents an overview of <code>async</code> and <code>await</code> with an example:</p>
<ol>
<li><a href="#async">Async</a><br>
a. <a href="#async-throws">Async Throws</a><br>
b. <a href="#async-return-value">Async Return Value</a></li>
<li><a href="#await">Await</a><br>
a. <a href="#await-throws">Await Throws</a></li>
<li><a href="#async-let">Async Let</a><br>
a. <a href="#async-await-let">Async Await Let</a></li>
<li><a href="#async-await-example">Async Await Example</a><br>
a. <a href="#call-async-function-from-non-async-code">Call Async Function From Non Async Code</a><br>
b. <a href="#async-await-vs-closures">Async Await vs Closures</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Async / Await in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="async">Async</h2><!--kg-card-begin: markdown--><p>In previous versions of Swift, asynchronous programming was often implemented through the use of completion blocks:</p>
<pre><code class="language-swift">// The completion block will be called when
// saveChanges completes its asynchronous logic
func saveChanges(completion: (() -&gt; Void)?) { ... }

// In other code, the saveChanges function would
// be called like this:
saveChanges {
    // Handle completion
}
</code></pre>
<p>Using the new <code>async</code> keyword, Swift can mark a function as having asynchronous logic:</p>
<pre><code class="language-swift">// Swift automatically handles asynchronous
// completion of saveChanges
func saveChanges() async { ... }

// In other code, the async saveChanges function
// would be called like this:
await saveChanges()
</code></pre>
<!--kg-card-end: markdown--><h3 id="async-throws">Async Throws</h3><!--kg-card-begin: markdown--><p>In previous versions of Swift, some completion blocks returned errors indicating the asynchronous logic in a function could potentially result in an error:</p>
<pre><code class="language-swift">func attachImageToData(
    imageResponse: URLResponse, 
    dataResponse: URLResponse, 
    completion: ((Error?) -&gt; Void)?
)
</code></pre>
<p>Using <code>async</code> allows the <code>attachImageToData</code> function to utilize <code>throws</code>, matching the syntax other non-asynchronous functions use for errors:</p>
<pre><code class="language-swift">func attachImageToData(
    imageResponse: URLResponse, 
    dataResponse: URLResponse) async throws
</code></pre>
<!--kg-card-end: markdown--><h3 id="async-return-value">Async Return Value</h3><!--kg-card-begin: markdown--><p>In previous versions of Swift, some completion blocks contained other types in addition to a potential error. These other types were often logically the return type of asynchronous logic:</p>
<pre><code class="language-swift">func uploadImage(
    image: UIImage, 
    completion: ((URLResponse?, Error?) -&gt; Void)?
)

func uploadData(
    data: Data, 
    completion: ((URLResponse?, Error?) -&gt; Void)?
)
</code></pre>
<p>Using <code>async</code> allows the <code>uploadImage</code> and <code>uploadData</code> functions to utilize the expected return type definition <code>-&gt; URLResponse</code>, matching the syntax of other non-asynchronous functions:</p>
<pre><code class="language-swift">func uploadImage(image: UIImage) 
    async throws -&gt; URLResponse
    
func uploadData(data: Data)
    async throws -&gt; URLResponse
</code></pre>
<!--kg-card-end: markdown--><h2 id="await">Await</h2><!--kg-card-begin: markdown--><p>The <code>await</code> keyword is used to tell Swift to wait for completion of an asynchronous function:</p>
<pre><code class="language-swift">// Await completion of saveChanges
await saveChanges()
</code></pre>
<p>If multiple <code>async</code> functions are called using <code>await</code>, Swift will wait for completion of each function before moving onto the next function:</p>
<pre><code class="language-swift">// Await completion of uploadData 
// before moving to saveChanges
await uploadData(data: Data())

// Await completion of saveChanges 
// before moving forward
await saveChanges()
</code></pre>
<!--kg-card-end: markdown--><h3 id="await-throws">Await Throws</h3><!--kg-card-begin: markdown--><p>Like non-asynchronous functions that can throw, <code>try</code> can be used for asynchronous functions in combination with <code>await</code> to call the asynchronous function and throw if an error occurs:</p>
<pre><code class="language-swift">try await attachImageToData(
    imageResponse: imageResponse, 
    dataResponse: dataResponse
)
</code></pre>
<!--kg-card-end: markdown--><h2 id="async-let">Async Let</h2><!--kg-card-begin: markdown--><p>In some cases, <code>async</code> logic requires the return value from an asynchronous function. The <code>async let</code> syntax can be used to mark a <code>let</code> variable as asynchronous, meaning the <code>let</code> variable will be available after some asynchronous logic completes:</p>
<pre><code class="language-swift">async let imageResponse = try uploadImage(
    image: image
)
</code></pre>
<!--kg-card-end: markdown--><h3 id="async-await-let">Async Await Let</h3><!--kg-card-begin: markdown--><p>Combining multiple <code>async let</code> statements will enable Swift to perform asynchronous logic in parallel:</p>
<pre><code class="language-swift">// Both imageResponse and dataResponse will
// be obtained in parallel
async let imageResponse = try uploadImage(
    image: image
)

async let dataResponse = try uploadData(
    data: data
)
</code></pre>
<p>To wait for completion of previous <code>async let</code> variables, use <code>await</code> when the <code>let</code> variable is required to have been initialized:</p>
<pre><code class="language-swift">try await attachImageToData(
    imageResponse: await imageResponse, 
    dataResponse: await dataResponse
)
</code></pre>
<p>Alternatively, use <code>await</code> to control concurrency and get only one value at a time:</p>
<pre><code class="language-swift">// By using await, uploadImage 
// will be called first
let imageResponse = try await uploadImage(
    image: image
)

// By using await on uploadImage, 
// uploadData will be called after 
// imageResponse is initialized
let dataResponse = try await uploadData(
    data: data
)
</code></pre>
<!--kg-card-end: markdown--><h2 id="async-await-example">Async Await Example</h2><!--kg-card-begin: markdown--><p>The async await example presented in this post will reference the following <code>async</code> functions:</p>
<pre><code class="language-swift">func uploadImage(image: UIImage) 
    async -&gt; URLResponse

func uploadData(data: Data) 
     async throws -&gt; URLResponse

func attachImageToData(
    imageResponse: URLResponse, 
    dataResponse: URLResponse) async throws

func saveChanges() async throws
</code></pre>
<p>Async await example combining multiple <code>async</code> calls and return values:</p>
<pre><code class="language-swift">// Define an asynchronous function uploadTask that 
// will contain multiple async function calls
func uploadTask(
    image: UIImage, 
    data: Data) async throws {

    // Perform the following async functions 
    // at the same time
    async let imageResponse = try uploadImage(
        image: image
    )

    async let dataResponse = try uploadData(
        data: data
    )
    
    // Wait for completion of attachImageToData 
    // before moving forward
    try await attachImageToData(
        imageResponse: await imageResponse, 
        dataResponse: await dataResponse
    )

    // Wait for completion of saveChanges 
    // before moving forward
    try await saveChanges()
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="call-async-function-from-non-async-code">Call Async Function From Non Async Code</h3><!--kg-card-begin: markdown--><p>Initialize a <code>Task</code> to make calls to <code>async</code> functions from non-async code:</p>
<pre><code class="language-swift">func userTappedUpload() {
    Task(priority: .default) {
        do {
            try await self.upload(
                image: UIImage(), 
                data: Data()
            )
        }
        catch {
            // Handle error
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="async-await-vs-closures">Async Await vs Closures</h3><!--kg-card-begin: markdown--><p>One benefit of using <code>async</code> and <code>await</code> is easier to read Swift code. If the <code>async</code> function <code>uploadTask</code> presented in this post is rewritten to only use completion closures, the function has a deep nested callback structure that is hard to read:</p>
<pre><code class="language-swift">func uploadTask(
    image: UIImage, 
    data: Data, 
    completion: ((Error?) -&gt; Void)?) {

    uploadImage(image: image) { imageResponse in
        // Verify imageResponse is successful
        
        self.uploadData(data: data) { 
            dataResponse, dataError in

            // Handle dataError if dataError != nil
            
            self.attachImageToData(
                imageResponse: imageResponse!, 
                dataResponse: dataResponse!) { 
                attachError in

                // Handle attachError if 
                // attachError != nil
                
                self.saveChanges() {
                    completion?(nil)
                }
            }
        }
    }
}

// Example calling upload
upload(image: UIImage(), data: Data()) { error in
    if let error = error {
        // Handle error
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="asynchronous-programming-in-swift">Asynchronous Programming In Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>async</code> and <code>await</code> you can implement asynchronous tasks with callbacks and asynchronous logic in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Crop UIImage In Swift]]></title><description><![CDATA[Learn how to crop UIImages in Swift to different boundaries, including centering and circular crops like social media apps.]]></description><link>https://www.advancedswift.com/crop-image/</link><guid isPermaLink="false">60aabd409c4b28003b6f40e6</guid><category><![CDATA[UI]]></category><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 23 May 2021 21:01:24 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1511367461989-f85a21fda167?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDR8fGNpcmNsZXxlbnwwfHx8fDE2MjE3OTk5NTc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1511367461989-f85a21fda167?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDR8fGNpcmNsZXxlbnwwfHx8fDE2MjE3OTk5NTc&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Crop UIImage In Swift"><p>Cropping images is common across iOS and macOS, especially cropping user profile images in social media apps. This post presents examples for cropping images in Swift, including a center and circle crop:</p>
<ol>
<li><a href="#crop-image">Crop Image</a><br>
a. <a href="#center-crop-image">Center Crop Image</a><br>
b. <a href="#crop-uiimage">Crop UIImage</a></li>
<li><a href="#crop-image-to-circle">Crop Image To Circle</a></li>
</ol>
<!--kg-card-end: markdown--><p>Note: this post will focus on cropping images. If you would like to learn about changing an image&apos;s size, check out this post:</p><figure class="kg-card kg-bookmark-card"><a class="kg-bookmark-container" href="https://www.advancedswift.com/resize-uiimage-no-stretching-swift/"><div class="kg-bookmark-content"><div class="kg-bookmark-title">Resize UIImage Without Stretching in Swift</div><div class="kg-bookmark-description">Learn how to scale a UIImage to a target size while keeping the aspect ratio the same</div><div class="kg-bookmark-metadata"><img class="kg-bookmark-icon" src="https://www.advancedswift.com/favicon.ico" alt="Crop UIImage In Swift"><span class="kg-bookmark-author">Advanced Swift</span><span class="kg-bookmark-publisher">Robert Pieta</span></div></div><div class="kg-bookmark-thumbnail"><img src="https://images.unsplash.com/photo-1514214089800-6f1f3ae37854?ixlib=rb-1.2.1&amp;q=80&amp;fm=jpg&amp;crop=entropy&amp;cs=tinysrgb&amp;w=2000&amp;fit=max&amp;ixid=eyJhcHBfaWQiOjExNzczfQ" alt="Crop UIImage In Swift"></div></a></figure><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Crop UIImage In Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="crop-image">Crop Image</h2><!--kg-card-begin: markdown--><p>A center crop takes an existing image and crops the image to a shape showing the center of the image. In the following example, a center square crop will be applied to a rectangular image.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/RectangularCroppedImage_AdvancedSwift.png" class="kg-image" alt="Crop UIImage In Swift" loading="lazy" width="1200" height="545" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/RectangularCroppedImage_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/RectangularCroppedImage_AdvancedSwift.png 1000w, https://www.advancedswift.com/content/images/2021/05/RectangularCroppedImage_AdvancedSwift.png 1200w" sizes="(min-width: 720px) 720px"><figcaption>Center Rectangular Cropped Image Example</figcaption></figure><h3 id="center-crop-image">Center Crop Image</h3><!--kg-card-begin: markdown--><p>The <code>CGImage</code> method <code>cropping(to:)</code> can be used to perform a rectangular crop:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let sourceImage = UIImage(
    named: &quot;imageNameInBundle&quot;
)!

// The shortest side
let sideLength = min(
    sourceImage.size.width,
    sourceImage.size.height
)

// Determines the x,y coordinate of a centered 
// sideLength by sideLength square 
let sourceSize = sourceImage.size
let xOffset = (sourceSize.width - sideLength) / 2.0
let yOffset = (sourceSize.height - sideLength) / 2.0

// The cropRect is the rect of the image to keep, 
// in this case centered
let cropRect = CGRect(
    x: xOffset,
    y: yOffset,
    width: sideLength,
    height: sideLength
).integral

// Center crop the image
let sourceCGImage = sourceImage.cgImage!
let croppedCGImage = sourceCGImage.cropping(
    to: cropRect
)!
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>This visualization provides a reference for the geometry applied in this example code:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/RectangularCrop_AdvancedSwift.png" class="kg-image" alt="Crop UIImage In Swift" loading="lazy" width="1200" height="600" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/RectangularCrop_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/RectangularCrop_AdvancedSwift.png 1000w, https://www.advancedswift.com/content/images/2021/05/RectangularCrop_AdvancedSwift.png 1200w" sizes="(min-width: 720px) 720px"><figcaption>Center Rectangle Crop Example Geometry</figcaption></figure><h3 id="crop-uiimage">Crop UIImage</h3><!--kg-card-begin: markdown--><p>To obtain a <code>UIImage</code> from cropped <code>CGImage</code> <code>croppedCGImage</code>, use the <code>imageRenderFormat.scale</code> and <code>imageOrientation</code> of the source image <code>sourceImage</code>:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// Center crop the image
let sourceCGImage = sourceImage.cgImage!
let croppedCGImage = sourceCGImage.cropping(
    to: cropRect
)!

// Use the cropped cgImage to initialize a cropped 
// UIImage with the same image scale and orientation
let croppedImage = UIImage(
    cgImage: croppedCGImage,
    scale: sourceImage.imageRendererFormat.scale,
    orientation: sourceImage.imageOrientation
)
</code></pre>
<!--kg-card-end: markdown--><h2 id="crop-image-to-circle">Crop Image To Circle</h2><!--kg-card-begin: markdown--><p><code>UIGraphicsImageRenderer</code> and <code>UIBezierPath</code> can be used to circle crop a <code>UIImage</code> in Swift . In the following example, a centered circular crop will be applied to a rectangular image.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/CircularCroppedImage_AdvancedSwift.png" class="kg-image" alt="Crop UIImage In Swift" loading="lazy" width="1200" height="545" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/CircularCroppedImage_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/CircularCroppedImage_AdvancedSwift.png 1000w, https://www.advancedswift.com/content/images/2021/05/CircularCroppedImage_AdvancedSwift.png 1200w" sizes="(min-width: 720px) 720px"><figcaption>Center Circular Cropped Image Example</figcaption></figure><!--kg-card-begin: markdown--><pre><code class="language-swift">// This example uses xOffset, yOffset, cropRect, 
// sourceImage, and croppedCGImage as computed in the 
// Center Crop Image example earlier in this post

// Start with the result of the Center Crop 
// Image example
let sourceCGImage = sourceImage.cgImage!
let croppedCGImage = sourceCGImage.cropping(
    to: cropRect
)!

// A circular crop results in some transparency in the 
// cropped image, so set opaque to false to ensure the 
// cropped image does not include a background fill
let imageRendererFormat = sourceImage.imageRendererFormat
imageRendererFormat.opaque = false

// UIGraphicsImageRenderer().image provides a block 
// interface to draw into in a new UIImage
let circleCroppedImage = UIGraphicsImageRenderer(  
    // The cropRect.size is the size of 
    // the resulting circleCroppedImage
    size: cropRect.size, 
    format: imageRendererFormat).image { context in
   
    // The drawRect is the cropRect starting at (0,0)
    let drawRect = CGRect(
        origin: .zero,
        size: cropRect.size
    )
 
    // addClip on a UIBezierPath will clip all contents 
    // outside of the UIBezierPath drawn after addClip 
    // is called, in this case, drawRect is a circle so
    // the UIBezierPath clips drawing to the circle
    UIBezierPath(ovalIn: drawRect).addClip()

    // The drawImageRect is offsets the image&#x2019;s bounds 
    // such that the circular clip is at the center of 
    // the image
    let drawImageRect = CGRect(
        origin: CGPoint(
            x: -xOffset, 
            y: -yOffset
        ),
        size: sourceImage.size
    )

    // Draws the sourceImage inside of the 
    // circular clip
    sourceImage.draw(in: drawImageRect)
}
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>This visualization provides a reference for the geometry applied in this example code:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/CircularCrop_AdvancedSwift.png" class="kg-image" alt="Crop UIImage In Swift" loading="lazy" width="1200" height="600" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/CircularCrop_AdvancedSwift.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/CircularCrop_AdvancedSwift.png 1000w, https://www.advancedswift.com/content/images/2021/05/CircularCrop_AdvancedSwift.png 1200w" sizes="(min-width: 720px) 720px"><figcaption>Center Circular Crop Example Geometry</figcaption></figure><h2 id="swift-crop-image-programmatically">Swift Crop Image Programmatically</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>UIGraphicsImageRenderer</code>, <code>UIBezierPath</code>, and <code>UIImage</code> you can crop images to different shapes and orientations in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Core Data Fetched Property Example In Swift]]></title><description><![CDATA[Learn about fetched properties in Core Data with commented example code, and about alternatives to fetched properties in Swift.]]></description><link>https://www.advancedswift.com/fetched-property-core-data/</link><guid isPermaLink="false">6097695d1b9361003bc5ab85</guid><category><![CDATA[Swift]]></category><category><![CDATA[databases]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 09 May 2021 05:02:36 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1599989608945-78daa3364b1e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDY2fHxnaWZ0fGVufDB8fHx8MTYyMDUzNTc1Nw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1599989608945-78daa3364b1e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDY2fHxnaWZ0fGVufDB8fHx8MTYyMDUzNTc1Nw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Core Data Fetched Property Example In Swift"><p>Fetched properties are a feature of Core Data, similar in concept to computed properties on Swift objects. This post presents an overview of fetched properties in Core Data with an example, and provides an alternative implementation:</p>
<ol>
<li><a href="#core-data-fetched-properties">Core Data Fetched Properties</a></li>
<li><a href="#fetched-property-example">Fetched Property Example</a></li>
<li><a href="#alternative-to-core-data-fetched-properties">Alternative To Core Data Fetched Properties</a></li>
</ol>
<!--kg-card-end: markdown--><h2 id="core-data-fetched-properties">Core Data Fetched Properties</h2><!--kg-card-begin: markdown--><p>Fetched Properties in Core Data are properties that return an array value from a predicate. A fetched property predicate is a Core Data query that evaluates to an array of results. In this blog post, a fetched property called <code>contractors</code> will be created on a <code>Business</code> entity that will return an array of all <code>People</code> in the <code>Business</code> that are contractors.</p>
<!--kg-card-end: markdown--><h2 id="fetched-property-example">Fetched Property Example</h2><!--kg-card-begin: markdown--><p>First, create a Core Data model with two entities: <code>Person</code> and <code>Business</code>. <code>Person</code> has <code>name</code> and <code>type</code> <code>String</code> attributes. <code>Business</code> has a <code>name</code> <code>String</code> attribute. <code>Business</code> also has a one-to-many relationship <code>people</code> to <code>Person</code>, the inverse is the <code>job</code> relationship on <code>Person</code>. Adding the <code>Person</code> and <code>Business</code> entities to a Core Data model should look like this:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/CoreDataBusinessEntity.png" class="kg-image" alt="Core Data Fetched Property Example In Swift" loading="lazy" width="1728" height="836" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/CoreDataBusinessEntity.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/CoreDataBusinessEntity.png 1000w, https://www.advancedswift.com/content/images/size/w1600/2021/05/CoreDataBusinessEntity.png 1600w, https://www.advancedswift.com/content/images/2021/05/CoreDataBusinessEntity.png 1728w" sizes="(min-width: 720px) 720px"><figcaption>Core Data Business Entity</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/CoreDataPersonEntity.png" class="kg-image" alt="Core Data Fetched Property Example In Swift" loading="lazy" width="1732" height="842" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/CoreDataPersonEntity.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/CoreDataPersonEntity.png 1000w, https://www.advancedswift.com/content/images/size/w1600/2021/05/CoreDataPersonEntity.png 1600w, https://www.advancedswift.com/content/images/2021/05/CoreDataPersonEntity.png 1732w" sizes="(min-width: 720px) 720px"><figcaption>Core Data Person Entity</figcaption></figure><!--kg-card-begin: markdown--><p>Next, add a fetched property <code>contractors</code> to <code>Business</code>. This can be done by clicking the <code>+</code> button under the <code>Fetched Properties</code> section in <code>Business</code> entity. Name the fetched property <code>contractors</code> and enter the following query for the predicate:</p>
<pre><code>type LIKE [c] &quot;contractor&quot; AND job == $FETCH_SOURCE
</code></pre>
<p>You may be wondering what <code>LIKE [c]</code> and <code>$FETCH_SOURCE</code> mean. This post presents an example of Fetched Properties for reference, but there are other implementations to consider that do not use complex query language. Please make sure to read the <a href="#alternative-to-core-data-fetched-properties">Alternative To Core Data Fetched Properties</a> section below! If you determine fetched properties are the right approach for you, the Apple Core Data Documentation on <a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreData/HowManagedObjectsarerelated.html#//apple_ref/doc/uid/TP40001075-CH17-SW13">Weak Relationships (Fetched Properties)</a> goes into detail about predicate syntax specific to fetched properties.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Adding the <code>contractors</code> fetched property on the <code>Business</code> entity will look like:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/05/CoreDataFetchedProperty.png" class="kg-image" alt="Core Data Fetched Property Example In Swift" loading="lazy" width="1326" height="304" srcset="https://www.advancedswift.com/content/images/size/w600/2021/05/CoreDataFetchedProperty.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/05/CoreDataFetchedProperty.png 1000w, https://www.advancedswift.com/content/images/2021/05/CoreDataFetchedProperty.png 1326w" sizes="(min-width: 720px) 720px"><figcaption>Core Data Fetched Property Predicate</figcaption></figure><!--kg-card-begin: markdown--><p>Now, the fetched property can be used in Swift:</p>
<pre><code class="language-swift">// Get Core Data managed object context
let delegate = UIApplication.shared.delegate as! AppDelegate
let context = delegate.persistentContainer.viewContext

// Create People core data models
let steve = Person(context: context)
steve.name = &quot;Steve&quot;
steve.type = &quot;contractor&quot;

let tim = Person(context: context)
tim.name = &quot;Tim&quot;
tim.type = &quot;employee&quot;

let amelia = Person(context: context)
amelia.name = &quot;Amelia&quot;
amelia.type = &quot;contractor&quot;

// Create a Business core data model
let business = Business(context: context)
business.name = &quot;Orange Computers&quot;

business.addToPeople(tim)
business.addToPeople(steve)
business.addToPeople(amelia)

// Save context
try! context.save()

// Use fetched property
let contractors = business.value(forKey: &quot;contractors&quot;)
    as! [Person]

for person in contractors {
    print(person.name)
}

// Expected output:
// Steve
// Amelia
</code></pre>
<!--kg-card-end: markdown--><h2 id="alternative-to-core-data-fetched-properties">Alternative To Core Data Fetched Properties</h2><!--kg-card-begin: markdown--><p>A Core Data fetched property has some drawbacks that developers should be aware of:</p>
<ol>
<li>Debugging fetched properties is more difficult than debugging Swift code, and in some cases no errors are logged even if a fetched property resulted in an error</li>
<li>Fetched properties cannot take arguments the same way as Swift functions can</li>
<li>Fetched properties are cached when evaluated, meaning fetched properties may not always return the expected value without refreshing the object.</li>
</ol>
<p>Implementing a computed property in a Swift Core Data model extension is often a clear, more intuitive way to implement a fetched property. Here is an alternative example implementation that produces the same result as the fetched property example without the drawbacks:</p>
<pre><code class="language-swift">// Extend the Business entity
extension Business {
    // Create a contractors computed property
    var contractors: [Person] {
        // Use a predicate to filter the people relationship
        let predicate = NSPredicate(
            format: &quot;type LIKE [c] %@&quot;, &quot;contractor&quot;
        )

        return Array(people!.filtered(using: predicate))
            as! [Person]
    }
}
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Core Data Fetched Property Example In Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="fetched-properties-in-core-data">Fetched Properties In Core Data</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! In some cases core data fetched properties may provide a useful way to execute predicates, but there is often a better implementation without the drawbacks associated with fetched properties in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[OrderedDictionary In Swift]]></title><description><![CDATA[Learn how and when to use OrderedDictionary, provided by the swift-collections package, in Swift.]]></description><link>https://www.advancedswift.com/ordereddictionary/</link><guid isPermaLink="false">60736c7b6a9747003b86864b</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 11 Apr 2021 21:50:15 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1607296393394-6e25d0fc15cc?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDIzfHxvcmRlcnxlbnwwfHx8fDE2MTgxNzU5NTI&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1607296393394-6e25d0fc15cc?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDIzfHxvcmRlcnxlbnwwfHx8fDE2MTgxNzU5NTI&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="OrderedDictionary In Swift"><p>Many iOS and macOS applications use <code>Dictionary</code> for internal logic. A new Swift package called <a href="https://github.com/apple/swift-collections">swift-collections</a> introduces <code>OrderedDictionary</code>, a dictionary which keeps track of insertion order. This post presents an overview of <code>OrderedDictionary</code> and usage examples:</p>
<ol>
<li><a href="#ordereddictionary-examples">OrderedDictionary Examples</a><br>
a. <a href="#insert-value-for-key">Insert Value For Key</a><br>
b. <a href="#get-value-for-key">Get Value For Key</a><br>
c. <a href="#remove-key-and-value">Remove Key and Value</a></li>
<li><a href="#dictionary-vs-ordereddictionary">Dictionary vs OrderedDictionary</a><br>
a. <a href="#ordereddictionary-maintains-insertion-order">OrderedDictionary Maintains Insertion Order</a></li>
<li><a href="#when-to-use-ordereddictionary">When To Use OrderedDictionary</a><br>
a. <a href="#ordered-counters">Ordered Counters</a><br>
b. <a href="#random-access-to-unique-ordered-elements">Random Access To Unique, Ordered Elements</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Note: To use <code>OrderedDictionary</code>, first add the <code>swift-collections</code> Swift package to your project. Then, import the <code>OrderedCollections</code> module:</p>
<pre><code class="language-swift">import OrderedCollections
</code></pre>
<!--kg-card-end: markdown--><h2 id="ordereddictionary-examples">OrderedDictionary Examples</h2><h3 id="insert-value-for-key">Insert Value For Key</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">var orderedDict: OrderedDictionary = [
    &quot;key0&quot;: 0,
    &quot;key1&quot;: 1
]

orderedDict[&quot;key2&quot;] = 2

// orderedDict now contains, in order,
// &quot;key0&quot;: 0, &quot;key1&quot;: 1, &quot;key2&quot;: 2
</code></pre>
<!--kg-card-end: markdown--><h3 id="get-value-for-key">Get Value For Key</h3><!--kg-card-begin: markdown--><p>Like a traditional <code>Dictionary</code>, <code>OrderedDictionary</code> is a key-value store and can retrieve values using a specified key:</p>
<pre><code class="language-swift">var orderedDict: OrderedDictionary = [
    &quot;key0&quot;: 0,
    &quot;key1&quot;: 1
]

// Returns the value 1
orderedDict[&quot;key1&quot;]
</code></pre>
<p>Additionally, <code>OrderedDictionary</code> has an internal order and can retrieve values at a specific position in the order using the elements property:</p>
<pre><code class="language-swift">// Returns the element at index 0
var element = orderedDict.elements[0]
element.key // &quot;key0&quot;
element.value // 0
</code></pre>
<!--kg-card-end: markdown--><h3 id="remove-key-and-value">Remove Key and Value</h3><!--kg-card-begin: markdown--><p>There are multiple ways to remove keys and values from an <code>OrderedDictionary</code>. One way is to remove a key and value explicitly, either specifying the key directly or the index the key and value are at:</p>
<pre><code class="language-swift">// Remove a specific key
orderedDict.removeValue(forKey: &quot;key1&quot;)

// Remove a key and value at a specific index
orderedDict.remove(at: 2)
</code></pre>
<p>Another method is to remove keys and values relative to the front and back of the <code>OrderedDictionary</code>:</p>
<pre><code class="language-swift">// Remove keys and values from the front
orderedSet.removeFirst()
orderedSet.removeFirst(2)

// Remove keys and values from the back
orderedSet.removeLast()
orderedSet.removeLast(2)
</code></pre>
<p><code>OrderedDictionary</code> also includes methods for removing all keys and values, and removing all keys and values that meet some filter criteria:</p>
<pre><code class="language-swift">// Remove all keys and values
orderedDict.removeAll()

// Filter keys and values
orderedDict.removeAll { (key, value) -&gt; Bool in
    // Filter criteria
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="dictionary-vs-ordereddictionary">Dictionary vs OrderedDictionary</h2><!--kg-card-begin: markdown--><p><code>Dictionary</code> is an unordered collection of keys and associated values, often used as a key-value store. Like <code>Dictionary</code>, <code>OrderedDictionary</code> contains keys and associated values and can be used as a key-value store. Unlike <code>Dictionary</code>:</p>
<!--kg-card-end: markdown--><h3 id="ordereddictionary-maintains-insertion-order">OrderedDictionary Maintains Insertion Order</h3><!--kg-card-begin: markdown--><p>As the name indicates, <code>OrderedDictionary</code> maintains key and value insertion order. This means an <code>OrderedDictionary</code> can efficiently retrieve a value for a specific key, like a traditional <code>Dictionary</code>, and also retrieve a key and value at a specific position, similar to a traditional <code>Array</code>.</p>
<p>To maintain key and value order, <code>OrderedDictionary</code> introduces an <code>elements</code> property. The <code>elements</code> property is an <code>Array</code> value, and can be used to iterate over or retrieve keys and values at a specific position in the order.</p>
<p>An important note, reassigning keys to different values does not change the order:</p>
<pre><code class="language-swift">var orderedDict: OrderedDictionary = [
    &quot;key0&quot;: 0,
    &quot;key1&quot;: 1,
    &quot;key2&quot;: 2
]

// orderedDict contains, in order,
// &quot;key0&quot;: 0, &quot;key1&quot;: 1, &quot;key2&quot;: 2

orderedDict[&quot;key1&quot;] = 100

// orderedDict contains, in order,
// &quot;key0&quot;: 0, &quot;key1&quot;: 100, &quot;key2&quot;: 2
</code></pre>
<!--kg-card-end: markdown--><h2 id="when-to-use-ordereddictionary">When To Use OrderedDictionary</h2><h3 id="ordered-counters">Ordered Counters</h3><!--kg-card-begin: markdown--><p>A counter is often used to determine the number of occurrences unique elements have in a sequence. An ordered counter allows the occurrences of unique elements to be counted, while also preserving the first-seen order:</p>
<pre><code class="language-swift">var sequence = [
    &quot;a&quot;, &quot;b&quot;, &quot;a&quot;, &quot;c&quot;, &quot;b&quot;, &quot;b&quot;, &quot;b&quot;, &quot;a&quot;
]

var orderedCounter: OrderedDictionary&lt;String,Int&gt; = [:]

for item in sequence {
    orderedCounter[item, default: 0] += 1
}

// orderedCounter now contains, in order,
// &quot;a&quot;: 3, &quot;b&quot;: 4, &quot;c&quot;: 1

// Accessing the key &quot;b&quot; returns 4, the number of 
// times &quot;b&quot; occurs in the sequence
orderedCounter[&quot;b&quot;]

// Accessing the position 0 returns the element
// &quot;a&quot;: 3, indicating &quot;a&quot; occurred first in the sequence
// and occurred a total of 3 times
var element = orderedCounter.elements[1]
element.key // &quot;a&quot;
element.value // 3
</code></pre>
<!--kg-card-end: markdown--><h3 id="random-access-to-unique-ordered-elements">Random Access To Unique, Ordered Elements</h3><!--kg-card-begin: markdown--><p>When working with unique sequences, like time-series, it is often useful to access the elements of the unique sequence in order and using a unique identifier. <code>OrderedDictionary</code> provides a type that can do both:</p>
<pre><code class="language-swift">var timeSeries = [
    [&quot;id&quot;: &quot;t0&quot;, &quot;value&quot;: &quot;0.1&quot;],
    [&quot;id&quot;: &quot;t1&quot;, &quot;value&quot;: &quot;1.1&quot;],
    [&quot;id&quot;: &quot;t2&quot;, &quot;value&quot;: &quot;2.1&quot;]
]

var series: OrderedDictionary&lt;String, Dictionary&lt;String,String&gt;&gt; = [:]

for datapoint in timeSeries {
    series[datapoint[&quot;id&quot;]!] = datapoint
}

// Accessing the key &quot;t1&quot; returns the datapoint
// associated with the id &quot;t1&quot;
series[&quot;t1&quot;] // [&quot;id&quot;: &quot;t1&quot;, &quot;value&quot;: &quot;1.1&quot;]

// Accessing the element at index 2 returns 
// the element associated with index 2 in the
// time series
var element = series.elements[2]
element.key // &quot;t2&quot;
element.value // [&quot;id&quot;: &quot;t2&quot;, &quot;value&quot;: &quot;2.1&quot;]
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="OrderedDictionary In Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="swift-ordereddictionary">Swift OrderedDictionary</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using the <code>swift-collections</code> package and <code>OrderedDictionary</code>, you can take advantage of both <code>Dictionary</code> key-value store properties and element ordering in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[OrderedSet In Swift]]></title><description><![CDATA[Learn how and when to use OrderedSet, provided by the swift-collections package, in Swift.]]></description><link>https://www.advancedswift.com/orderedset/</link><guid isPermaLink="false">607367bb6a9747003b8685db</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 11 Apr 2021 21:32:16 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1542044211-723ee4dada2d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI3fHxvcmRlcnxlbnwwfHx8fDE2MTgxNzU5NTI&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1542044211-723ee4dada2d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDI3fHxvcmRlcnxlbnwwfHx8fDE2MTgxNzU5NTI&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="OrderedSet In Swift"><p>Many iOS and macOS applications use <code>Set</code> for internal logic. A new Swift package called <a href="https://github.com/apple/swift-collections">swift-collections</a> introduces <code>OrderedSet</code>, a set which keeps track of insertion order. This post presents an overview of <code>OrderedSet</code> and usage examples:</p>
<ol>
<li><a href="#orderedset-examples">OrderedSet Examples</a><br>
a. <a href="#insert-element">Insert Element</a><br>
b. <a href="#get-element">Get Element</a><br>
c. <a href="#remove-element">Remove Element</a><br>
d. <a href="#union">Union</a><br>
e. <a href="#intersection">Intersection</a></li>
<li><a href="#set-vs-orderedset">Set vs OrderedSet</a><br>
a. <a href="#orderedset-maintains-insert-order">OrderedSet Maintains Insert Order</a><br>
b. <a href="#orderedset-insert-performance-differs">OrderedSet Insert Performance Differs</a></li>
<li><a href="#when-to-use-orderedset">When To Use OrderedSet</a><br>
a. <a href="#time-series-deduplication">Time-Series Deduplication</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Note: To use <code>OrderedSet</code>, first add the <code>swift-collections</code> Swift package to your project. Then, import the <code>OrderedCollections</code> module:</p>
<pre><code class="language-swift">import OrderedCollections
</code></pre>
<!--kg-card-end: markdown--><h2 id="orderedset-examples">OrderedSet Examples</h2><h3 id="insert-element">Insert Element</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">var orderedSet = OrderedSet([&quot;id0&quot;, &quot;id1&quot;])
orderedSet.append(&quot;id2&quot;)

// OrderedSet now contains, in order,
// &quot;id0&quot;, &quot;id1&quot;, &quot;id2&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="get-element">Get Element</h3><!--kg-card-begin: markdown--><p>A traditional <code>Set</code> does not have an interface to &quot;get&quot; an element, only <code>contains(_:) -&gt; Bool</code> to determine if the <code>Set</code> includes a specific element. OrderedSet implements <code>contains(_:) -&gt; Bool</code> as well, and also allows elements to be retrieved by the position of the element in the order:</p>
<pre><code class="language-swift">var orderedSet = OrderedSet([&quot;id0&quot;, &quot;id1&quot;, &#x201C;id2&#x201D;])

// orderedSet contains, in order, 
// &quot;id0&quot;, &quot;id1&quot;, &quot;id2&quot;. Getting the element
// at index 1 returns &#x201C;id1&#x201D;

// Get the element at index 1
orderedSet[1] // &quot;id1&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="remove-element">Remove Element</h3><!--kg-card-begin: markdown--><p>There are multiple ways to remove elements from an <code>OrderedSet</code>. One way is to remove an element explicitly, either specifying the element directly or the index the element is at:</p>
<pre><code class="language-swift">// Remove a specific element
orderedSet.remove(&quot;id2&quot;)

// Remove an element at a specific index
orderedSet.remove(at: 2)
</code></pre>
<p>Another method is to remove elements relative to the front and back of the <code>OrderedSet</code>:</p>
<pre><code class="language-swift">// Remove elements from the front
orderedSet.removeFirst()
orderedSet.removeFirst(2)

// Remove elements from the back
orderedSet.removeLast()
orderedSet.removeLast(2)
</code></pre>
<p><code>OrderedSet</code> also includes methods for removing all elements, and removing all elements that meet some filter criteria:</p>
<pre><code class="language-swift">// Remove all elements
orderedSet.removeAll()

// Filter elements
orderedSet.removeAll { (element) -&gt; Bool in
    // Filter criteria
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="union">Union</h3><!--kg-card-begin: markdown--><p>A union between a <code>Set</code> and another <code>Set</code> returns a new <code>Set</code> with elements of both source sets. Similarly, a union between an <code>OrderedSet</code> and another <code>OrderedSet</code> (or sequence) returns a new <code>OrderedSet</code> with elements of both sources. In an <code>OrderedSet</code> union, new elements are appended to the back of the <code>OrderedSet</code>.</p>
<pre><code class="language-swift">let orderedSet = OrderedSet([&quot;id0&quot;, &quot;id1&quot;])
var newOrderedSet = orderedSet.union([
    &quot;id1&quot;, &quot;newId&quot;, &quot;id0&quot;
])

// newOrderedSet now contains, in order,
// &quot;id0&quot;, &quot;id1&quot;, &quot;newId&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="intersection">Intersection</h3><!--kg-card-begin: markdown--><p>An intersection between a <code>Set</code> and another <code>Set</code> returns a new <code>Set</code> with only common elements of both source sets. Similarly, an intersection between an <code>OrderedSet</code> and another <code>OrderedSet</code> (or sequence) returns a new <code>OrderedSet</code> with only common elements of both sources. In an <code>OrderedSet</code> intersection, elements are ordered according to the <code>OrderedSet</code> on which <code>union(_:)</code> was called:</p>
<pre><code class="language-swift">let orderedSet = OrderedSet([
    &quot;id0&quot;, &quot;id1&quot;, &quot;id2&quot;, &quot;id3&quot;, &quot;id4&quot;
])

var newOrderedSet = orderedSet.intersection([
    &quot;id3&quot;, &quot;id2&quot;, &quot;id0&quot;
])

// newOrderedSet now contains, in order,
// &quot;id0&quot;, &quot;id2&quot;, &quot;id3&quot;
</code></pre>
<!--kg-card-end: markdown--><h2 id="set-vs-orderedset">Set vs OrderedSet</h2><!--kg-card-begin: markdown--><p><code>Set</code> is an unordered collection of unique elements, often used to test if an element belongs to a set. Like <code>Set</code>, <code>OrderedSet</code> contains unique elements and can be used to test if an element belongs to a set. Unlike <code>Set</code>:</p>
<!--kg-card-end: markdown--><h3 id="orderedset-maintains-insert-order">OrderedSet Maintains Insert Order</h3><!--kg-card-begin: markdown--><p>As the name indicates, <code>OrderedSet</code> maintains element order. This means an <code>OrderedSet</code> can efficiently check if an element is within the <code>OrderedSet</code>, like a traditional <code>Set</code>, and also retrieve elements at a specific position, like a traditional <code>Array</code>.</p>
<p>To maintain element order, <code>OrderedSet</code> has a different interface than <code>Set</code>. Instead of implementing <code>add(_:)</code> to add elements, <code>OrderedSet</code> implements <code>append(_:)</code> and <code>insert(_:, at:)</code> for greater clarity on how the order is modified. <code>OrderedSet.append(_:)</code> adds an element to the back of an <code>OrderedSet</code> (if the element is not already in the <code>OrderedSet</code>), and <code>insert(_:, at:)</code> adds an element at a specific index in the <code>OrderedSet</code>.</p>
<!--kg-card-end: markdown--><h3 id="orderedset-insert-performance-differs">OrderedSet Insert Performance Differs</h3><!--kg-card-begin: markdown--><p>An <code>OrderedSet</code> implementation requires additional logic for insertions and removals to maintain element order. The <a href="https://github.com/apple/swift-collections">swift-collections README</a> details the performance impact:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><blockquote>
<p>&quot;these operations are expected to have performance characteristics similar to an Array: inserting or removing an element to the end of an ordered set is expected to execute in O(1) operations, while they are expected to take linear time at the front (or in the middle) of the set&quot;</p>
</blockquote>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>This means that repeated calls to <code>insert(_:, at:)</code> or <code>remove(at:)</code> at the front or the middle of an <code>OrderedSet</code> will take longer than repeated <code>append(_:)</code> or <code>removeLast()</code> calls.</p>
<!--kg-card-end: markdown--><h2 id="when-to-use-orderedset">When To Use OrderedSet</h2><h3 id="time-series-deduplication">Time-Series Deduplication</h3><!--kg-card-begin: markdown--><p>In some cases, for example a time series of data points, deduplication requires order to be perseved. An <code>OrderedSet</code> can deduplicate ordered elements while preserving the original element order:</p>
<pre><code class="language-swift">var timeSeries = [
    [&quot;id&quot;: &quot;0&quot;, &quot;value&quot;: &quot;0&quot;],
    [&quot;id&quot;: &quot;1&quot;, &quot;value&quot;: &quot;1&quot;],
    [&quot;id&quot;: &quot;0&quot;, &quot;value&quot;: &quot;0&quot;],
    [&quot;id&quot;: &quot;2&quot;, &quot;value&quot;: &quot;2&quot;],
    [&quot;id&quot;: &quot;1&quot;, &quot;value&quot;: &quot;1&quot;]
]

var orderedUniqueSeries = OrderedSet(timeSeries)
// orderedUniqueSeries contains, in order,
//    [&quot;id&quot;: &quot;0&quot;, &quot;value&quot;: &quot;0&quot;],
//    [&quot;id&quot;: &quot;1&quot;, &quot;value&quot;: &quot;1&quot;],
//    [&quot;id&quot;: &quot;2&quot;, &quot;value&quot;: &quot;2&quot;]

// Iterating over an OrderdSet always
// yields elements in order
for item in orderedUniqueSeries {
    print(&quot;\(item[&quot;id&quot;]!)&quot;)
}

// Expected console output:
// &quot;0&quot;
// &quot;1&quot;
// &quot;2&quot;
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="OrderedSet In Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="swift-orderedset">Swift OrderedSet</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using the <code>swift-collections</code> package and <code>OrderedSet</code>, you can take advantage of both <code>Set</code> properties and element ordering in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Read A File Using Combine In Swift]]></title><description><![CDATA[Learn how to create a custom subscription and publisher to read a file on the main thread or a background thread using Combine in Swift.]]></description><link>https://www.advancedswift.com/read-file-combine-swift/</link><guid isPermaLink="false">60695b236a9747003b86857e</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><category><![CDATA[Combine]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 04 Apr 2021 06:35:25 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1572061486094-7277c6715dee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDMyfHxyZWFkJTIwcGFnZXxlbnwwfHx8fDE2MTc1MTg5NDg&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1572061486094-7277c6715dee?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDMyfHxyZWFkJTIwcGFnZXxlbnwwfHx8fDE2MTc1MTg5NDg&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Read A File Using Combine In Swift"><p>Loading a file is a common operation in iOS and macOS apps often performed asynchronously on a background thread. Combine is a great tool for developers to work with asynchronous events. This post presents a complete example for using Combine to read a file on any thread in Swift:</p>
<ol>
<li><a href="#create-a-file-subscription">Create A File Subscription</a></li>
<li><a href="#create-a-file-publisher">Create A File Publisher</a></li>
<li><a href="#load-a-file-using-combine">Load A File Using Combine</a></li>
<li><a href="#returning-a-future-is-not-a-great-approach">Returning A Future Is Not A Great Approach</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Read A File Using Combine In Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="create-a-file-subscription">Create A File Subscription</h2><!--kg-card-begin: markdown--><p>The first step is to create a Combine subscription, <code>FileSubscription</code>, that adheres to the <code>Subscription</code> protocol. A <code>FileSubscription</code> is responsible for loading the file at <code>fileURL</code> when there is demand from subscribers.</p>
<p>An important note: no <code>DispatchQueue</code> or threading logic is required in <code>FileSubscription</code>.</p>
<pre><code class="language-swift">class FileSubscription&lt;S: Subscriber&gt;: Subscription
    where S.Input == Data, S.Failure == Error {

    // fileURL is the url of the file to read
    private let fileURL: URL
    private var subscriber: S?

    init(fileURL: URL, subscriber: S) {
        self.fileURL = fileURL
        self.subscriber = subscriber
    }

    func request(_ demand: Subscribers.Demand) {
        // Load the file at fileURL only when demand is
        // greater than 0, meaning subscribers were added
        // to this subscription and demand values
        if demand &gt; 0 {
            do {
                // Success case, data is loaded and this
                // subscription finishes
                let data = try Data(contentsOf: fileURL)
                subscriber?.receive(data)
                subscriber?.receive(completion: .finished)
            } 
            catch let error {
                // Failure case, this subscription finishes
                // and propagates the error 
                subscriber?.receive(
                    completion: .failure(error)
                )
            }
        }
    }

    // Set the subscriber reference to nil, cancelling
    // the subscription
    func cancel() {
        subscriber = nil
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="create-a-file-publisher">Create A File Publisher</h2><!--kg-card-begin: markdown--><p>The next step is to create a Combine publisher, <code>FilePublisher</code>, adhering to the <code>Publisher</code> protocol. A <code>FilePublisher</code> is responsible for creating a new <code>FileSubscription</code> when a subscriber subscribes to the publisher:</p>
<pre><code class="language-swift">struct FilePublisher: Publisher {
    // The output type of FilePublisher publisher
    // is Data, which will be the Data of the read file
    typealias Output = Data

    typealias Failure = Error
    
    // fileURL is the url of the file to read
    let fileURL: URL
    
    func receive&lt;S&gt;(subscriber: S) where S : Subscriber, 
        Failure == S.Failure, Output == S.Input {

        // Create a FileSubscription for the new subscriber
        // and set the file to be loaded to fileURL
        let subscription = FileSubscription(
            fileURL: fileURL,
            subscriber: subscriber
        )
        
        subscriber.receive(subscription: subscription)
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="load-a-file-using-combine">Load A File Using Combine</h2><!--kg-card-begin: markdown--><p>The final step is to use Combine methods to configure the <code>FilePublisher</code> subscriber. In this example, the chain is configured using:</p>
<ol>
<li><code>subscribe(on: DispatchQueue.global(qos: .background))</code>, meaning the file will be loaded asynchronously</li>
<li><code>receive(on: DispatchQueue.main)</code>, meaning the file data or file read error will be handled on the main thread</li>
<li><code>sink(receiveCompletion:, receiveValue:)</code>, handling the success and failure cases of loading file data</li>
</ol>
<pre><code class="language-swift">let fileURL = // URL of the file to read

// The cancellables set is used to retain a reference
// to the subscription, otherwise the subscription or 
// publisher may release before file logic is executed
var cancellables = Set&lt;AnyCancellable&gt;()

// Create a FilePublisher for the specified fileURL
FilePublisher(fileURL: fileURL)
    // Subscribe on a background thread, meaning the 
    // FileSubscription logic for reading a file will 
    // run on a background thread
    .subscribe(on: DispatchQueue.global(qos: .background))

    // Receive on the main thread, meaning the sink 
    // callbacks will run on the main thread
    .receive(on: DispatchQueue.main)

     // Handle the success and failure cases
    .sink(receiveCompletion: { error in
            // Handle error
        }, 
        receiveValue: { fileData in
            // Handle loaded file data
         }
    )

    // Retain a reference to the subscription to prevent
    // early deallocation before the subscription finishes
    .store(in: &amp;cancellables)
</code></pre>
<!--kg-card-end: markdown--><h2 id="returning-a-future-is-not-a-great-approach">Returning A Future Is Not A Great Approach</h2><!--kg-card-begin: markdown--><p>Another potential implementation using Combine is to return a <code>Future</code> that loads a file in its callback. Returning a <code>Future</code> is not ideal, as the <code>Future</code> callback will execute immediately. This means <code>subscribe(on:)</code> has no impact on which thread the file is loaded on:</p>
<pre><code class="language-swift">// Poor Implementation
func read(fileURL: URL) -&gt; Future&lt;Data, Error&gt; {
    return Future&lt;Data, Error&gt; { promise in
        let data = // Read file data
        promise(.success(data))
    }
}
</code></pre>
<p>A common iteration is to wrap the file load logic in a <code>DispatchQueue</code> to ensure the file load happens on a background thread. However, the problem is still the same. The <code>subscribe(on:)</code> method has no impact on which thread the file is loaded on, meaning a subscriber cannot control which thread is used.</p>
<p>Adding a <code>queue</code> argument to <code>read(fileURL:)</code> could allow the <code>Future</code> to load data on a specified thread. This still would not enable <code>subscribe(on:)</code> to determine which thread a file is loaded on.</p>
<pre><code class="language-swift">// Poor Implementation
func read(fileURL: URL) -&gt; Future&lt;Data, Error&gt; {
    return Future&lt;Data, Error&gt; { promise in
        DispatchQueue.global().async {
            let data = // Read file data
            promise(.success(data))
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="reading-file-data-on-any-thread-using-combine-in-swift">Reading File Data On Any Thread Using Combine In Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using the <code>Subscriber</code> and <code>Publisher</code> protocols, and <code>subscribe(on:)</code> and <code>receive(on:)</code> methods, you can load files on any thread using Combine in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Building and Parsing URLs in Swift]]></title><description><![CDATA[Learn how to create a URL from components, parse a URL into components, and work with URL query items in Swift.]]></description><link>https://www.advancedswift.com/a-guide-to-urls-in-swift/</link><guid isPermaLink="false">606017eb6a9747003b8684ed</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><category><![CDATA[Networking]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 28 Mar 2021 06:02:27 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1503792453751-9dffb431aa63?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDM2fHxidWlsZHxlbnwwfHx8fDE2MTY5MTAyODI&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1503792453751-9dffb431aa63?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDM2fHxidWlsZHxlbnwwfHx8fDE2MTY5MTAyODI&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Building and Parsing URLs in Swift"><p>Creating and parsing URLs is commonly implemented in iOS and macOS apps that connect to the web. This post presents a number of <code>URL</code>, <code>URLComponents</code>, and <code>URLQueryItem</code> examples in Swift:</p>
<ol>
<li><a href="#parse-url-string">Parse URL String</a><br>
a. <a href="#parse-absolute-url">Parse Absolute URL</a><br>
b. <a href="#parse-relative-url">Parse Relative URL</a><br>
c. <a href="#get-value-of-url-query-parameters">Get Value Of URL Query Parameters</a><br>
e. <a href="#urlcomponents-automatically-decodes-url-encoded-strings">URLComponents Automatically Decodes URL Encoded strings</a><br>
d. <a href="#decode-url-encoded-string">Decode URL Encoded String</a><br>
f. <a href="#what-is-resolvingagainstbaseurl">What is resolvingAgainstBaseURL?</a></li>
<li><a href="#create-url-string">Create URL String</a><br>
a. <a href="#build-a-url-with-query-parameters">Build A URL With Query Parameters</a><br>
b. <a href="#urlcomponents-automatically-encodes-query-items">URLComponents Automatically Encodes Query Items</a><br>
c. <a href="#url-encode-a-string">URL Encode A String</a></li>
<li><a href="#url-property-examples">URL Property Examples</a><br>
a. <a href="#urls-and-strings">URLs and Strings</a><br>
b. <a href="#port-host-and-scheme">Port, Host, and Scheme</a><br>
c. <a href="#query-and-fragment">Query and Fragment</a><br>
d. <a href="#paths-and-extensions">Paths and Extensions</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Building and Parsing URLs in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="parse-url-string">Parse URL String</h2><h3 id="parse-absolute-url">Parse Absolute URL</h3><!--kg-card-begin: markdown--><p>An absolute URL is a fully specified address.</p>
<pre><code class="language-swift">var url = URL(
    string: &quot;https://advswift.com/api/v1?page=url+components&quot;
)!

url.host // advswift.com
url.path // /api/v1
</code></pre>
<!--kg-card-end: markdown--><h3 id="parse-relative-url">Parse Relative URL</h3><!--kg-card-begin: markdown--><p>A relative URL is a partially specified address, starting at the path, appended to a root URL.</p>
<pre><code class="language-swift">var root = URL(string: &quot;https://advswift.com/&quot;)!
var url = URL(
    string: &quot;api/v1?page=url+components&quot;, 
    relativeTo: root
)!

url.host // advswift.com
url.path // /api/v1
</code></pre>
<!--kg-card-end: markdown--><h3 id="get-value-of-url-query-parameters">Get Value Of URL Query Parameters</h3><!--kg-card-begin: markdown--><p>A common task is to extract the URL query parameters as a dictionary. Parsing a <code>URL</code> with <code>URLComponents</code> provides a <code>queryItems</code> property that contains a list of query item names and values:</p>
<pre><code class="language-swift">var url = URL(
    string: &quot;https://advswift.com/api/v1?page=url&quot;
)!

var components = URLComponents(
    url: url, 
    resolvingAgainstBaseURL: false
)!

// URL query parameters as a dictionary
components.queryItems
// [
//    {
//        &quot;name&quot;: &quot;page&quot;, 
//        &quot;value&quot;: &quot;url&quot;
//    }
// ]
</code></pre>
<!--kg-card-end: markdown--><h3 id="urlcomponents-automatically-decodes-url-encoded-strings">URLComponents Automatically Decodes URL Encoded strings</h3><!--kg-card-begin: markdown--><p>URL query parameters parsed by <code>URLComponents</code> will automatically be decoded if the query item value was URL encoded:</p>
<pre><code class="language-swift">var url = URL(
    string: &quot;https://advswift.com/api/v1?page=url%20query&quot;
)!

var components = URLComponents(
    url: url, 
    resolvingAgainstBaseURL: false
)!

// Decoded URL query parameters as a dictionary
components.queryItems
// [
//    {
//        &quot;name&quot;: &quot;page&quot;, 
//        &quot;value&quot;: &quot;url query&quot;
//    }
// ]
</code></pre>
<!--kg-card-end: markdown--><h3 id="decode-url-encoded-string">Decode URL Encoded String</h3><!--kg-card-begin: markdown--><p>Use the <code>removingPercentEncoding</code> <code>String</code> property to remove URL encoding directly:</p>
<pre><code class="language-swift">var encoded = &quot;url%20components&quot;
var decoded = encoded.removingPercentEncoding
// decoded is &quot;url components&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="what-is-resolvingagainstbaseurl">What is resolvingAgainstBaseURL?</h3><!--kg-card-begin: markdown--><p>The <code>URLComponents</code> constructor argument <code>resolvingAgainstBaseURL</code> determines if URLComponents should use the absolute URL:</p>
<pre><code class="language-swift">var root = URL(string: &quot;https://advswift.com/&quot;)!
var url = URL(
    string: &quot;api/v1?page=url+components&quot;, 
    relativeTo: root
)!

var relativeComponents = URLComponents(
    url: url, 
    resolvingAgainstBaseURL: false
)!

// &quot;api/v1?page=url+components&quot;
relativeComponents.string

var absoluteComponents = URLComponents(
    url: url, 
    resolvingAgainstBaseURL: true
)!

// &quot;https://advswift.com/api/v1?page=url+components&quot;
absoluteComponents.string
</code></pre>
<!--kg-card-end: markdown--><h2 id="create-url-string">Create URL String</h2><!--kg-card-begin: markdown--><p><code>URLComponents</code> can also be used to construct custom urls:</p>
<pre><code class="language-swift">var components = URLComponents()
components.scheme = &quot;https&quot;
components.host = &quot;advswift.com&quot;
components.path = &quot;/home&quot;

// &quot;https://advswift.com/home&quot;
components.string
</code></pre>
<!--kg-card-end: markdown--><h3 id="build-a-url-with-query-parameters">Build A URL With Query Parameters</h3><!--kg-card-begin: markdown--><p>Specifying <code>queryItems</code> on <code>URLComponents</code> will properly build a url with query parameters:</p>
<pre><code class="language-swift">var components = URLComponents()
components.scheme = &quot;https&quot;
components.host = &quot;advswift.com&quot;
components.path = &quot;/home&quot;

components.queryItems = [
    URLQueryItem(name: &quot;topic&quot;, value: &quot;swift&quot;),
    URLQueryItem(name: &quot;page&quot;, value: &quot;urls&quot;)
]

// &quot;https://advswift.com/home?topic=swift&amp;page=urls&quot;
components.string
</code></pre>
<!--kg-card-end: markdown--><h3 id="urlcomponents-automatically-encodes-query-items">URLComponents Automatically Encodes Query Items</h3><!--kg-card-begin: markdown--><p><code>URLComponents</code> will automatically URL encode query items that contain disallowed characters:</p>
<pre><code class="language-swift">var components = URLComponents()

components.queryItems = [
    URLQueryItem(name: &quot;page&quot;, value: &quot;url components&quot;)
]

// &quot;?page=url%20components&quot;
components.string
</code></pre>
<!--kg-card-end: markdown--><h3 id="url-encode-a-string">URL Encode A String</h3><!--kg-card-begin: markdown--><p>Use the <code>String</code> method <code>addingPercentEncoding(withAllowedCharacters:)</code> to URL encode a string directly:</p>
<pre><code class="language-swift">var decoded = &quot;url components&quot;
var encoded = decoded.addingPercentEncoding(
    withAllowedCharacters: .urlQueryAllowed
)
// encoded is &quot;url%20components&quot;
</code></pre>
<!--kg-card-end: markdown--><h2 id="url-property-examples">URL Property Examples</h2><h3 id="urls-and-strings">URLs and Strings</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">// Absolute URL
var url = URL(string: &quot;https://advswift.com/home&quot;)!
url.absoluteURL // URL struct, https://advswift.com/home
url.absoluteString // &quot;https://advswift.com/home&quot;
url.baseURL // nil

// Relative URL
var root = URL(string: &quot;https://advswift.com&quot;)!
var url = URL(string: &quot;v1/api&quot;, relativeTo: root)!

url.absoluteURL 
// URL struct, https://advswift.com/home/v1/api

url.absoluteString // &quot;https://advswift.com/v1/api&quot;
url.baseURL // URL struct, &quot;https://advswift.com&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="port-host-and-scheme">Port, Host, and Scheme</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">var url = URL(string: &quot;https://advswift.com:80&quot;)!
url.port // 80, an Int
url.host // &quot;advswift.com&quot;
url.scheme // &quot;https&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="query-and-fragment">Query and Fragment</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">// URL Query Example
var url = URL(string: 
    &quot;https://advswift.com/page?topic=swift&amp;examples=true&quot;
)!

url.query // &quot;topic=swift&amp;examples=true&quot;

// URL Fragment Example
var url = URL(string: &quot;https://advswift.com/page#anchor&quot;)!
url.fragment // &quot;anchor&quot;
</code></pre>
<!--kg-card-end: markdown--><h3 id="paths-and-extensions">Paths and Extensions</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">var url = URL(
    string: &quot;https://advswift.com/api/v1/endpoint.ext&quot;
)!

url.path // &quot;/api/v1/endpoint.ext&quot;
url.pathExtension // &quot;ext&quot;
url.pathComponents // [&quot;/&quot;, &quot;api&quot;, &quot;v1&quot;, &quot;endpoint.ext&quot;]

url.relativePath // &quot;/api/v1/endpoint.ext&quot;

url.relativeString 
// &quot;https://advswift.com/api/v1/endpoint.ext&quot;
</code></pre>
<!--kg-card-end: markdown--><h2 id="encode-url-parameters-and-create-custom-urls-in-swift">Encode URL Parameters and Create Custom URLs In Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>URL</code>, <code>URLComponents</code>, and <code>URLQueryItem</code> you can create custom urls, parse URL formats, and encode URL query items in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Autolayout vs Autoresizing Masks in Swift]]></title><description><![CDATA[Learn when to use autolayout and autoresizing masks to create responsive user interfaces in Swift.]]></description><link>https://www.advancedswift.com/autolayout-vs-autoresizing-masks/</link><guid isPermaLink="false">6058277bc1262a003b64aed8</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><category><![CDATA[UI]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Mon, 22 Mar 2021 05:55:15 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1571666521805-f5e8423aba9d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDZ8fHBsYW58ZW58MHx8fHwxNjE2MzkwMDg0&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1571666521805-f5e8423aba9d?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDZ8fHBsYW58ZW58MHx8fHwxNjE2MzkwMDg0&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Autolayout vs Autoresizing Masks in Swift"><p>User Interface layout programming is a big part of modern iOS and macOS apps written in Swift. This post presents a brief overview of two layout methods, Autolayout and Autoresizing Masks, and contains examples of how each method can be used in Swift:</p>
<ol>
<li><a href="#autolayout">Autolayout</a><br>
a. <a href="#what-is-autolayout">What is Autolayout?</a><br>
b. <a href="#autolayout-example">Autolayout Example</a><br>
c. <a href="#autolayout-safe-areas-example">Autolayout Safe Areas Example</a></li>
<li><a href="#autoresizing-mask">Autoresizing Mask</a><br>
a. <a href="#what-is-a-autoresizing-mask">What is a Autoresizing Mask</a><br>
b. <a href="#autoresizing-mask-example">Autoresizing Mask Example</a></li>
<li><a href="#autolayout-vs-autoresizingmask">Autolayout vs AutoResizingMask</a><br>
a. <a href="#when-to-use-autolayout">When To Use Autolayout</a><br>
b. <a href="#when-to-use-autoresizing-masks">When To Use Autoresizing Masks</a></li>
<li><a href="#using-autolayout-and-autoresizing-masks-at-the-same-time">Using Autolayout And Autoresizing Masks At The Same Time</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Autolayout vs Autoresizing Masks in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="autolayout">Autolayout</h2><h2 id="what-is-autolayout">What is Autolayout?</h2><!--kg-card-begin: markdown--><p>Autolayout is a user interface layout framework that uses constraints, a rule for where a UI element should be, to determine the layout of a UI. The autolayout engine will recompute the appropriate layout when the superview changes size, for example:</p>
<ol>
<li>The user resizes a window on macOS</li>
<li>An iOS device rotates</li>
<li>The user enters or leaves split view on an iPad (running iOS)</li>
</ol>
<!--kg-card-end: markdown--><h2 id="autolayout-example">Autolayout Example</h2><!--kg-card-begin: markdown--><p>One common use case for Autolayout is supporting rotation so a UI adapts appropriately to landscape and portrait device orientations.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>To use Autolayout on a view, that view needs a complete set of constraints. This means the view&#x2019;s <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code> properties must have constraints defining how each of those frame properties should be computed.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Here, to make a <code>UILabel</code> and <code>UITextField</code> responsive, the following constraints will be added:</p>
<ol>
<li>Top Space to Superview (40)</li>
<li>Leading Space to Superview (20)</li>
<li>Trailing Space to Superview (20)</li>
<li>Bottom Space to Superview (8)</li>
<li>Height (25)</li>
</ol>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutUILabelExample.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1134" height="1118" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutUILabelExample.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutolayoutUILabelExample.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutolayoutUILabelExample.png 1134w" sizes="(min-width: 720px) 720px"><figcaption>UILabel Autolayout Constraints Example</figcaption></figure><!--kg-card-begin: markdown--><p>Adding the constraints in a Storyboard to the <code>UILabel</code> shows the blue constraints attributes when the <code>UILabel</code> is selected. The same type of constraints were added to the <code>UITextField</code> underneath.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutConstraintsStoryboard.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1006" height="608" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutConstraintsStoryboard.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutolayoutConstraintsStoryboard.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutolayoutConstraintsStoryboard.png 1006w" sizes="(min-width: 720px) 720px"><figcaption>Autolayout UILabel Constraints In A Storyboard</figcaption></figure><!--kg-card-begin: markdown--><p>The <code>UILabel</code> and <code>UITextfield</code> are now properly constrained using Autolayout. When the UI orientation is changed to landscape, Autolayout will expand both views horizontally.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/ResponsiveAutolayoutLandscape.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1024" height="296" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/ResponsiveAutolayoutLandscape.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/ResponsiveAutolayoutLandscape.png 1000w, https://www.advancedswift.com/content/images/2021/03/ResponsiveAutolayoutLandscape.png 1024w" sizes="(min-width: 720px) 720px"><figcaption>Responsive Landscape Orientation With Autolayout</figcaption></figure><h2 id="autolayout-safe-areas-example">Autolayout Safe Areas Example</h2><!--kg-card-begin: markdown--><p>A superpower of Autolayout is handling safe areas. Safe areas are margins maintained by the iOS system to help user interfaces account for system attributes. For example, safe areas can be used to handle rounded corners and non-rounded corners on iOS screens.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The secret to handling safe areas is a view constrained by autolayout <strong>does not</strong> need to be constrained only to its superview. In the following example, the Inbox <code>UILabel</code> will be constrained to the top safe area of the <code>UIViewController</code> <code>view</code> even though the superview of Inbox <code>UILabel</code> is the view with a blue background.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The first step is to constrain a view with a blue background to the leading, top, and trailing edges of the superview (here a <code>UIViewController</code> <code>view</code>).</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Importantly, <strong>do not</strong> constraint the bottom or the height of in this step.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample-1.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1060" height="1136" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutSafeAreaExample-1.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutolayoutSafeAreaExample-1.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample-1.png 1060w" sizes="(min-width: 720px) 720px"><figcaption>UIView Autolayout Constraints In A Storyboard</figcaption></figure><!--kg-card-begin: markdown--><p>Next, add two <code>UILabel</code> labels with some text. Add constraints for the leading and trailing edges of the Inbox <code>UILabel</code> to the superview (view with a blue background). Also add a height constraint to the Inbox <code>UILabel</code> view.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Importantly, <strong>do not</strong> constrain the top edge of the Inbox <code>UILabel</code> at this step.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample-2.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1044" height="1154" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutSafeAreaExample-2.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutolayoutSafeAreaExample-2.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample-2.png 1044w" sizes="(min-width: 720px) 720px"><figcaption>Example Autolayout Constraints For A UILabel In A Storyboard</figcaption></figure><!--kg-card-begin: markdown--><p>For the subtitle <code>UILabel</code>, add constraints for all edges to the superview.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample-3.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1072" height="1156" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutSafeAreaExample-3.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutolayoutSafeAreaExample-3.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample-3.png 1072w" sizes="(min-width: 720px) 720px"><figcaption>UILabel Example Autolayout Constraints In A Storyboard</figcaption></figure><!--kg-card-begin: markdown--><p>So far, the views added are not yet fully constrained. This next step completes the Autolayout configuration and provides desired behavior.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Constrain the Inbox <code>UILabel</code> to the Top Safe Area of the <code>UIViewController</code> <code>view</code>.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaExample.gif" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="800" height="788"><figcaption>Autolayout Constraints Safe Area Example</figcaption></figure><!--kg-card-begin: markdown--><p>The result shows the powerful capabilities of Autolayout. Now across different devices with and without rounded corners, the defined UI will display correctly:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaLayout.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="890" height="504" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutSafeAreaLayout.png 600w, https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaLayout.png 890w" sizes="(min-width: 720px) 720px"><figcaption>UI Using Autolayout Safe Area Example</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaLayout-2.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="896" height="382" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutSafeAreaLayout-2.png 600w, https://www.advancedswift.com/content/images/2021/03/AutolayoutSafeAreaLayout-2.png 896w" sizes="(min-width: 720px) 720px"><figcaption>UI Using Autolayout Safe Area Example</figcaption></figure><h2 id="autoresizing-mask">Autoresizing Mask</h2><h2 id="what-is-a-autoresizing-mask">What is a Autoresizing Mask</h2><!--kg-card-begin: markdown--><p>Autoresizing masks is a layout method using a bit mask, or an encoded set of flags, that defines how a view should respond to changes in the superview&#x2019;s bounds.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The properties available in a autoresizing mask on a view are:</p>
<ol>
<li>Flexible Top Margin, meaning resizing can change the view&#x2019;s top margin</li>
<li>Flexible Left Margin, meaning resizing can change the view&#x2019;s left margin</li>
<li>Flexible Right Margin, meaning resizing can change the view&#x2019;s right margin</li>
<li>Flexible Bottom Margin, meaning resizing can change the view&#x2019;s bottom margin</li>
<li>Flexible Width, meaning resizing can change the view&#x2019;s width</li>
<li>Flexible Height, meaning resizing can change the view&#x2019;s height</li>
</ol>
<!--kg-card-end: markdown--><h2 id="autoresizing-mask-example">Autoresizing Mask Example</h2><!--kg-card-begin: markdown--><p>This autoresizing mask example will define the layout of all subviews in a chat message cell using autoresizing masks. First, add all the views (4 <code>UILabel</code> labels) in the view without any constraints.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Then, in the Size Inspector, configure each view with the appropriate resizing mark. Each red and faded red arrow or strut in the Autoresizing section of the inspector is clickable. Clicking on a red or faded red component will enable or disable the autoresizing mask property.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The Advanced Swift <code>UILabel</code> has a flexible width (shown by the red horizontal arrow) and a fixed leading, top, and trailing margin (shown by the red left, top, and right struts).</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-1.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1416" height="344" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutoresizingMaskExample-1.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutoresizingMaskExample-1.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-1.png 1416w" sizes="(min-width: 720px) 720px"><figcaption>UILabel With Flexible Width Autoresizing Mask</figcaption></figure><!--kg-card-begin: markdown--><p>The date <code>UILabel</code> is pinned to the top and trailing edge of the superview, meaning the date <code>UILabel</code> will retain its frame and distance from the top and trailing edge.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-2.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1416" height="278" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutoresizingMaskExample-2.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutoresizingMaskExample-2.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-2.png 1416w" sizes="(min-width: 720px) 720px"><figcaption>UILabel Pinned With A Autoresizing Mask</figcaption></figure><!--kg-card-begin: markdown--><p>The message <code>UILabel</code> has a flexible width and a fixed leading, top, and trailing margin.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-3.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1462" height="290" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutoresizingMaskExample-3.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutoresizingMaskExample-3.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-3.png 1462w" sizes="(min-width: 720px) 720px"><figcaption>UILabel With Flexible Width Autoresizing Mask</figcaption></figure><!--kg-card-begin: markdown--><p>The A <code>UILabel</code> is pinned to the top and leading edge of the superview, meaning the A <code>UILabel</code> will retain its frame and distance from the top and leading edge.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-4.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1438" height="282" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutoresizingMaskExample-4.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutoresizingMaskExample-4.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-4.png 1438w" sizes="(min-width: 720px) 720px"><figcaption>UILabel Pinned With A Autoresizing Mask</figcaption></figure><!--kg-card-begin: markdown--><p>Now, with all views configured with the appropriate autoresizing mask, the view is responsive. In a landscape orientation the Advanced Swift and message <code>UILabel</code> labels will be stretched horizontally, with all other views staying the same size. The date <code>UILabel</code> will maintain its distance from the superview&#x2019;s trailing edge.</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-5.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1700" height="262" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutoresizingMaskExample-5.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutoresizingMaskExample-5.png 1000w, https://www.advancedswift.com/content/images/size/w1600/2021/03/AutoresizingMaskExample-5.png 1600w, https://www.advancedswift.com/content/images/2021/03/AutoresizingMaskExample-5.png 1700w" sizes="(min-width: 720px) 720px"><figcaption>Responsive Autoresizing Mask Example</figcaption></figure><h2 id="autolayout-vs-autoresizingmask">Autolayout vs AutoresizingMask</h2><h2 id="when-to-use-autolayout">When To Use Autolayout</h2><!--kg-card-begin: markdown--><p>Although both Autolayout and autoresizing masks can be used to layout iOS and macOS UI, Autolayout is a more powerful layout framework. Use autolayout for:</p>
<ol>
<li>Safe areas and margins</li>
<li>Complex layout responsiveness</li>
<li>Inter-view dependencies like aspect ratios, related widths</li>
<li>Fine-grained layout control</li>
</ol>
<!--kg-card-end: markdown--><h2 id="when-to-use-autoresizing-masks">When To Use Autoresizing Masks</h2><!--kg-card-begin: markdown--><p>Even though autolayout is more powerful, autoresizing can still be valuable. Consider using autoresizing masks for:</p>
<ol>
<li>Embedded views that primarily stretch in one direction</li>
<li>Prototyping responsive UI</li>
<li>Simple layouts</li>
</ol>
<!--kg-card-end: markdown--><h2 id="using-autolayout-and-autoresizing-masks-at-the-same-time">Using Autolayout And Autoresizing Masks At The Same Time</h2><!--kg-card-begin: markdown--><p>Autolayout and autoresizing masks are not exclusive user interface layout methods, and both can be used at the same time.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Both examples presented in this post are combined in the following example. First, a <code>UITableView</code> was added using autolayout constraining the top, leading, trailing, and bottom edges. Then, the <code>UITableViewCell</code> was added using autoresizing masks as presented in this post.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The result is a user interface layout that reacts as expected in both portrait and landscape orientations, for devices with and without rounded corners:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutAndAutoresizingMaskExample-1.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="618" height="1194" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutAndAutoresizingMaskExample-1.png 600w, https://www.advancedswift.com/content/images/2021/03/AutolayoutAndAutoresizingMaskExample-1.png 618w"><figcaption>Autolayout and Autoresizing Masks, Portrait Example</figcaption></figure><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/AutolayoutAndAutoresizingMaskExample-2.png" class="kg-image" alt="Autolayout vs Autoresizing Masks in Swift" loading="lazy" width="1104" height="590" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/AutolayoutAndAutoresizingMaskExample-2.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/AutolayoutAndAutoresizingMaskExample-2.png 1000w, https://www.advancedswift.com/content/images/2021/03/AutolayoutAndAutoresizingMaskExample-2.png 1104w" sizes="(min-width: 720px) 720px"><figcaption>Autolayout and Autoresizing Masks, Landscape Example</figcaption></figure><h2 id="a-guide-to-autolayout-and-autoresizing-masks-in-swift">A Guide To Autolayout and Autoresizing Masks In Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using autolayout and autoresizing masks, individually or together, you can create response UIs for your iOS and macOS apps in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[CGPoint Examples in Swift From Lottie and Charts]]></title><description><![CDATA[Learn how top Swift frameworks Lottie and Charts (44k+ combined GitHub stars) use CGPoint in Swift.]]></description><link>https://www.advancedswift.com/cgpoint-examples-lottie-charts/</link><guid isPermaLink="false">604da4cd23368d003bdd1b49</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><category><![CDATA[UI]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 14 Mar 2021 06:00:46 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1596333576084-52ede5fa350b?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDc1fHxkb3R8ZW58MHx8fHwxNjE1NzAxMzA4&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1596333576084-52ede5fa350b?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MnwxMTc3M3wwfDF8c2VhcmNofDc1fHxkb3R8ZW58MHx8fHwxNjE1NzAxMzA4&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="CGPoint Examples in Swift From Lottie and Charts"><p><code>CGPoint</code> is a struct used to represent an x and y coordinate in a 2D plane. This post presents examples of how Lottie and Charts, two popular Cocoapods with over 44,000 combined GitHub stars, use <code>CGPoint</code> in Swift:</p>
<ol>
<li><a href="#compute-cgrect-corners-and-center">Compute <code>CGRect</code> Corners and Center</a></li>
<li><a href="#describe-a-coregraphics-path">Describe A CoreGraphics Path</a></li>
<li><a href="#respond-to-rotation-gestures">Respond To Rotation Gestures</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="CGPoint Examples in Swift From Lottie and Charts" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="compute-cgrect-corners-and-center">Compute CGRect Corners and Center</h2><!--kg-card-begin: markdown--><p>Lottie contains a custom implemented utility extension called MathKit (<a href="https://github.com/airbnb/lottie-ios/blob/1692cb4d0fcf0406dcaf61bf7cafea49dca51354/lottie-swift/src/Private/Utility/Extensions/MathKit.swift#L148">source</a>) that extends <code>CGRect</code>.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The extension uses <code>CGPoint</code> to represent the center and corners of the added <code>CGRect</code> properties:</p>
<pre><code class="language-swift">extension CGRect {
    // Implement a getter and setter for the center
    // of the on CGRect
    var center: CGPoint {
        get {
          return CGPoint(x: midX, y: midY)
        }
        set {
            origin = CGPoint(
                x: newValue.x - (size.width * 0.5),
                y: newValue.y - (size.height * 0.5)
            )
        }
    }

    // Implement a getter and setter for the top left
    // corner of the CGRect
    var topLeft: CGPoint {
        get {
            return CGPoint(x: minX, y: minY)
        }
        set {
            origin = CGPoint(
                x: newValue.x,
                y: newValue.y
            )
        }
    }

    // Implement a getter and setter for the bottom left
    // corner of the CGRect
    var bottomLeft: CGPoint {
        get {
            return CGPoint(x: minX, y: maxY)
        }
        set {
            origin = CGPoint(
                x: newValue.x,
                y: newValue.y - size.height
            )
        }
    }

    // Implement a getter and setter for the top right
    // corner of the CGRect
    var topRight: CGPoint {
        get {
            return CGPoint(x: maxX, y: minY)
        }
        set {
            origin = CGPoint(
                x: newValue.x - size.width,
                y: newValue.y
            )
        }
    }

    // Implement a getter and setter for the bottom right
    // corner of the CGRect
    var bottomRight: CGPoint {
        get {
          return CGPoint(x: maxX, y: maxY)
        }
        set {
            origin = CGPoint(
                x: newValue.x - size.width,
                y: newValue.y - size.height
            )
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="describe-a-coregraphics-path">Describe A CoreGraphics Path</h2><!--kg-card-begin: markdown--><p>One of the ways Charts uses <code>CGPoint</code> is to create a path when drawing with CoreGraphics (<a href="https://github.com/danielgindi/Charts/blob/d2bf08fdd6841d549a6579635ec797185c087635/Source/Charts/Renderers/Scatter/TriangleShapeRenderer.swift#L34">source</a>). In this example, Charts uses <code>CGPoint</code> to create a triangle path:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// In this example context is a CGContext, 
// which provides an interface to draw with

// setFillColor sets the drawing color to color.cgColor
context.setFillColor(color.cgColor)
        
// beginPath starts creating a path
context.beginPath()

// move and addLine specify how to append to the path
context.move(to: 
    CGPoint(
        x: point.x, 
        y: point.y - shapeHalf
    )
)

context.addLine(to: 
    CGPoint(
        x: point.x + shapeHalf, 
        y: point.y + shapeHalf
    )
)

context.addLine(to:
    CGPoint(
        x: point.x - shapeHalf, 
        y: point.y + shapeHalf
    )
)
     
// closePath followed by fillPath fills the path 
// with the fill color in the draw buffer
context.closePath()
context.fillPath()
</code></pre>
<!--kg-card-end: markdown--><h2 id="respond-to-rotation-gestures">Respond To Rotation Gestures</h2><!--kg-card-begin: markdown--><p>Another way Charts uses <code>CGPoint</code> is to handle rotation gestures (<a href="https://github.com/danielgindi/Charts/blob/d2bf08fdd6841d549a6579635ec797185c087635/Source/Charts/Charts/PieRadarChartViewBase.swift#L486">source</a>). Gesture recognizers use <code>CGPoint</code> to represent the location a user touches the device&#x2019;s screen. Charts implements a number of methods to handle rotation gestures at a specific location, a CGPoint argument:</p>
<pre><code class="language-swift">processRotationGestureBegan(location: CGPoint)
processRotationGestureMoved(location: CGPoint)
processRotationGestureEnded(location: CGPoint)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>When processing touch locations, a common operation is to get the distance between touches. Charts implements a <code>distance(from:, to:)</code> method taking in two <code>CGPoint</code> parameters (<a href="https://github.com/danielgindi/Charts/blob/d2bf08fdd6841d549a6579635ec797185c087635/Source/Charts/Charts/PieRadarChartViewBase.swift#L791">source</a>):</p>
<pre><code class="language-swift">private func distance(from: CGPoint, to: CGPoint) -&gt; CGFloat {
    let dx = from.x - to.x
    let dy = from.y - to.y
    return sqrt(dx * dx + dy * dy)
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="cgpoint-examples-in-swift">CGPoint Examples in Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>CGPoint</code>, you can compute attributes of 2D representations like <code>CGRect</code>, describe paths with CoreGraphics, and better handle gestures in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Create, Update, and Delete Core Data Objects in Swift]]></title><description><![CDATA[Learn how to create, update, and delete Core Data objects in Swift with commented code examples.]]></description><link>https://www.advancedswift.com/core-data-objects/</link><guid isPermaLink="false">604419feea94e8003932f7ca</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><category><![CDATA[databases]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 07 Mar 2021 00:24:27 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1511721511189-ca0a98b3229e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDI2fHxvcmdhbml6ZXxlbnwwfHx8&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1511721511189-ca0a98b3229e?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDI2fHxvcmdhbml6ZXxlbnwwfHx8&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Create, Update, and Delete Core Data Objects in Swift"><p>Core Data is a powerful mobile database allowing developers to create high performance, data-driven iOS and macOS applications. This post presents examples of creating, updating, and deleting Core Data objects in Swift:</p>
<ol>
<li><a href="#defining-a-new-core-data-entity">Defining A New Core Data Entity</a><br>
a. <a href="#new-data-model-entity-using-xcode">New Data Model Entity Using Xcode</a><br>
b. <a href="#xcode-nsmanagedobject-sync">Xcode NSManagedObject Sync</a></li>
<li><a href="#create-a-new-core-data-object">Create A New Core Data Object</a><br>
a. <a href="#new-nsmanagedobject-example">New NSManagedObject Example</a><br>
b. <a href="#use-of-unresolved-identifier-entity-">Use of unresolved identifier &#x2018;Entity&#x2019;</a><br>
c. <a href="#command-compileswiftsources-failed-with-a-nonzero-exit-code">Command CompileSwiftSources failed with a nonzero exit code</a></li>
<li><a href="#update-a-core-data-object">Update A Core Data Object</a></li>
<li><a href="#delete-a-core-data-object">Delete A Core Data Object</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p><strong>Note</strong>: Object manipulation in Core Data requires an <code>NSManagedObjectContext</code>. The examples in this post assume the variable <code>context</code> is in scope and is a <code>NSManagedObjectContext</code>.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Create, Update, and Delete Core Data Objects in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="defining-a-new-core-data-entity">Defining A New Core Data Entity</h2><!--kg-card-begin: markdown--><p>Core Data is well integrated in Xcode, providing a visual interface for definition entities, properties, and relationships. To open the Data Model Editor, select a <code>.xcdatamodeld</code> file:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/CoreDataModelFile.png" class="kg-image" alt="Create, Update, and Delete Core Data Objects in Swift" loading="lazy" width="542" height="376"><figcaption>Core Data .xcdatamodeld File In Xcode</figcaption></figure><h3 id="new-data-model-entity-using-xcode">New Data Model Entity Using Xcode</h3><!--kg-card-begin: markdown--><p>By default, the editor contains no entities. Select <code>Add Entity</code> in the lower left to create a new entity called <code>Entity</code> with no properties:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/CoreDataEntity.png" class="kg-image" alt="Create, Update, and Delete Core Data Objects in Swift" loading="lazy" width="1418" height="792" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/CoreDataEntity.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/CoreDataEntity.png 1000w, https://www.advancedswift.com/content/images/2021/03/CoreDataEntity.png 1418w" sizes="(min-width: 720px) 720px"><figcaption>New Core Data Entity Definition In Xcode</figcaption></figure><!--kg-card-begin: markdown--><p>Double clicking on the name <code>Entity</code> allows a more descriptive name to be entered. In this example the entity was renamed <code>UserEntity</code>.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>Properties of <code>UserEntity</code> can be added by using the plus button under the <code>Attributes</code> table. For this example, three properties were created. A property <code>age</code> of type <code>Int16</code>, <code>email</code> of type <code>String</code>, and <code>name</code> of type <code>String</code>:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/CoreDataUserEntity.png" class="kg-image" alt="Create, Update, and Delete Core Data Objects in Swift" loading="lazy" width="1418" height="786" srcset="https://www.advancedswift.com/content/images/size/w600/2021/03/CoreDataUserEntity.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/03/CoreDataUserEntity.png 1000w, https://www.advancedswift.com/content/images/2021/03/CoreDataUserEntity.png 1418w" sizes="(min-width: 720px) 720px"><figcaption>Core Data UserEntity Entity Definition In Xcode</figcaption></figure><!--kg-card-begin: markdown--><p>Xcode automatically saves changes to the <code>.xcdatamodeld</code> file when using the visual Data Model Editor.</p>
<!--kg-card-end: markdown--><h3 id="xcode-nsmanagedobject-sync">Xcode NSManagedObject Sync</h3><!--kg-card-begin: markdown--><p>Defining entities in the <code>.xcdatamodeld</code> file enables Xcode to create types automatically for each entity. In this example, when the project is built Xcode will use the <code>UserEntity</code> definition in the <code>.xcdatamodeld</code> file to create a <code>UserEntity</code> type available in Swift.</p>
<p>This <code>UserEntity</code> type will automatically have the same properties as the entity definition in the <code>.xcdatamodeld</code> file. Specifically, the <code>UserEntity</code> type will have a <code>Int16</code> property <code>age</code>, a <code>String?</code> property <code>email</code>, and a <code>String?</code> property <code>name</code>.</p>
<!--kg-card-end: markdown--><h2 id="create-a-new-core-data-object">Create A New Core Data Object</h2><!--kg-card-begin: markdown--><p>After defining a new <code>UserEntity</code> entity in the <code>.xcdatamodeld</code> file, <code>UserEntity</code> can be used as a type in Swift. The <code>UserEntity</code> constructor takes in a <code>NSManagedObjectContext</code> and returns an instance of <code>UserEntity</code> with all properties set to default values.</p>
<!--kg-card-end: markdown--><h3 id="new-nsmanagedobject-example">New NSManagedObject Example</h3><pre><code class="language-swift">// Create a new UserEntity in the
// NSManagedObjectContext context
let user = UserEntity(context: context)

// Assign values to the entity&apos;s properties
user.name = &quot;User Name&quot;
user.email = &quot;user@domain.com&quot;
user.age = 32

// To save the new entity to the persistent store, call
// save on the context
do {
    try context.save()
}
catch {
    // Handle Error
}</code></pre><h3 id="use-of-unresolved-identifier-entity-">Use of unresolved identifier &#x2018;Entity&#x2019;</h3><!--kg-card-begin: markdown--><p>One common error when working with Xcode managed <code>.xcdatamodeld</code> file is <code>Use of unresolved identifier &apos;Entity&apos;</code>. This error means that Xcode did not properly update entity description changes in the <code>.xcdatamodeld</code> when compiling the iOS or macOS application.</p>
<p>Cleaning the build folder can often resolve this issue. The build folder can be cleaned using the Product menu and selecting Clean Build Folder:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/03/CleanBuildFolder.png" class="kg-image" alt="Create, Update, and Delete Core Data Objects in Swift" loading="lazy" width="444" height="494"><figcaption>Clean Build Folder Menu Command In Xcode</figcaption></figure><h3 id="command-compileswiftsources-failed-with-a-nonzero-exit-code">Command CompileSwiftSources failed with a nonzero exit code</h3><!--kg-card-begin: markdown--><p>Another common error when working with Xcode managed <code>.xcdatamodeld</code> file is <code>Command CompileSwiftSources failed with a nonzero exit code</code> and is often preceded with <code>error: no such file or directory</code>.</p>
<p>Like the <code>Use of unresolved identifier error</code>, cleaning the build folder can often resolve this issue.</p>
<!--kg-card-end: markdown--><h2 id="update-a-core-data-object">Update A Core Data Object</h2><!--kg-card-begin: markdown--><pre><code class="language-swift">// Update entity properties as needed
user.age = 33

// To save new entity updates to the persistent store,
// call save on the context
do {
    try context.save()
}
catch {
    // Handle Error
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="delete-a-core-data-object">Delete A Core Data Object</h2><!--kg-card-begin: markdown--><pre><code class="language-swift">// Delete the entity from the context
context.delete(user)

// To delete the entity from the persistent store, call
// save on the context
do {
    try context.save()
}
catch {
    // Handle Error
}
</code></pre>
<!--kg-card-end: markdown--><h2 id="saving-modifying-and-removing-an-nsmanagedobject-in-swift">Saving, Modifying, and Removing An NSManagedObject in Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>NSManagedObject</code>, <code>NSManagedObjectContext</code>, and Xcode, you can define new database entities, create new entities, update existing entities, and delete entities in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Corner Radius, Shadows, and Borders in Swift]]></title><description><![CDATA[Learn how to apply a corner radius, shadow, and border to all kinds of views, including UIViews, UIButtons, and UIImageViews, in Swift.]]></description><link>https://www.advancedswift.com/corners-borders-shadows/</link><guid isPermaLink="false">603aed2702ca8f0039b64034</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><category><![CDATA[UI]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 28 Feb 2021 01:53:33 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1583118289889-f9e5ee78c82a?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDE0NXx8Y3V0fGVufDB8fHw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1583118289889-f9e5ee78c82a?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDE0NXx8Y3V0fGVufDB8fHw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Corner Radius, Shadows, and Borders in Swift"><p>Rounding corners, adding shadows, and drawing borders are a common way to differentiate UI elements and make an iOS application&#x2019;s design stand out. This post presents examples of how to apply a corner radius, shadow, and border to a view in Swift:</p>
<ol>
<li><a href="#corner-radius">Corner Radius</a><br>
a. <a href="#layer-cornerradius">layer.cornerRadius</a><br>
b. <a href="#rounding-top-left-top-right-bottom-left-and-bottom-right-corners-separately">Rounding Top-Left, Top-Right, Bottom-Left, and Bottom-Right Corners Separately</a><br>
c. <a href="#-ibdesignable-ibinspectable-corner-radius">@IBDesignable, @IBInspectable Corner Radius</a><br>
d. <a href="#corner-radius-in-storyboard">Corner Radius In Storyboard</a><br>
e. <a href="#examples-of-uiview-uibutton-uiimageview-with-rounded-corners">Examples of UIView, UIButton, UIImageView With Rounded Corners</a></li>
<li><a href="#shadows">Shadows</a><br>
a. <a href="#layer-shadow-properties">layer.shadow Properties</a><br>
b. <a href="#-ibdesignable-ibinspectable-shadow">@IBDesignable, @IBInspectable Shadow</a><br>
c. <a href="#shadow-in-storyboard">Shadow In Storyboard</a><br>
d. <a href="#examples-of-uiview-uibutton-uiimageview-with-a-shadow">Examples of UIView, UIButton, UIImageView With A Shadow</a></li>
<li><a href="#borders">Borders</a><br>
a. <a href="#layer-border-properties">layer.border Properties</a><br>
b. <a href="#-ibdesignable-ibinspectable-border">@IBDesignable, @IBInspectable Border</a><br>
c. <a href="#border-in-storyboard">Border In Storyboard</a><br>
d. <a href="#examples-of-uiview-uibutton-uiimageview-with-a-border">Examples of UIView, UIButton, UIImageView With A Border</a></li>
<li><a href="#solutions-to-common-problems">Solutions To Common Problems</a><br>
a. <a href="#shadows-and-rounded-corners-at-the-same-time">Shadows And Rounded Corners At The Same Time</a><br>
b. <a href="#uiimageview-shadows-with-content-mode-aspect-fill-center-etc-">UIImageView Shadows With Content Mode [Aspect Fill, Center, etc]</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Corner Radius, Shadows, and Borders in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="corner-radius">Corner Radius</h2><h3 id="layer-cornerradius">layer.cornerRadius</h3><!--kg-card-begin: markdown--><p>Rounding all corners on a <code>UIView</code> can be implemented by setting the <code>cornerRadius</code> property on the view&#x2019;s <code>layer</code>:</p>
<pre><code class="language-swift">view.layer.cornerRadius = 5.0
</code></pre>
<!--kg-card-end: markdown--><h3 id="rounding-top-left-top-right-bottom-left-and-bottom-right-corners-separately">Rounding Top-Left, Top-Right, Bottom-Left, and Bottom-Right Corners Separately</h3><!--kg-card-begin: markdown--><p>Sometimes rounding on only certain corners of a view is desirable. To set the corner radius for only some corners, use <code>UIBezier</code> to create a mask path specifying the <code>UIRectCorner</code> that should be rounded:</p>
<pre><code class="language-swift">// Specify which corners to round
let corners = UIRectCorner(arrayLiteral: [
    UIRectCorner.topLeft,
    UIRectCorner.topRight,
    UIRectCorner.bottomLeft,
    UIRectCorner.bottomRight
])

// Determine the size of the rounded corners
let cornerRadii = CGSize(
    width: cornerRadius,
    height: cornerRadius
)

// A mask path is a path used to determine what
// parts of a view are drawn. UIBezier path can
// be used to create a path where only specific
// corners are rounded
let maskPath = UIBezierPath(
    roundedRect: view.bounds,
    byRoundingCorners: corners,
    cornerRadii: cornerRadii
)

// Apply the mask layer to the view
let maskLayer = CAShapeLayer()
maskLayer.path = maskPath.cgPath
maskLayer.frame = view.bounds

view.layer.mask = maskLayer
</code></pre>
<!--kg-card-end: markdown--><h3 id="-ibdesignable-ibinspectable-corner-radius">@IBDesignable, @IBInspectable Corner Radius</h3><!--kg-card-begin: markdown--><p>An <code>@IBDesignable</code> <code>UIView</code> extension marking the <code>cornerRadius</code> property as <code>@IBInspectable</code> can be implemented to allow a corner radius to be set in a <code>Storyboard</code>:</p>
<pre><code class="language-swift">@IBDesignable extension UIView {
    @IBInspectable var cornerRadius: CGFloat {
        get { return layer.cornerRadius }
        set { 
              layer.cornerRadius = newValue

              // If masksToBounds is true, subviews will be 
              // clipped to the rounded corners.
              layer.masksToBounds = (newValue &gt; 0)
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="corner-radius-in-storyboard">Corner Radius In Storyboard</h3><!--kg-card-begin: markdown--><p>Implementing the <code>@IBDesignable</code> <code>UIView</code> extension and applying the <code>@IBInspectable</code> modifier to the <code>cornerRadius</code> property allows a view&#x2019;s corner radius to be set in a Storyboard&#x2019;s Attributes Inspector:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/RoundedCornersInStoryboard.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="1058" height="352" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/RoundedCornersInStoryboard.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/02/RoundedCornersInStoryboard.png 1000w, https://www.advancedswift.com/content/images/2021/02/RoundedCornersInStoryboard.png 1058w" sizes="(min-width: 720px) 720px"><figcaption>Setting A UIView Corner Radius In A Storyboard Attribute Inspector</figcaption></figure><h3 id="examples-of-uiview-uibutton-uiimageview-with-rounded-corners">Examples of UIView, UIButton, UIImageView With Rounded Corners</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/RoundedCornersExamples.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="942" height="238" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/RoundedCornersExamples.png 600w, https://www.advancedswift.com/content/images/2021/02/RoundedCornersExamples.png 942w" sizes="(min-width: 720px) 720px"><figcaption>UIView, UIButton, and UIImageView with Rounded Corners</figcaption></figure><h2 id="shadows">Shadows</h2><h3 id="layer-shadow-properties">layer.shadow Properties</h3><!--kg-card-begin: markdown--><p>Adding a shadow to a <code>UIView</code> can be implemented by setting the <code>shadowColor</code>, <code>shadowOpacity</code>, <code>shadowOffset</code>, and <code>shadowRadius</code> properties on the view&#x2019;s <code>layer</code>:</p>
<pre><code class="language-swift">view.layer.shadowColor = UIColor.black.cgColor
view.layer.shadowOpacity = 0.2
view.layer.shadowOffset = CGSize(width: 4, height: 4)
view.layer.shadowRadius = 5.0

// Set masksToBounds to false, otherwise the shadow
// will be clipped and will not appear outside of 
// the view&#x2019;s frame
view.layer.masksToBounds = false
</code></pre>
<!--kg-card-end: markdown--><h3 id="-ibdesignable-ibinspectable-shadow">@IBDesignable, @IBInspectable Shadow</h3><!--kg-card-begin: markdown--><p>An <code>@IBDesignable</code> <code>UIView</code> extension marking the shadow properties as <code>@IBInspectable</code> can be implemented to allow view shadows to be configured in a Storyboard:</p>
<pre><code class="language-swift">@IBDesignable extension UIView {
    @IBInspectable var shadowRadius: CGFloat {
        get { return layer.shadowRadius }
        set { layer.shadowRadius = newValue }
    }

    @IBInspectable var shadowOpacity: CGFloat {
        get { return CGFloat(layer.shadowOpacity) }
        set { layer.shadowOpacity = Float(newValue) }
    }

    @IBInspectable var shadowOffset: CGSize {
        get { return layer.shadowOffset }
        set { layer.shadowOffset = newValue }
    }

    @IBInspectable var shadowColor: UIColor? {
        get {
            guard let cgColor = layer.shadowColor else { 
                return nil 
            }
            return UIColor(cgColor: cgColor)
        }
        set { layer.shadowColor = newValue?.cgColor }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="shadow-in-storyboard">Shadow In Storyboard</h3><!--kg-card-begin: markdown--><p>By implementing the <code>@IBDesignable</code> <code>UIView</code> extension and applying the <code>@IBInspectable</code> modifier to the shadow properties, a view&#x2019;s shadow to be set in a Storyboard&#x2019;s Attributes Inspector:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/ShadowInStoryboard.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="1086" height="364" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/ShadowInStoryboard.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/02/ShadowInStoryboard.png 1000w, https://www.advancedswift.com/content/images/2021/02/ShadowInStoryboard.png 1086w" sizes="(min-width: 720px) 720px"><figcaption>Setting A UIView Shadow In A Storyboard Attribute Inspector</figcaption></figure><h3 id="examples-of-uiview-uibutton-uiimageview-with-a-shadow">Examples of UIView, UIButton, UIImageView With A Shadow</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/ShadowExamples.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="926" height="238" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/ShadowExamples.png 600w, https://www.advancedswift.com/content/images/2021/02/ShadowExamples.png 926w" sizes="(min-width: 720px) 720px"><figcaption>UIView, UIButton, and UIImageView with a Shadow</figcaption></figure><h2 id="borders">Borders</h2><h3 id="layer-border-properties">layer.border Properties</h3><!--kg-card-begin: markdown--><p>Adding a border to a <code>UIView</code> can be implemented by setting the <code>borderColor</code> and <code>borderWidth</code> properties on the view&#x2019;s layer:</p>
<pre><code class="language-swift">view.layer.borderColor = UIColor.black.cgColor
view.layer.borderWidth = 2
</code></pre>
<!--kg-card-end: markdown--><h3 id="-ibdesignable-ibinspectable-border">@IBDesignable, @IBInspectable Border</h3><!--kg-card-begin: markdown--><p>An <code>@IBDesignable</code> <code>UIView</code> extension marking the border properties as <code>@IBInspectable</code> can be implemented to allow view borders to be configured in a Storyboard:</p>
<pre><code class="language-swift">@IBDesignable extension UIView {
    @IBInspectable var borderColor: UIColor? {
        get {
            guard let cgColor = layer.borderColor else { 
                return nil 
            }
            return UIColor(cgColor: cgColor)
        }
        set { layer.borderColor = newValue?.cgColor }
    }

    @IBInspectable var borderWidth: CGFloat {
        get {
            return layer.borderWidth
        }
        set {
            layer.borderWidth = newValue
        }
    }
}
</code></pre>
<!--kg-card-end: markdown--><h3 id="border-in-storyboard">Border In Storyboard</h3><!--kg-card-begin: markdown--><p>By implementing the <code>@IBDesignable</code> <code>UIView</code> extension and applying the <code>@IBInspectable</code> modifier to the border properties, a view&#x2019;s border to be set in a Storyboard&#x2019;s Attributes Inspector:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/BorderInStoryboard.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="1020" height="380" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/BorderInStoryboard.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/02/BorderInStoryboard.png 1000w, https://www.advancedswift.com/content/images/2021/02/BorderInStoryboard.png 1020w" sizes="(min-width: 720px) 720px"><figcaption>Setting A UIView Border In A Storyboard Attribute Inspector</figcaption></figure><h3 id="examples-of-uiview-uibutton-uiimageview-with-a-border">Examples of UIView, UIButton, UIImageView With A Border</h3><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/BorderExamples.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="958" height="230" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/BorderExamples.png 600w, https://www.advancedswift.com/content/images/2021/02/BorderExamples.png 958w" sizes="(min-width: 720px) 720px"><figcaption>UIView, UIButton, and UIImageView with a Border</figcaption></figure><h2 id="solutions-to-common-problems">Solutions To Common Problems</h2><h3 id="shadows-and-rounded-corners-at-the-same-time">Shadows And Rounded Corners At The Same Time</h3><!--kg-card-begin: markdown--><p>One challenge with shadows and rounded corners are subviews. Clipping subviews, for example using <code>masksToBounds</code>, is necessary for rounded corners to cut off subviews. However, clipping prevents the shadow from drawing:</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/ShadowAndCornerRadius.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="2000" height="422" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/ShadowAndCornerRadius.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/02/ShadowAndCornerRadius.png 1000w, https://www.advancedswift.com/content/images/size/w1600/2021/02/ShadowAndCornerRadius.png 1600w, https://www.advancedswift.com/content/images/2021/02/ShadowAndCornerRadius.png 2250w" sizes="(min-width: 720px) 720px"><figcaption>UIView Corner Radius and Shadow, Not Working And Working Examples</figcaption></figure><!--kg-card-begin: markdown--><p>One solution is to create a view <code>container</code> that will only draw the shadow, and another view <code>contentView</code> that will clip subviews to rounded corners:</p>
<pre><code class="language-swift">let contentView = UIView()
contentView.layer.cornerRadius = 5.0
contentView.layer.masksToBounds = true

let container = UIView()
container.layer.cornerRadius = 5.0
container.layer.masksToBounds = false

container.layer.shadowColor = UIColor.black.cgColor
container.layer.shadowOffset = CGSize(width: 4, height: 4)
container.layer.shadowOpacity = 0.2
container.layer.shadowRadius = 5.0

contentView.frame = container.bounds
contentView.autoresizingMask = [
    .flexibleWidth, .flexibleHeight
]

container.addSubview(contentView)
</code></pre>
<!--kg-card-end: markdown--><h3 id="uiimageview-shadows-with-content-mode-aspect-fill-center-etc-">UIImageView Shadows With Content Mode [Aspect Fill, Center, etc]</h3><!--kg-card-begin: markdown--><p>Shadows are drawn outside of a view&#x2019;s <code>bounds</code>, meaning <code>clipToBounds</code> and the view&#x2019;s <code>layer</code> <code>masksToBounds</code> properties must be <code>false</code> for the shadow to be visible.</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>A <code>UIImageView</code> with <code>contentMode</code> set to <code>.aspectFill</code>, <code>.center</code>, and others will draw the image outside of the <code>UIImageView</code> <code>bounds</code> if <code>clipToBounds</code> is <code>false</code>. Example (the outline is the bounds of the image view):</p>
<!--kg-card-end: markdown--><figure class="kg-card kg-image-card kg-card-hascaption"><img src="https://www.advancedswift.com/content/images/2021/02/ImageViewFillOutsideBounds.png" class="kg-image" alt="Corner Radius, Shadows, and Borders in Swift" loading="lazy" width="1284" height="436" srcset="https://www.advancedswift.com/content/images/size/w600/2021/02/ImageViewFillOutsideBounds.png 600w, https://www.advancedswift.com/content/images/size/w1000/2021/02/ImageViewFillOutsideBounds.png 1000w, https://www.advancedswift.com/content/images/2021/02/ImageViewFillOutsideBounds.png 1284w" sizes="(min-width: 720px) 720px"><figcaption>Image Drawing Outside Of A UIImageView Bounds</figcaption></figure><!--kg-card-begin: markdown--><p>The solution is the same as presented in the <a href="#shadows-and-rounded-corners-at-the-same-time">Shadows And Rounded Corners At The Same Time</a> section, except that the <code>imageView</code> is the <code>contentView</code> in the provided code example.</p>
<!--kg-card-end: markdown--><h2 id="corner-radius-shadows-and-borders-in-swift">Corner Radius, Shadows, and Borders in Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using the appropriate layer properties on a <code>UIView</code>, you can apply a corner radius, shadow, and border to views, buttons, tables, images, and all other views in Swift.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item><item><title><![CDATA[Email, Phone, Username, Password, and Date Regular Expressions in Swift]]></title><description><![CDATA[Learn how to create and use regular expressions in Swift to validate emails, phone numbers, usernames, passwords, and dates.]]></description><link>https://www.advancedswift.com/regular-expressions/</link><guid isPermaLink="false">60320b040792c80045d49ac1</guid><category><![CDATA[Swift]]></category><category><![CDATA[iOS]]></category><category><![CDATA[macOS]]></category><dc:creator><![CDATA[Robert Pieta]]></dc:creator><pubDate>Sun, 21 Feb 2021 07:39:47 GMT</pubDate><media:content url="https://images.unsplash.com/photo-1529957018945-07aed3538ad5?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDJ8fG9yZ2FuaXplfGVufDB8fHw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" medium="image"/><content:encoded><![CDATA[<!--kg-card-begin: markdown--><img src="https://images.unsplash.com/photo-1529957018945-07aed3538ad5?crop=entropy&amp;cs=tinysrgb&amp;fit=max&amp;fm=jpg&amp;ixid=MXwxMTc3M3wwfDF8c2VhcmNofDJ8fG9yZ2FuaXplfGVufDB8fHw&amp;ixlib=rb-1.2.1&amp;q=80&amp;w=2000" alt="Email, Phone, Username, Password, and Date Regular Expressions in Swift"><p>Validating user input is a common task in dynamic iOS and macOS apps. This post presents examples of using regular expressions to validate email, phone number, username, password, and date user inputs in Swift:</p>
<ol>
<li><a href="#email-regular-expression">Email Regular Expression</a><br>
a. <a href="#simple-email-regex">Simple Email Regex</a><br>
b. <a href="#email-validation-example">Email Validation Example</a></li>
<li><a href="#phone-number-regular-expression">Phone Number Regular Expression</a><br>
a. <a href="#simple-phone-number-regex">Simple Phone Number Regex</a><br>
b. <a href="#phone-number-validation-example">Phone Number Validation Example</a></li>
<li><a href="#username-regular-expression">Username Regular Expression</a><br>
a. <a href="#simple-username-regex">Simple Username Regex</a><br>
b. <a href="#username-validation-example">Username Validation Example</a></li>
<li><a href="#password-regular-expression">Password Regular Expression</a><br>
a. <a href="#simple-password-regex">Simple Password Regex</a><br>
b. <a href="#password-validation-example">Password Validation Example</a></li>
<li><a href="#date-regular-expression">Date Regular Expression</a><br>
a. <a href="#simple-date-regex">Simple Date Regex</a><br>
b. <a href="#date-validation-example">Date Validation Example</a></li>
</ol>
<!--kg-card-end: markdown--><!--kg-card-begin: html--><section class="subscribe-form">
    <h3 class="subscribe-form-title"><b>FREE all Swift</b> Loading Animations</h3>
    <img src="https://www.advancedswift.com/content/images/2021/05/AdvancedSwiftLoadingAnimations-4.gif" alt="Email, Phone, Username, Password, and Date Regular Expressions in Swift" style="width: 350px; padding: 20px;">
    <p class="subscribe-form-description"><i>Immediately</i> get access to commented code for these animations when you follow Advanced Swift.</p>
    <form data-members-form="subscribe">
        <div class="form-group">
            <input class="subscribe-email" data-members-email placeholder="Enter your email" autocomplete="false">
            <button class="button primary" type="submit" style="min-width: 110px;">
                <span class="button-content">Get Code</span>
                <span class="button-loader">
                    <svg version="1.1" id="loader-1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="40px" height="40px" viewbox="0 0 40 40" enable-background="new 0 0 40 40" xml:space="preserve">
    <path opacity="0.2" fill="#000" d="M20.201,5.169c-8.254,0-14.946,6.692-14.946,14.946c0,8.255,6.692,14.946,14.946,14.946
s14.946-6.691,14.946-14.946C35.146,11.861,28.455,5.169,20.201,5.169z M20.201,31.749c-6.425,0-11.634-5.208-11.634-11.634
c0-6.425,5.209-11.634,11.634-11.634c6.425,0,11.633,5.209,11.633,11.634C31.834,26.541,26.626,31.749,20.201,31.749z"/>
    <path fill="#000" d="M26.013,10.047l1.654-2.866c-2.198-1.272-4.743-2.012-7.466-2.012h0v3.312h0
C22.32,8.481,24.301,9.057,26.013,10.047z">
        <animatetransform attributetype="xml" attributename="transform" type="rotate" from="0 20 20" to="360 20 20" dur="0.5s" repeatcount="indefinite"/>
    </path>
</svg>
                </span>
            </button>
        </div>
        <div class="message-success">
            <strong>Great!</strong> Check your inbox and click the link to get access.
        </div>
        <div class="message-error">
            Please enter a valid email address!
        </div>
    </form>
</section><!--kg-card-end: html--><h2 id="email-regular-expression">Email Regular Expression</h2><!--kg-card-begin: markdown--><p>Emails can be validated using a regular expression. Matching the full email address specification requires a complex regular expression. However, for many iOS and macOS applications a simple email regular expression is acceptable.</p>
<!--kg-card-end: markdown--><h3 id="simple-email-regex">Simple Email Regex</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">// One or more characters followed by an &quot;@&quot;,
// then one or more characters followed by a &quot;.&quot;,
// and finishing with one or more characters
let emailPattern = #&quot;^\S+@\S+\.\S+$&quot;#

// Matching Examples
// user@domain.com
// firstname.lastname-work@domain.com
</code></pre>
<!--kg-card-end: markdown--><h3 id="email-validation-example">Email Validation Example</h3><!--kg-card-begin: markdown--><p>One way to validate emails with regular expressions is the <code>String</code> method <code>range(of:, options:)</code>:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// &quot;test@test.com&quot; matches emailPattern,
// so result is a Range&lt;String.Index&gt;
var result = &quot;test@test.com&quot;.range(
    of: emailPattern,
    options: .regularExpression
)

let validEmail = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>If an iOS or macOS application uses the same regular expression many times, the <code>NSRegularExpression</code> method <code>matches(in:, options:, range:)</code> may be more efficient:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let emailRegex = try! NSRegularExpression(
    pattern: emailPattern,
    options: []
)

let source = &quot;test@test.com&quot;
let sourceRange = NSRange(
    source.startIndex..&lt;source.endIndex,
    in: source
)

// &quot;test@test.com&quot; matches emailPattern,
// so result is a [NSTextCheckingResult]
var result = emailRegex.matches(
    in: source,
    options: [],
    range: sourceRange
)

let validEmail = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><h3 id="phone-number-regular-expression">Phone Number Regular Expression</h3><!--kg-card-begin: markdown--><p>Phone numbers can be validated using regular expressions. If an iOS or macOS is localized for customers in different parts of the world, change the regular expression to match regional phone number format conventions.</p>
<!--kg-card-end: markdown--><h3 id="simple-phone-number-regex">Simple Phone Number Regex</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">// 3 numbers, then 3 numbers, then 4 numbers
// The first 3 numbers may be enclosed in (), and either 
// &quot; &quot; or &quot;-&quot; can be used to separate number groups
let phonePattern = #&quot;^\(?\d{3}\)?[ -]?\d{3}[ -]?\d{4}$&quot;#

// Matching Examples
//111-222 3333
//111 222 3333
//(111) 222-3333
//1112223333
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>The <code>phonePattern</code> can be adapted to validate other phone number formats. The syntax <code>\d{3}</code> matches 3 numbers <code>123</code>. To match, for example <code>22-33</code>, the syntax would be <code>\d{2}-\d{2}</code>.</p>
<!--kg-card-end: markdown--><h3 id="phone-number-validation-example">Phone Number Validation Example</h3><!--kg-card-begin: markdown--><p>One way to validate phone numbers with regular expressions is the <code>String</code> method <code>range(of:, options:)</code>:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// &quot;(567)-678 1231&quot; matches emailPattern,
// so result is a Range&lt;String.Index&gt;
var result = &quot;(567)-678 1231&quot;.range(
    of: phonePattern,
    options: .regularExpression
)

let validPhoneNumber = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>If an iOS or macOS application uses the same regular expression many times, the <code>NSRegularExpression</code> method <code>matches(in:, options:, range:)</code> may be more efficient:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let phoneRegex = try! NSRegularExpression(
    pattern: phonePattern,
    options: []
)

let source = &quot;(567)-678 1231&quot;
let sourceRange = NSRange(
    source.startIndex..&lt;source.endIndex,
    in: source
)

// &quot;(567)-678 1231&quot; matches phonePattern,
// so result is a [NSTextCheckingResult]
var result = phoneRegex.matches(
    in: source,
    options: [],
    range: sourceRange
)

let validPhoneNumber = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><h3 id="username-regular-expression">Username Regular Expression</h3><!--kg-card-begin: markdown--><p>Usernames and full names can be validated using regular expressions. If an iOS or macOS is localized for customers in different parts of the world, change the regular expression to accept regional language characters.</p>
<!--kg-card-end: markdown--><h3 id="simple-username-regex">Simple Username Regex</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">// One or more characters, followed by any text,
// then a space, and finally one or more characters.
// This regular expression requires first and last names, 
// while also accepting middle names.
let usernamePattern = #&quot;^[a-zA-Z-]+ ?.* [a-zA-Z-]+$&quot;#

// Matching Examples
// Steve Jobs
// Tim Cook
// Greg Joz Joswiak
</code></pre>
<!--kg-card-end: markdown--><h3 id="username-validation-example">Username Validation Example</h3><!--kg-card-begin: markdown--><p>One way to validate usernames with regular expressions is the <code>String</code> method <code>range(of:, options:)</code>:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// &quot;FirstName LastName&quot; matches usernamePattern,
// so result is a Range&lt;String.Index&gt;
var result = &quot;FirstName LastName&quot;.range(
    of: usernamePattern,
    options: .regularExpression
)

var validUsername = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>If an iOS or macOS application uses the same regular expression many times, the <code>NSRegularExpression</code> method <code>matches(in:, options:, range:)</code> may be more efficient:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let nameRegex = try! NSRegularExpression(
    pattern: usernamePattern,
    options: []
)

let source = &quot;FirstName LastName&quot;
let sourceRange = NSRange(
    source.startIndex..&lt;source.endIndex,
    in: source
)

// &quot;FirstName LastName&quot; matches usernamePattern,
// so result is a [NSTextCheckingResult]
var result = nameRegex.matches(
    in: source,
    options: [],
    range: sourceRange
)

let validUsername = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>In addition to username validation, extracting a first and last name from a username is a common task that can be implemented with regular expressions. The article <a href="https://www.advancedswift.com/regex-capture-groups/">Regular Expression Capture Groups</a> presents examples of using capture groups to extract first and last names.</p>
<!--kg-card-end: markdown--><h2 id="password-regular-expression">Password Regular Expression</h2><!--kg-card-begin: markdown--><p>Password requirements can be validated using regular expressions. Regular expressions are flexible, and can support many different password requirements found in iOS and macOS apps.</p>
<!--kg-card-end: markdown--><h3 id="simple-password-regex">Simple Password Regex</h3><!--kg-card-begin: markdown--><p>The <code>?=</code> syntax is used to create a &quot;positive look ahead&quot; check in a regular expression. Combining multiple positive look aheads is one way to create a multi-requirement password validation regular expression:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let passwordPattern =
    // At least 8 characters
    #&quot;(?=.{8,})&quot;# +

    // At least one capital letter
    #&quot;(?=.*[A-Z])&quot;# +
        
    // At least one lowercase letter
    #&quot;(?=.*[a-z])&quot;# +
        
    // At least one digit
    #&quot;(?=.*\d)&quot;# +
        
    // At least one special character
    #&quot;(?=.*[ !$%&amp;?._-])&quot;#
</code></pre>
<!--kg-card-end: markdown--><h3 id="password-validation-example">Password Validation Example</h3><!--kg-card-begin: markdown--><p>One way to validate passwords with regular expressions is the <code>String</code> method <code>range(of:, options:)</code>:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// &quot;$tr0ngPa$$w0rd&quot; matches passwordPattern,
// so result is a Range&lt;String.Index&gt;
var result = &quot;$tr0ngPa$$w0rd&quot;.range(
    of: passwordPattern,
    options: .regularExpression
)

var validPassword = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>If an iOS or macOS application uses the same regular expression many times, the <code>NSRegularExpression</code> method <code>matches(in:, options:, range:)</code> may be more efficient:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let passwordRegex = try! NSRegularExpression(
    pattern: passwordPattern,
    options: []
)

let source = &quot;$tr0ngPa$$w0rd&quot;
let sourceRange = NSRange(
    source.startIndex..&lt;source.endIndex,
    in: source
)

// &quot;$tr0ngPa$$w0rd&quot; matches passwordPattern,
// so result is a [NSTextCheckingResult]
var result = passwordRegex.matches(
    in: source,
    options: [],
    range: sourceRange
)

let validPassword = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><h2 id="date-regular-expression">Date Regular Expression</h2><!--kg-card-begin: markdown--><p>Date formats can be validated using regular expressions. Change the date regular expression to match the expected date input format of your iOS or macOS application</p>
<!--kg-card-end: markdown--><h3 id="simple-date-regex">Simple Date Regex</h3><!--kg-card-begin: markdown--><pre><code class="language-swift">// 1-2 digits followed by &quot;-&quot; or &quot;/&quot;,
// then 1-2 digits followed by &quot;-&quot; or &quot;/&quot;,
// finally 4 digits
let datePattern = #&quot;^\d{1,2}[\/-]\d{1,2}[\/-]\d{4}$&quot;#

// Matching Examples
// 1/2/2021
// 02-03-2020
</code></pre>
<!--kg-card-end: markdown--><h3 id="date-validation-example">Date Validation Example</h3><!--kg-card-begin: markdown--><p>One way to validate dates with regular expressions is the <code>String</code> method <code>range(of:, options:)</code>:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">// &quot;02-3-2020&quot; matches datePattern,
// so result is a Range&lt;String.Index&gt;
var result = &quot;02-3-2020&quot;.range(
    of: datePattern,
    options: .regularExpression
)

var validDate = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>If an iOS or macOS application uses the same regular expression many times, the <code>NSRegularExpression</code> method <code>matches(in:, options:, range:)</code> may be more efficient:</p>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><pre><code class="language-swift">let dateRegex = try! NSRegularExpression(
    pattern: datePattern,
    options: []
)

let source = &quot;02-3-2020&quot;
let sourceRange = NSRange(
    source.startIndex..&lt;source.endIndex,
    in: source
)

// &quot;02-3-2020&quot; matches datePattern,
// so result is a [NSTextCheckingResult]
var result = dateRegex.matches(
    in: source,
    options: [],
    range: sourceRange
)

let validDate = (result != nil)
</code></pre>
<!--kg-card-end: markdown--><!--kg-card-begin: markdown--><p>In addition to date validation, extracting date components from a date is a common task that can be implemented with regular expressions. The article <a href="https://www.advancedswift.com/regex-capture-groups/">Regular Expression Capture Groups</a> presents examples of using capture groups to extract date components.</p>
<!--kg-card-end: markdown--><h2 id="regular-expressions-in-swift">Regular Expressions in Swift</h2><!--kg-card-begin: markdown--><p>That&#x2019;s it! By using <code>NSRegularExpression</code> and <code>String.range(of:, options:)</code> you can validate email, phone number, username, password, and date inputs in Swift using regular expressions.</p>
<!--kg-card-end: markdown-->]]></content:encoded></item></channel></rss>