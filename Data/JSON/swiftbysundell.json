{
  "version": "https://jsonfeed.org/version/1",
  "title": "Swift by Sundell",
  "home_page_url": "https://www.swiftbysundell.com/",
  "description": "Weekly Swift articles, podcasts and tips by John Sundell",
  "items": [
    {
      "guid": "https://www.swiftbysundell.com/articles/connecting-async-await-with-other-swift-code",
      "url": "https://www.swiftbysundell.com/articles/connecting-async-await-with-other-swift-code",
      "title": "Connecting async/await to other Swift code",
      "content_html": "<p>Swift 5.5’s new suite of concurrency features definitely played a major role at this year’s edition of WWDC. Particularly, the newly introduced async/await pattern could not just be seen in the more Swift-focused sessions and announcements, but all over the new APIs and features that were unveiled at the conference.</p><p>While async/await is very likely to become the primary way to write asynchronous code on Apple’s platforms going forward, like with all <a href=\"https://www.swiftbysundell.com/articles/shifting-paradigms-in-swift\">major technology transitions</a>, it’s going to take a while for us to get there. So, in this article, let’s explore a few ways to “bridge the gap” between the new world of async/await and other kinds of asynchronous Swift code.</p><p class=\"info\">Note that this article will cover APIs and language features that are currently in beta as part of Xcode 13.</p><h2>What’s async/await?</h2><p>Let’s start with a quick recap what async/await actually is. I’ll go into much more detail in future articles as I gain more hands-on experience with this new pattern and the way it’s integrated into Apple’s SDKs, but — at the most basic level — async/await enables us to annotate asynchronous functions (or computed properties) with the <code>async</code> keyword, which in turn requires us to use the <code>await</code> keyword when calling them. At that point, the system will automatically manage all of the complexity that’s involved in waiting for such an asynchronous call to complete, without blocking any other, outside code from executing.</p><p>For example, the following <code>DocumentLoader</code> has an <code>async</code>-marked <code>loadDocument</code> method, which uses Foundation’s <code>URLSession</code> API to perform an asynchronous network call by <em>awaiting</em> the data that was downloaded from a given URL:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DocumentLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">var</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n\n    <span class=\"s-keyword\">func</span> loadDocument(withID id: <span class=\"s-type\">Document</span>.<span class=\"s-type\">ID</span>) <span class=\"s-keyword\">async</span> <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">Document</span> {\n        <span class=\"s-keyword\">let</span> url = <span class=\"s-call\">urlForForLoadingDocument</span>(withID: id)\n        <span class=\"s-keyword\">let</span> (data, <span class=\"s-keyword\">_</span>) = <span class=\"s-keyword\">try</span> <span class=\"s-keyword\">await</span> urlSession.<span class=\"s-call\">data</span>(from: url)\n        <span class=\"s-keyword\">return try</span> decoder.<span class=\"s-call\">decode</span>(<span class=\"s-type\">Document</span>.<span class=\"s-keyword\">self</span>, from: data)\n    }\n\n    ...\n}</code></pre><p>So <code>async</code>-marked functions can, in turn, call other asynchronous functions just by prefixing those calls with the <code>await</code> keyword. At that point, the local execution will be suspended until that nested <code>await</code> completes, again without blocking any other code from being executed in the meantime.</p><h2>Calling async functions from a synchronous context</h2><p>But then the question is — how do we call an <code>async</code>-marked function from within a context that’s <em>not itself asynchronous</em>? For example, what if we wanted to use the above <code>DocumentLoader</code> within something like a UIKit-based view controller? That’s where <em>tasks</em> come in. What we’ll need to do is to wrap our call to <code>loadDocument</code> in an <code>async</code> closure, which in turn will create a <code>Task</code> within which we can perform our asynchronous calls — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> DocumentViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> documentID: <span class=\"s-type\">Document</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">DocumentLoader</span>\n    \n    ...\n\n    <span class=\"s-keyword\">private func</span> loadDocument() {\n        <span class=\"s-keyword\">async</span> {\n            <span class=\"s-keyword\">do</span> {\n                <span class=\"s-keyword\">let</span> document = <span class=\"s-keyword\">try</span> <span class=\"s-keyword\">await</span> loader.<span class=\"s-call\">loadDocument</span>(withID: documentID)\n                <span class=\"s-call\">display</span>(document)\n            } <span class=\"s-keyword\">catch</span> {\n                <span class=\"s-call\">display</span>(error)\n            }\n        }\n    }\n\n    <span class=\"s-keyword\">private func</span> display(<span class=\"s-keyword\">_</span> document: <span class=\"s-type\">Document</span>) {\n        ...\n    }\n\n    <span class=\"s-keyword\">private func</span> display(<span class=\"s-keyword\">_</span> error: <span class=\"s-type\">Error</span>) {\n        ...\n    }\n}</code></pre><p class=\"info\">Note that the above closure-based <code>async</code> API is likely going to be turned into a proper <code>Task</code> initializer in an upcoming Xcode 13 beta. At that point, I’ll update this article as soon as possible.</p><p>What’s really neat about the above pattern is that we can now use Swift’s default <code>do/try/catch</code> <a href=\"https://www.swiftbysundell.com/basics/error-handling\">error handling mechanism</a> even when performing asynchronous calls. We also no longer have to do any kind of “weak self-dance” in order to avoid retain cycles, and we don’t even need to manually dispatch our UI updates on the main queue, since that’s now being taken care of for us by the <em><a href=\"https://www.swiftbysundell.com/articles/the-main-actor-attribute\">main actor</a></em>.</p><h2>Retrofitting existing APIs with async/await support</h2><p>Next, let’s take a look at how we can go the other way — that is, how we can make some of our existing asynchronous code compatible with the new async/await pattern.</p><p>As an example, let’s say that our app contains the following <code>CommentLoader</code> type that lets us load all of the comments that have been attached to a given document using a completion handler-based API:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> CommentLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> loadCommentsForDocument(\n        withID id: <span class=\"s-type\">Document</span>.<span class=\"s-type\">ID</span>,\n        then handler: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Result</span>&lt;[<span class=\"s-type\">Comment</span>], <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n    ) {\n        ...\n    }\n}</code></pre><p>Initially, it might seem like we’ll need to significantly change the above API in order to make it async/await-compatible, but that’s not actually the case. All that we really have to do is to use the new <code>withCheckedThrowingContinuation</code> function to wrap a call to our existing method within an <code>async</code>-marked version of it — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">CommentLoader</span> {\n    <span class=\"s-keyword\">func</span> loadCommentsForDocument(\n        withID id: <span class=\"s-type\">Document</span>.<span class=\"s-type\">ID</span>\n    ) <span class=\"s-keyword\">async throws</span> -&gt; [<span class=\"s-type\">Comment</span>] {\n        <span class=\"s-keyword\">try await</span> withCheckedThrowingContinuation { continuation <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">loadCommentsForDocument</span>(withID: id) { result <span class=\"s-keyword\">in\n                switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> comments):\n                    continuation.<span class=\"s-call\">resume</span>(returning: comments)\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    continuation.<span class=\"s-call\">resume</span>(throwing: error)\n                }\n            }\n        }\n    }\n}</code></pre><p class=\"info\">Note that the <code>continuation</code> that’s passed into our wrapping closure can only be called once. If we accidentally call it twice, that’ll result in a fatal error. In this case, there’s zero chance of that happening, though, since our completion handler is only called once, but it’s definitely something that’s worth keeping in mind when using this technique. To learn more, check out my friend Vincent’s <a href=\"https://wwdcbysundell.com/2021/wrapping-completion-handlers-into-async-apis\">WWDC article about this topic</a>.</p><p>With the above in place, we can now easily call our <code>loadCommentsForDocument</code> method using the <code>await</code> keyword, just like when calling system-provided asynchronous APIs. For example, here’s how we could update our <code>DocumentLoader</code> to now automatically fetch the comments for each document that it loads:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DocumentLoader {\n    <span class=\"s-keyword\">var</span> commentLoader: <span class=\"s-type\">CommentLoader</span>\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">var</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n\n    <span class=\"s-keyword\">func</span> loadDocument(withID id: <span class=\"s-type\">Document</span>.<span class=\"s-type\">ID</span>) <span class=\"s-keyword\">async throws</span> -&gt; <span class=\"s-type\">Document</span> {\n        <span class=\"s-keyword\">let</span> url = <span class=\"s-call\">urlForForLoadingDocument</span>(withID: id)\n        <span class=\"s-keyword\">let</span> (data, <span class=\"s-keyword\">_</span>) = <span class=\"s-keyword\">try await</span> urlSession.<span class=\"s-call\">data</span>(from: url)\n        <span class=\"s-keyword\">var</span> document = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">decode</span>(<span class=\"s-type\">Document</span>.<span class=\"s-keyword\">self</span>, from: data)\n        document.<span class=\"s-property\">comments</span> = <span class=\"s-keyword\">try await</span> commentLoader.<span class=\"s-call\">loadCommentsForDocument</span>(\n            withID: id\n        )\n        <span class=\"s-keyword\">return</span> document\n    }\n}</code></pre><p>What’s really nice about async/await is that even as we add additional, nested calls, our code doesn’t really grow much in complexity. It keeps looking more or less just like good old fashioned synchronous code, plus a few <code>await</code> keywords.</p><h2>Adapting single-output Combine publishers</h2><p>Finally, let’s also take a look at a way to make certain Combine-powered code async/await-compatible as well. While Swift’s new concurrency system includes other, more “Combine-like” ways to emit dynamic streams of values over time (such as <code>AsyncSequence</code>, and the upcoming <code>AsyncStream</code>), if all that we’re looking to do is to await a single asynchronous result from a Combine pipeline, then here’s a way that we could make that happen in a quite lightweight manner.</p><p>Using the same <code>continuation</code>-based technique that we used earlier, let’s extend Combine’s <code>Publisher</code> protocol with a <code>singleResult</code> method that’ll resume our continuation with the first value that was emitted by a given publisher. We’ll also use Swift’s <a href=\"https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics\">closure capturing mechanics</a> to retain our Combine subscription’s <code>AnyCancellable</code> instance until our operation has been completed — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publishers</span> {\n    <span class=\"s-keyword\">struct</span> MissingOutputError: <span class=\"s-type\">Error</span> {}\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> singleResult() <span class=\"s-keyword\">async throws</span> -&gt; <span class=\"s-type\">Output</span> {\n        <span class=\"s-keyword\">var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n        <span class=\"s-keyword\">var</span> didReceiveValue = <span class=\"s-keyword\">false\n\n        return try await</span> <span class=\"s-call\">withCheckedThrowingContinuation</span> { continuation <span class=\"s-keyword\">in</span>\n            cancellable = <span class=\"s-call\">sink</span>(\n                receiveCompletion: { completion <span class=\"s-keyword\">in\n                    switch</span> completion {\n                    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                        continuation.<span class=\"s-call\">resume</span>(throwing: error)\n                    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">finished</span>:\n                        <span class=\"s-keyword\">if</span> !didReceiveValue {\n                            continuation.<span class=\"s-call\">resume</span>(\n                                throwing: <span class=\"s-type\">Publishers</span>.<span class=\"s-type\">MissingOutputError</span>()\n                            )\n                        }\n                    }\n                },\n                receiveValue: { value <span class=\"s-keyword\">in\n                    guard</span> !didReceiveValue <span class=\"s-keyword\">else</span> { <span class=\"s-keyword\">return</span> }\n\n                    didReceiveValue = <span class=\"s-keyword\">true</span>\n                    cancellable?.<span class=\"s-call\">cancel</span>()\n                    continuation.<span class=\"s-call\">resume</span>(returning: value)\n                }\n            )\n        }\n    }\n}</code></pre><p>If we now imagine that the <code>CommentLoader</code> that we used earlier instead had a Combine-powered API (rather than a closure-based one), then we could now easily use async/await to call it using the above extension:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> CommentLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> loadCommentsForDocument(\n        withID id: <span class=\"s-type\">Document</span>.<span class=\"s-type\">ID</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Comment</span>], <span class=\"s-type\">Error</span>&gt; {\n        ...    \n    }\n}\n\n...\n\n<span class=\"s-keyword\">let</span> comments = <span class=\"s-keyword\">try await</span> loader\n    .<span class=\"s-call\">loadCommentsForDocument</span>(withID: documentID)\n    .<span class=\"s-call\">singleResult</span>()</code></pre><p>Of course, like its name implies, our new <code>singleResult</code> method will only return the first value that a given Combine publisher emitted, so it should only be used on publishers which aren’t expected to produce multiple values over time (unless we’re only interested in the very first value).</p><p>We’ll take a much closer look at how we can bridge the gap between Combine, async/await, and the rest of Swift’s new concurrency system in upcoming articles.</p><h2>Conclusion</h2><p>Async/await offers an exciting new way to write asynchronous code in Swift, and is likely to become a very key part of Apple’s overall API design going forward. However, since it’s not backward compatible with older operating system versions, and since we’ll very likely also need to interact with other code that doesn’t yet use async/await, finding ways to connect such code with Swift’s new concurrency system is going to be incredibly important for many teams.</p><p>Hopefully, this article has given you a few ideas on how to do just that, and if you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "Let’s explore a few ways to “bridge the gap” between the new world of async/await and other kinds of asynchronous Swift code.",
      "date_published": "2021-06-21T17:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/double-cgfloat-auto-conversions",
      "url": "https://www.swiftbysundell.com/tips/double-cgfloat-auto-conversions",
      "title": "Automatic conversions between Double and CGFloat values in Swift 5.5",
      "content_html": "<p><strong>New in Swift 5.5:</strong> The compiler can now automatically perform conversions between <code>Double</code> and <code>CGFloat</code> values.</p><p>Although the two have always been equivalent on 64-bit systems, before Swift 5.5 (which is currently in beta as part of Xcode 13), we had to manually convert between them in order to satisfy Swift’s type system — since they were, and still are, two distinct types as far as the type system in concerned.</p><p>However, when using literals, the compiler has always been able to infer what type that each literal should be turned into based on the current context. For example, within the following SwiftUI view, we’re applying both the <code>scaleEffect</code> and <code>opacity</code> modifier without having to specify that the former accepts a <code>CGFloat</code>, while the latter accepts a <code>Double</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DecorationImage: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Image</span>(name)\n            .<span class=\"s-call\">scaleEffect</span>(<span class=\"s-number\">0.5</span>) <span class=\"s-comment\">// This is a CGFloat</span>\n            .<span class=\"s-call\">opacity</span>(<span class=\"s-number\">0.8</span>) <span class=\"s-comment\">// This is a Double</span>\n    }\n}</code></pre><p>But if we instead were to define those two values as properties, then we’d have to explicitly type our <code>scale</code> value as <code>CGFloat</code> — since otherwise it would be interpreted as a <code>Double</code>, and we’d get a compiler error when trying to pass it to the <code>scaleEffect</code> modifier:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DecorationImage: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> scale: <span class=\"s-type\">CGFloat</span> = <span class=\"s-number\">0.5</span>\n    <span class=\"s-keyword\">var</span> opacity: <span class=\"s-type\">Double</span> = <span class=\"s-number\">0.8</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Image</span>(name)\n            .<span class=\"s-call\">scaleEffect</span>(scale)\n            .<span class=\"s-call\">opacity</span>(opacity)\n    }\n}</code></pre><p>When using Swift 5.5, though, that’s no longer the case — and we can now freely pass <code>Double</code> values to functions that accept a <code>CGFloat</code>, and vice versa. So we could either choose to make both of our properties <code>CGFloat</code> values, or doubles, or (my personal preference) remove the type information entirely and let the compiler infer that they are doubles:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DecorationImage: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> scale = <span class=\"s-number\">0.5</span>\n    <span class=\"s-keyword\">var</span> opacity = <span class=\"s-number\">0.8</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Image</span>(name)\n            .<span class=\"s-call\">scaleEffect</span>(scale)\n            .<span class=\"s-call\">opacity</span>(opacity)\n    }\n}</code></pre><p>The good news is that the above doesn’t just work with system APIs, it works with any code or API that uses <code>CGFloat</code> or <code>Double</code> values. A small, but really nice new feature.</p>",
      "summary": "How the Swift compiler is now able to automatically perform conversions between Double and CGFloat values.",
      "date_published": "2021-06-15T15:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/the-main-actor-attribute",
      "url": "https://www.swiftbysundell.com/articles/the-main-actor-attribute",
      "title": "Using the MainActor attribute to automatically dispatch UI updates on the main queue",
      "content_html": "<p>One challenge when it comes to concurrency on Apple’s platforms is that an app’s UI can, for the most part, only be updated on the <em>main thread</em>. So, whenever we’re performing any kind of work on a background thread (either directly or indirectly), then we always have to make sure to jump back to the main queue before accessing any property, method, or function that has to do with rendering our UI.</p><p>In theory, that might sound simple. In practice, it’s very common to accidentally perform UI updates on a background queue — which can cause glitches, or even put an app in an inconsistent or undefined state, which in turn might lead to crashes and other errors.</p><h2>Manual main queue dispatching</h2><p>So far, the most commonly used solution to this problem has been to wrap all UI-related updates in asynchronous calls to <code>DispatchQueue.main</code>, when there’s any chance that those updates will be triggered on a background queue — for example in situations like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProfileViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> userID: <span class=\"s-type\">User</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">UserLoader</span>\n    <span class=\"s-keyword\">private lazy var</span> nameLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private lazy var</span> biographyLabel = <span class=\"s-type\">UILabel</span>()\n    ...\n\n    <span class=\"s-keyword\">private func</span> loadUser() {\n        loader.<span class=\"s-call\">loadUser</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>.<span class=\"s-property\">async</span> {\n                <span class=\"s-keyword\">switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> user):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">nameLabel</span>.<span class=\"s-property\">text</span> = user.<span class=\"s-property\">name</span>\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">biographyLabel</span>.<span class=\"s-property\">text</span> = user.<span class=\"s-property\">biography</span>\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">showError</span>(error)\n                }\n            }\n        }\n    }\n}</code></pre><p>While the above pattern certainly works, always having to remember to perform those <code>DispatchQueue.main</code> calls is definitely not very convenient, and quite error-prone as well. That’s especially true in situations when it might not be completely obvious that a given piece of code could indeed be run on a background queue, such as when observing <a href=\"https://www.swiftbysundell.com/discover/combine\">Combine publishers</a>, or when implementing certain delegate methods.</p><h2>The main actor</h2><p>Thankfully, Swift 5.5 is introducing what will likely become a much more robust and almost entirely automatic solution to this very common problem — the <em>main actor</em>. While we’ll explore Swift’s implementation of the Actor pattern in much more detail in future articles, for this particular use case, all that we really need to know is that this new, built-in <code>actor</code> implementation ensures that all work that’s being run on it is always performed on the main queue.</p><p class=\"info\">Please note that, at the time of writing, Swift 5.5 is currently in beta as part of Xcode 13.</p><p>So how exactly do we “run” our code on that main actor? The first thing that we have to do is to make our asynchronous code use the new async/await pattern, which is also being introduced as part of Swift 5.5’s suite of concurrency features. In this case, that could be done by creating a new, async/await-powered version of the <code>loadUser</code> method that our above view controller is calling — which simply involves wrapping a call to its default, completion handler-based version using Swift’s new continuation API:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">UserLoader</span> {\n    <span class=\"s-keyword\">func</span> loadUser() <span class=\"s-keyword\">async throws</span> -&gt; <span class=\"s-type\">User</span> {\n        <span class=\"s-keyword\">try await</span> <span class=\"s-call\">withCheckedThrowingContinuation</span> { continuation <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">loadUser</span> { result <span class=\"s-keyword\">in\n                switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> user):\n                    continuation.<span class=\"s-call\">resume</span>(returning: user)\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    continuation.<span class=\"s-call\">resume</span>(throwing: error)\n                }\n            }\n        }\n    }\n}</code></pre><p class=\"info\">To learn more about the above pattern, check out my friend Vincent Pradeilles’ WWDC by Sundell &amp; Friends article <a href=\"https://wwdcbysundell.com/2021/wrapping-completion-handlers-into-async-apis\">“Wrapping completion handlers into async APIs”</a>.</p><p>With the above in place, we can now use an <code>async</code> block, along with Swift’s standard <code>do, try catch</code> <a href=\"https://www.swiftbysundell.com/basics/error-handling\">error handling mechanism</a>, to call our loader’s new async/await-powered API from within our <code>ProfileViewController</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProfileViewController: <span class=\"s-type\">UIViewController</span> {\n    ...\n    \n    <span class=\"s-keyword\">private func</span> loadUser() {\n        <span class=\"s-keyword\">async</span> {\n            <span class=\"s-keyword\">do</span> {\n                <span class=\"s-keyword\">let</span> user = <span class=\"s-keyword\">try await</span> loader.<span class=\"s-call\">loadUser</span>()\n                nameLabel.<span class=\"s-property\">text</span> = user.<span class=\"s-property\">name</span>\n                biographyLabel.<span class=\"s-property\">text</span> = user.<span class=\"s-property\">biography</span>\n            } <span class=\"s-keyword\">catch</span> {\n                <span class=\"s-call\">showError</span>(error)\n            }\n        }\n    }\n}</code></pre><p>But wait, how can the above work without any calls to <code>DispatchQueue.main.async</code>? If <code>loadUser</code> performs its work on a background queue, won’t that mean that our UI will now be incorrectly updated on a background queue as well?</p><p>That’s where the main actor comes in. If we take a look at the declarations for both <code>UILabel</code> and <code>UIViewController</code>, we can see that they’ve both been annotated with the new <code>@MainActor</code> attribute:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@MainActor class</span> UILabel: <span class=\"s-type\">UIView</span>\n<span class=\"s-keyword\">@MainActor class</span> UIViewController: <span class=\"s-type\">UIResponder</span></code></pre><p>What that means is that, when using Swift’s new concurrency system, all properties and methods on those classes (and any of their subclasses, including our <code>ProfileViewController</code>) will automatically be set, called, and accessed on the main queue. All those calls will automatically be routed through the system-provided <code>MainActor</code>, which always performs all of its work on the main thread — completely eliminating the need for us to manually call <code>DispatchQueue.main.async</code>. Really cool!</p><h2>Custom UI-related classes</h2><p>But what if we’re instead working on a completely custom type that we’d also like to gain the above kind of capability? For example, when implementing an <code>ObservableObject</code> that’s used within a SwiftUI view, we need to make sure to only assign its <code>@Published</code>-marked properties on the main queue, so wouldn’t it be great if we could also leverage the <code>MainActor</code> in those cases as well?</p><p>The good news is — we can! Just like how many of UIKit’s built-in classes are now annotated with <code>@MainActor</code>, we can apply that attribute to our own classes as well — giving them that same automatic main thread-dispatching behavior:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@MainActor</span> <span class=\"s-keyword\">class</span> ListViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> result: <span class=\"s-type\">Result</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">Error</span>&gt;?\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">ItemLoader</span>\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        <span class=\"s-keyword\">async</span> {\n            <span class=\"s-keyword\">do</span> {\n                <span class=\"s-keyword\">let</span> items = <span class=\"s-keyword\">try await</span> loader.<span class=\"s-call\">loadItems</span>()\n                result = .<span class=\"s-call\">success</span>(items)\n            } <span class=\"s-keyword\">catch</span> {\n                result = .<span class=\"s-call\">failure</span>(error)\n            }\n        }\n    }\n}</code></pre><p>One thing that’s very important to point out, though, is that all of this only works when we’re using Swift’s new concurrency system. So when using other concurrency patterns, for example completion handlers, then the <code>@MainActor</code> attribute has no effect — meaning that the following code will still cause our <code>result</code> property to be incorrectly assigned on a background queue:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@MainActor class</span> ListViewModel: <span class=\"s-type\">ObservableObject</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        loader.<span class=\"s-call\">loadItems</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n            self</span>?.<span class=\"s-property\">result</span> = result\n        }\n    }\n}</code></pre><p>At first, that might seem like a strange limitation, but it does make sense when considering that actors can only be accessed asynchronously, using the new async/await system. So if we’re operating in a completely synchronous context (which our above completion handler actually is, even if it might be called on a background thread) there’s no way for the system to automatically dispatch that code onto the main actor.</p><h2>Conclusion</h2><p>Over time, once most of our asynchronous code has been migrated to Swift’s new concurrency system, the <code>MainActor</code> is hopefully going to more or less eliminate the need for us to manually dispatch our UI updates on the main queue. Of course, that doesn’t mean that we no longer have to consider threading and other concurrency issues when designing our APIs and our architecture — but at least that very common issue of accidentally performing UI updates on a background queue can, at some point, hopefully become a problem of the past.</p><p>For much more on Swift’s new concurrency system, make sure to listen to my <a href=\"https://www.swiftbysundell.com/podcast/99\">podcast conversation with Doug Gregor from Apple</a>, and stay tuned to Swift by Sundell for many more articles on async/await, actors, and structured concurrency within the coming weeks and months.</p><p>Thanks for reading!</p>",
      "summary": "How the MainActor attribute eliminates the need for us to manually dispatch UI updates on the main queue when using Swift 5.5’s new concurrency system.",
      "date_published": "2021-06-13T14:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/99",
      "url": "https://www.swiftbysundell.com/podcast/99",
      "title": "Podcast: “Structured concurrency”, with special guest Doug Gregor",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell99.mp3\" type=\"audio/mpeg\"/></audio><p>Doug Gregor from Apple joins John to discuss Swift 5.5’s new concurrency features in great detail. How do features like async/await and actors work under the hood, and how were those concepts adapted in order to feel right at home within Swift’s existing ecosystem? That, and much more, on this WWDC21 special episode of the show.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://detailspro.app\">DetailsPro</a>:</strong> A native, fast, and beautiful design tool for iPhone, iPad and Mac, which lets you design, prototype and even build entire SwiftUI-powered UIs super easily. Try it for free at <a href=\"https://detailspro.app\">detailspro.app</a>.</li><li><strong><a href=\"https://www.revenuecat.com\">RevenueCat</a>:</strong> In-app subscriptions made easy. RevenueCat handles the pain points of implementing subscriptions and in-app purchases, so that you can get back to building your app. Learn more at <a href=\"https://www.revenuecat.com\">revenuecat.com</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/dgregor79\">Doug on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://apple.github.io/swift-evolution\">Swift Evolution</a></li><li><a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md\">Async/await</a></li><li><a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift\">Futures and Promises</a></li><li><a href=\"https://www.swiftbysundell.com/discover/combine\">Combine</a></li><li><a href=\"https://developer.apple.com/documentation/swift/task\">Task</a></li><li><a href=\"https://wwdcbysundell.com/2021/using-async-await-with-urlsession\">URLSession’s async/await-powered APIs</a></li><li><a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0300-continuation.md\">Continuations</a></li><li><a href=\"https://wwdcbysundell.com/2021/exploring-new-swiftui-list-apis/#pull-to-refresh\">Using SwiftUI’s refreshable modifier</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/emptyview/task(_:)\">SwiftUI’s task modifier</a></li><li><a href=\"https://wwdcbysundell.com/2021/calling-async-apis-from-synchronous-contexts\">Calling async APIs from a synchronous context</a></li><li><a href=\"https://developer.apple.com/documentation/swift/asyncsequence\">AsyncSequence</a></li><li><a href=\"https://developer.apple.com/wwdc21/10133\">Doug and Dario Rexin’s WWDC21 talk about actors</a></li><li><a href=\"https://www.erlang.org\">Erlang</a></li><li><a href=\"https://doc.akka.io/docs/akka/current/actors.html\">Akka’s implementation of actors</a></li><li><a href=\"https://developer.apple.com/documentation/swift/sendable\">The Sendable protocol</a></li><li><a href=\"https://developer.apple.com/documentation/swift/mainactor\">The MainActor type</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Doug Gregor from Apple joins John to discuss Swift 5.5’s new concurrency features in great detail. How do features like async/await and actors work under the hood, and how were those concepts adapted in order to feel right at home within Swift’s existing ecosystem? That, and much more, on this WWDC21 special episode of the show.",
      "date_published": "2021-06-11T15:00:00.000Z"
    },
    {
      "guid": "swiftbysundell/links/wwdc-by-sundell-and-friends-2021",
      "url": "https://wwdcbysundell.com/",
      "title": "First looks at the new APIs and frameworks announced at WWDC21 on WWDC by Sundell & Friends",
      "content_html": "<p>As I have for the past two years, this year I’m once again sharing my first impressions of many of the new APIs and frameworks that are being introduced at WWDC, over on my dedicated website — <a href=\"https://wwdcbysundell.com\">wwdcbysundell.com</a>. And, just like last year, I’m joined by some of my friends from around the Apple developer community who are providing their own unique takes on the announcements through a series of guest articles and videos.</p><p>So if you’re interested in seeing lots of examples of how the new additions to frameworks like UIKit and SwiftUI can be used, as well as first looks at some of the brand new tools that were announced this year — such as Swift’s new concurrency features, and frameworks like ShazamKit — then head over to <a href=\"https://wwdcbysundell.com\">WWDC by Sundell &amp; Friends</a>.</p><p>I hope that you’re having a great conference week, and I’ll of course continue to share more in-depth articles and podcast episodes about the new tools, frameworks and announcements over the next weeks, months, and years.</p>",
      "summary": "Head over to WWDC by Sundell & Friends to find highly technical coverage of WWDC21 and first looks at some of the key new APIs, tools, and frameworks.",
      "date_published": "2021-06-10T11:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2021",
      "url": "https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2021",
      "title": "A Swift developer’s WWDC dreams - 2021 edition",
      "content_html": "<p>With the start of WWDC21 just around the corner, I’d like to continue the tradition that I <a href=\"https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams\">started in 2019</a>, and share some of my biggest hopes and dreams for this year’s edition of the conference.</p><p>Note that these are really not <em>predictions</em>, nor are they based on any kind of insider information. It’s just me sharing some of my personal Swift-related WWDC dreams with you.</p><h2>Powerful SwiftUI customization</h2><p>I absolutely love <a href=\"https://www.swiftbysundell.com/discover/swiftui\">SwiftUI</a> (so much so that I’m <em>kind of</em> <a href=\"https://github.com/JohnSundell/Plot#components\">porting it to the web</a>), but that doesn’t mean that it’s perfect. In fact, being just shy of two years old at this point, it’s still a very young framework that has yet to become as feature-complete, flexible and powerful as tools like UIKit and AppKit are.</p><p>One of the key improvements that I’d like to see this year — that would unlock a lot of that additional power and flexibility — is for Apple to add proper, fully baked customization APIs to the entire suite of system views that the framework ships with.</p><p>For example, like we took a look at in <a href=\"https://www.swiftbysundell.com/articles/encapsulating-swiftui-view-styles\">“Encapsulating SwiftUI view styles”</a>, the <code>ButtonStyle</code> protocol already enables us to perform very custom, finely grained customization when it comes to how <code>Button</code> views are styled:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ActionButtonStyle: <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        configuration.<span class=\"s-property\">label</span>\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>What makes styles defined using the above protocol so powerful is that they can be applied to an entire view hierarchy at once — making it possible to very neatly separate an app’s styling and theming code from the specific logic that’s contained within each individual view. In fact, if we wanted to, we could even style all of the buttons within an entire SwiftUI-based application simply by doing this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@main struct</span> MyApp: <span class=\"s-type\">App</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">Scene</span> {\n        <span class=\"s-type\">WindowGroup</span> {\n            <span class=\"s-type\">RootView</span>().<span class=\"s-call\">buttonStyle</span>(<span class=\"s-type\">ActionButtonStyle</span>())\n        }\n    }\n}</code></pre><p>However, while SwiftUI already ships with a number of other styling protocols that work the exact same way as <code>ButtonStyle</code>, many of them are currently not available for us third-party developers to implement. Take the <code>NavigationViewStyle</code> protocol, for example. If we take a look at its public definition by command-clicking it in Xcode, all that we’ll see is this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">public protocol</span> NavigationViewStyle {\n}</code></pre><p>The same thing is true for other, similar protocols as well — including <code>ListStyle</code>, <code>MenuButtonStyle</code>, <code>PickerStyle</code>, and so on. So, my wish would be for Apple to open up those protocols so that we’ll be able to write custom styles for more or less <em>any</em> built-in SwiftUI view, not just for a few select ones, like <code>Button</code> and <code>Label</code>. I think that could solve many of the styling-related issues that lots of developers (myself included) have faced when adopting SwiftUI within apps that require more custom-looking UIs.</p><p>For example, the above kind of customization APIs could enable us to style navigation and tab bars, to (finally) be able to remove list cell separators, and to perform other kinds of common tweaks that UIKit and AppKit make super simple, but SwiftUI currently makes close to impossible (without resorting to some form of <code>UIAppearance</code> or subview hacking).</p><p>I think that SwiftUI already has a quite broad coverage when it comes to the <em>types</em> of views that it supports, so (at least from my perspective) it would make a ton of sense for Apple to instead focus on <em>depth</em> this year — to make the views that SwiftUI already offers much more flexible, powerful, and customizable.</p><h2>Async/await all the things!</h2><p>With concurrency being such a strong focus of Swift 5.5 (which I’ll cover in much more detail once I’ve had a chance to use it to write proper production code), I’d love to see Apple update many of the asynchronous APIs that ship as part of their SDKs to take full advantage of features like <code>async/await</code>.</p><p>For example, imagine being able to perform a <code>URLSession</code>-based network call like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> response = <span class=\"s-keyword\">try await</span> <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>.<span class=\"s-call\">dataTask</span>(for: url)</code></pre><p>Or to request push notification permissions like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> center = <span class=\"s-type\">UNUserNotificationCenter</span>.<span class=\"s-call\">current</span>()\n<span class=\"s-keyword\">let</span> isAuthorized = <span class=\"s-keyword\">try await</span> center.<span class=\"s-call\">requestAuthorization</span>()</code></pre><p>While <a href=\"https://www.swiftbysundell.com/discover/combine\">Combine</a> already enables us to perform many kinds of asynchronous tasks in really powerful ways, if Apple were to fully embrace Swift’s new first-class concurrency features, I think that would both serve as great examples for the community to follow, and would make it much easier for us to adopt those features within our own code as well.</p><p>Plus, those new APIs would very likely be purely additive to the existing ones, meaning that (just like when Combine was introduced) we’d be able to migrate to them piece-by-piece, at our own pace.</p><h2>Interactive widgets</h2><p>To say that iOS 14’s <a href=\"https://wwdcbysundell.com/2020/getting-started-with-widgetkit\">introduction of WidgetKit</a> has turned out to be successful is almost an understatement — with the new home screen widgets reaching very widespread adoption, not just among developers and tech enthusiasts, but also within the wider iOS user base (in big part thanks to the incredible work by <a href=\"https://apps.apple.com/us/app/widgetsmith/id1523682319\">Widgetsmith</a> creator David Smith, who I had the true pleasure of <a href=\"https://www.swiftbysundell.com/podcast/91\">talking to on the podcast</a> a while back).</p><p>However, in their current shape, widgets are quite limited in terms of what kinds of user interactions that they can accept — with deep links into the host application being the only real way to implement custom interaction logic. Now, I completely understand <em>why</em> Apple made that decision. After all, like Eliza Block explained when she was a <a href=\"https://www.swiftbysundell.com/podcast/76\">guest on the podcast last year</a>, a widget’s UI isn’t actually constantly running on the home screen, but is rather rendered by the system based on serialized snapshots that are stored on disk, mostly for performance and energy efficiency reasons.</p><p>So if the system is essentially rendering all widgets as completely static view hierarchies that are computed up-front (by a widget’s backing <code>TimelineProvider</code>), how could Apple enable us to write custom interaction code within that context, without fundamentally changing the way widgets work?</p><p>One idea that comes to mind is that some form of event-based message-passing system could be introduced, that would enable a given widget’s timeline entry views to trigger custom events, for example using something like a built-in <code>EventButton</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleWidgetEntryView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> entry: <span class=\"s-type\">ArticleEntry</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>, spacing: <span class=\"s-number\">5</span>) {\n            <span class=\"s-type\">Text</span>(entry.<span class=\"s-property\">article</span>.<span class=\"s-property\">title</span>)\n                .<span class=\"s-call\">bold</span>()\n            <span class=\"s-type\">Text</span>(entry.<span class=\"s-property\">article</span>.<span class=\"s-property\">description</span>)\n                .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">secondary</span>)\n                .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">footnote</span>)\n            <span class=\"s-type\">EventButton</span>(\n                systemImage: <span class=\"s-string\">\"heart.fill\"</span>,\n                event: <span class=\"s-type\">ArticleWidget</span>.<span class=\"s-type\">Event</span>.<span class=\"s-property\">toggleFavorite</span>\n            )\n        }\n        .<span class=\"s-call\">padding</span>()\n    }\n}</code></pre><p>Since the above doesn’t involve executing any arbitrary view-level code in response to user interactions, it would still let the system remain in complete control over the rendering and lifecycle of all widget UIs.</p><p>Because WidgetKit is Swift(UI)-only, the above <code>Event</code> type could then very likely be referenced by both the main <code>Widget</code> definition, and its <code>TimelineProvider</code>, in a completely type-safe way — rather than having to pass either raw strings or <code>userInfo</code>-style dictionaries around.</p><p>For example, perhaps the <code>TimelineProvider</code> protocol (or a <a href=\"https://www.swiftbysundell.com/articles/specializing-protocols-in-swift\">specialized version</a> of it) could gain a new method that would be passed any <code>Event</code> that was triggered (as well as the entry that triggered it), which in turn would let us run completely custom code in response to that, while still enabling the system to keep using its snapshot-based rendering strategy.</p><h2>Rock-solid tooling</h2><p>Although the overall quality of Swift’s tooling and the way it’s integrated into Xcode has certainly improved since when the language was first introduced, it remains one of the most significant drawbacks of Swift as a whole. It’s still, in 2021, very common for autocomplete to completely stop working, for syntax highlighting to disappear, and for obscure error messages to be shown when a compilation failure occurred — even within relatively simple projects.</p><p>I realize that these are not easy problems to solve, especially given Swift’s overall complexity and very rapid evolution, but if I could just pick a single item from this list of dreams, then it’d be this one. There’s just so many things to like about Swift, UIKit, SwiftUI, and the rest of Apple’s frameworks and SDKs, and for all of its flaws, I think that Xcode is actually a quite fantastic development environment overall — I just <em>really wish</em> that the basic editing experience would get elevated to the very high level of quality that I’ve come to expect from Apple products.</p><p>That’s not to say that <em>all</em> of Swift’s tooling is flawed. Take the Swift Package Manager for example — overall, it’s <em>by far</em> the most stable and easy-to-use dependency management system that I’ve ever used (and I don’t mean that as an insult to any of the other package managers out there). Basically, when using SwiftPM, <a href=\"https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager\">dependency management</a> has mostly become a solved problem, at least for me and the teams that I work with. It’s fast, reliable, and powerful. The same thing can now also be said for Xcode’s new build system, and many other parts of the overall experience of developing apps for Apple’s platforms.</p><p>So, what I’m hoping for is for some of the rough edges to be smoothened out, and I’m sure that we’ll get there one day. Let’s see if Xcode 13’s release day will be that day.</p><h2>Remaining 2020 dreams</h2><p>Finally, I’d also still love to see some of my remaining <a href=\"https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020\">2020 dreams</a> eventually become reality.</p><p><strong><a href=\"https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020/#xcode-on-ipad\">Xcode on iPad</a></strong> is something that I’ve long been wishing for. I know that not <em>everyone</em> wants to write code on an iPad, but I really do, especially when traveling or when working outside. That doesn’t mean that I’d stop using my M1 Mac mini if an iPad version of Xcode would be released next week — it would just mean that I’d have an additional device that I, and others, could build apps and libraries on.</p><p>Swift Playgrounds is an amazing tool for learning, prototyping and experimentation — but it’s not an IDE for building proper apps and Swift packages, and it was never intended to be. I think at this point in its lifecycle, the iPad should become a computing platform that’s not just capable of <em>running apps</em> — it should also enable us to <em>build and deploy them</em>.</p><p><strong><a href=\"https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020/#end-to-end-swift\">End-to-end Swift</a></strong>, or some form of Swift-based cloud functions, was also one of my 2020 dreams. So many apps need to run server-side logic, but not all of them <em>really</em> need a completely custom server. Sure, there are lots of third-party tools available that lets us deploy individual pieces of logic, such as <a href=\"https://workers.cloudflare.com\">Cloudflare Workers</a> (which is what powers this site’s search feature), but it would be incredible to see a completely integrated, Swift-based server-less system from Apple that would let us accomplish similar things.</p><p>I’d also still very much like to be able to <strong><a href=\"https://www.swiftbysundell.com/articles/a-swift-developers-wwdc-dreams-2020/#swift-package-manager-for-apps-and-playgrounds\">use the Swift Package Manager to define entire app projects</a></strong>, rather than just libraries and command line tools. Like I mentioned earlier, SwiftPM is one of my favorite parts of Swift’s overall toolchain, so I’d be delighted to see it expand to cover even more use cases this year.</p><h2>Conclusion</h2><p>Those are my biggest Swift-related dreams for WWDC21. What do you think? Do you share some of my dreams, or are there any other Swift-related announcements that you’d like to see next week? Let me know via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>If you enjoyed this article, then make sure to check out <a href=\"https://wwdcbysundell.com\">WWDC by Sundell &amp; Friends</a>, on which I and some of my friends will cover WWDC21 in great detail all throughout the week of the conference.</p><p>Thanks for reading!</p>",
      "summary": "With the start of WWDC21 just around the corner, I’d like to share some of my biggest hopes and dreams for this year’s edition of the conference.",
      "date_published": "2021-06-03T19:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/98",
      "url": "https://www.swiftbysundell.com/podcast/98",
      "title": "Podcast: “An entire spectrum of apps”, with special guest Sean Allen",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell98.mp3\" type=\"audio/mpeg\"/></audio><p>Sean Allen returns to the show to talk about using the MVVM design pattern within SwiftUI-based apps, building a course around MapKit and CloudKit, how to approach all of the new material that WWDC has to offer, and what goes into making a really great developer portfolio.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://nordvpn.com/sundell\">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on, and unlock your video streaming services. Get a massive discount on their two-year plan, and an extra free month, at <a href=\"https://nordvpn.com/sundell\">nordvpn.com/sundell</a>.</li><li><strong><a href=\"https://macstadium.com/sundell\">MacStadium</a>:</strong> The leading provider of cloud solutions built on real Mac hardware. Get started at <a href=\"https://macstadium.com/sundell\">macstadium.com/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/seanallen_dev\">Sean on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://seanallen.teachable.com/p/dub-dub-grub-swiftui-mapkit-cloudkit\">Sean’s new course: Dub Dub Grub</a></li><li><a href=\"https://www.youtube.com/seanallen\">Sean’s YouTube channel</a></li><li><a href=\"https://developer.apple.com/icloud/cloudkit\">CloudKit</a></li><li><a href=\"https://dribbble.com\">Dribbble</a></li><li><a href=\"https://www.behance.net\">Behance</a></li><li><a href=\"https://www.youtube.com/watch?v=FwGMU_Grnf8\">Sean’s MVVM video</a></li><li><a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift/\">Different flavors of view models in Swift</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-and-modifying-the-environment\">The SwiftUI environment API</a></li><li><a href=\"https://stackoverflow.com/questions/59491675/swiftui-how-to-pass-environmentobject-into-view-model\">Stack Overflow answer about SwiftUI and view models</a></li><li><a href=\"https://www.swiftbysundell.com/tags/the-factory-pattern\">The factory pattern</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/91\">The recent episode with David Smith</a></li><li><a href=\"https://wwdcbysundell.com\">WWDC by Sundell &amp; Friends</a></li><li><a href=\"https://www.youtube.com/watch?v=Fk01P4WkIVw\">Sean’s most recent portfolio review video</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Sean Allen returns to the show to talk about using the MVVM design pattern within SwiftUI-based apps, building a course around MapKit and CloudKit, how to approach all of the new material that WWDC has to offer, and what goes into making a really great developer portfolio.",
      "date_published": "2021-05-31T16:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/avoiding-problematic-enum-cases-in-swift",
      "url": "https://www.swiftbysundell.com/articles/avoiding-problematic-enum-cases-in-swift",
      "title": "Avoiding problematic cases when using Swift enums",
      "content_html": "<p>Swift’s implementation of enums is, without a doubt, one of the most beloved and powerful features that the language has to offer. The fact that Swift enums go way beyond simple enumerations of integer-based constants, and support things like associated values and sophisticated pattern matching, makes them a great candidate for solving many different kinds of problems.</p><p>However, there are certain kinds of enum cases that can arguably be good to avoid, as they could lead us to some tricky situations, or make our code feel less “idiomatic” that what we intended. Let’s take a look at a few such cases and how they could be refactored using some of Swift’s other language features.</p><h2>Representing the lack of a value</h2><p>As an example, let’s say that we’re working on a podcast app, and that we’ve implemented the various categories that our app supports using an enum. That enum currently contains cases for each category, as well as two somewhat <em>special</em> cases that’s used for podcasts that don’t have a category at all (<code>none</code>), as well as a category that can be used to reference all categories at once (<code>all</code>):</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span> {\n    <span class=\"s-keyword\">enum</span> Category: <span class=\"s-type\">String</span>, <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">case</span> none\n        <span class=\"s-keyword\">case</span> all\n        <span class=\"s-keyword\">case</span> entertainment\n        <span class=\"s-keyword\">case</span> technology\n        <span class=\"s-keyword\">case</span> news\n        ...\n    }\n}</code></pre><p>Then, when implementing features such as filtering, we can use the above enum to perform pattern matching against the <code>Category</code> value that the user selected within the UI (which is encapsulated within a <code>Filter</code> model):</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span> {\n    <span class=\"s-keyword\">func</span> matches(filter: <span class=\"s-type\">Filter</span>) -&gt; <span class=\"s-type\">Bool</span> {\n        <span class=\"s-keyword\">switch</span> filter.<span class=\"s-property\">category</span> {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">all</span>, category:\n            <span class=\"s-keyword\">return</span> name.<span class=\"s-call\">contains</span>(filter.<span class=\"s-property\">string</span>)\n        <span class=\"s-keyword\">default</span>:\n            <span class=\"s-keyword\">return false</span>\n        }\n    }\n}</code></pre><p>At first glance, the above two pieces of code might look perfectly fine. But, if we think about it, the fact that we’ve currently added a specific <code>none</code> case for representing the lack of a category is arguably a bit strange, given that Swift does have a built-in language feature that’s tailor-made for that purpose — <em>optionals</em>.</p><p>So, if we instead were to turn our <code>Podcast</code> model’s <code>category</code> property into an optional, then we’d get support for representing missing categories completely for free — plus we could now leverage all of the features that Swift optionals support (such as <code>if let</code> statements) when dealing with such missing values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Podcast {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> category: <span class=\"s-type\">Category</span>?\n    ...\n}</code></pre><p>Something that’s really interesting about the above change is that any exhaustive <code>switch</code> statements that we were previously using on <code>Podcast.Category</code> values will still keep working just as they did before — since <a href=\"https://www.swiftbysundell.com/basics/optionals\">it turns out</a> that the <code>Optional</code> type itself is also, in fact, an enum that uses a <code>none</code> case to represent the lack of a value — meaning that code like the following function can remain completely unchanged (apart from modifying its argument to be an optional):</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> title(forCategory category: <span class=\"s-type\">Podcast</span>.<span class=\"s-type\">Category</span>?) -&gt; <span class=\"s-type\">String</span> {\n    <span class=\"s-keyword\">switch</span> category {\n    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">none</span>:\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Uncategorized\"</span>\n    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">all</span>:\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"All\"</span>\n    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">entertainment</span>:\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Entertainment\"</span>\n    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">technology</span>:\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Technology\"</span>\n    <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">news</span>:\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"News\"</span>\n    ...\n    }\n}</code></pre><p>The above works thanks to a bit of Swift compiler magic that automatically flattens optionals when they’re used in pattern matching contexts (such as <code>switch</code> statements), which lets us both address cases within the <code>Optional</code> type itself, as well as cases defined within our own <code>Podcast.Category</code> enum, all within the same statement.</p><p class=\"info\">If we wanted to, we could’ve also used <code>case nil</code> instead of <code>case .none</code>, since those are functionally identical in the above type of situation.</p><h2>Domain-specific enums</h2><p>Next, let’s turn our attention to our <code>Podcast.Category</code> enum’s <code>all</code> case, which is also a bit strange if we think about it. After all, a podcast can’t belong to all categories simultaneously, so that <code>all</code> case really only makes sense within the context of filtering.</p><p>So, rather than including that case within our main <code>Category</code> enum, let’s instead create a dedicated type that’s specific to the domain of filtering. That way, we can achieve a quite neat separation of concerns, and since we’re using nested types, we can have our new enum use the same <code>Category</code> name, only this time it’ll be nested within our <code>Filter</code> model — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Filter</span> {\n    <span class=\"s-keyword\">enum</span> Category {\n        <span class=\"s-keyword\">case</span> any\n        <span class=\"s-keyword\">case</span> uncategorized\n        <span class=\"s-keyword\">case</span> specific(<span class=\"s-type\">Podcast</span>.<span class=\"s-type\">Category</span>)\n    }\n}</code></pre><p class=\"info\">Worth noting is that we <em>could’ve</em> chosen to use the optional approach here as well, with <code>nil</code> representing either <code>any</code> or <code>uncategorized</code>, but since there are two potential candidates in this case, we’re arguably making our intent much more clear by using dedicated cases here.</p><p>What’s really nice about the above approach is that we can now implement our entire filtering logic using Swift’s <a href=\"https://www.swiftbysundell.com/articles/pattern-matching-in-swift\">pattern matching capabilities</a> — by switching on the filtered category and by then using <code>where</code> clauses to attach additional logic to each case:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span> {\n    <span class=\"s-keyword\">func</span> matches(filter: <span class=\"s-type\">Filter</span>) -&gt; <span class=\"s-type\">Bool</span> {\n        <span class=\"s-keyword\">switch</span> filter.<span class=\"s-property\">category</span> {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">any</span> <span class=\"s-keyword\">where</span> category != <span class=\"s-keyword\">nil</span>,\n             .<span class=\"s-dotAccess\">uncategorized</span> <span class=\"s-keyword\">where</span> category == <span class=\"s-keyword\">nil</span>,\n             .<span class=\"s-call\">specific</span>(category):\n            <span class=\"s-keyword\">return</span> name.<span class=\"s-call\">contains</span>(filter.<span class=\"s-property\">string</span>)\n        <span class=\"s-keyword\">default</span>:\n            <span class=\"s-keyword\">return false</span>\n        }\n    }\n}</code></pre><p>With all of the above changes in place, we can now go ahead and remove the <code>none</code> and <code>all</code> cases from our main <code>Podcast.Category</code> enum — leaving us with a much more straightforward list of each of the categories that our app supports:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span> {\n    <span class=\"s-keyword\">enum</span> Category: <span class=\"s-type\">String</span>, <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">case</span> entertainment\n        <span class=\"s-keyword\">case</span> technology\n        <span class=\"s-keyword\">case</span> news\n        ...\n    }\n}</code></pre><h2>Custom cases and custom types</h2><p>When it comes to enums like <code>Podcast.Category</code>, it’s incredibly common to (at some point) introduce some kind of <code>custom</code> case that can be used to handle one-off cases, or to provide forward compatibility by gracefully handling cases that might be added server-side in the future.</p><p>One way to implement that would be to use a case that has an associated value — in our case a <code>String</code> representing the raw value of a custom category, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span> {\n    <span class=\"s-keyword\">enum</span> Category: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">case</span> all\n        <span class=\"s-keyword\">case</span> entertainment\n        <span class=\"s-keyword\">case</span> technology\n        <span class=\"s-keyword\">case</span> news\n        ...\n        <span class=\"s-keyword\">case</span> custom(<span class=\"s-type\">String</span>)\n    }\n}</code></pre><p>Unfortunately, while associated values are incredibly useful in other contexts, this is not really one of them. First of all, by adding such a case, our enum can no longer be <code>String</code>-backed, meaning that we’ll now have to write custom encoding and decoding code, as well as logic for converting instances to and from raw strings.</p><p>So let’s explore another approach instead, by converting our <code>Category</code> enum into a <code>RawRepresentable</code> struct, which once again lets us leverage Swift’s built-in logic for encoding, decoding, and handling string conversions for such types:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span> {\n    <span class=\"s-keyword\">struct</span> Category: <span class=\"s-type\">RawRepresentable</span>, <span class=\"s-type\">Codable</span>, <span class=\"s-type\">Hashable</span> {\n        <span class=\"s-keyword\">var</span> rawValue: <span class=\"s-type\">String</span>\n    }\n}</code></pre><p>Since we’re now free to create <code>Category</code> instances from any custom string that we want, we can easily support both custom and future categories without requiring any additional code on our part. However, to make sure that our code remains backward compatible, and to make it easy to refer to any of our built-in, currently known categories — let’s also extend our new type with static APIs that’ll achieve all of those things:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span>.<span class=\"s-type\">Category</span> {\n    <span class=\"s-keyword\">static var</span> entertainment: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span>(rawValue: <span class=\"s-string\">\"entertainment\"</span>)\n    }\n\n    <span class=\"s-keyword\">static var</span> technology: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span>(rawValue: <span class=\"s-string\">\"technology\"</span>)\n    }\n\n    <span class=\"s-keyword\">static var</span> news: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span>(rawValue: <span class=\"s-string\">\"news\"</span>)\n    }\n    \n    ...\n\n    <span class=\"s-keyword\">static func</span> custom(<span class=\"s-keyword\">_</span> id: <span class=\"s-type\">String</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span>(rawValue: id)\n    }\n}</code></pre><p>Although the above change did require <em>some</em> amount of extra code to be added, we’ve now ended up with a much more flexible setup that’s almost entirely backward compatible. In fact, the only updates that we need to make are to code that performs exhaustive switches on <code>Category</code> values.</p><p>For example, the <code>title</code> function that we took a look at earlier previously switched on such a value to return a title matching a given category. Since we can no longer get an exhaustive list of each <code>Category</code> value at compile-time, we’d now have to use a different approach to compute those titles. In this particular case we could, for example, see this as an excellent opportunity to move those strings to a <code>Localizable.strings</code> file, and then resolve our titles like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> title(forCategory category: <span class=\"s-type\">Podcast</span>.<span class=\"s-type\">Category</span>?) -&gt; <span class=\"s-type\">String</span> {\n    <span class=\"s-keyword\">guard let</span> id = category?.<span class=\"s-property\">rawValue</span> <span class=\"s-keyword\">else</span> {\n        <span class=\"s-keyword\">return</span> <span class=\"s-type\">NSLocalizedString</span>(<span class=\"s-string\">\"category-uncategorized\"</span>, comment: <span class=\"s-string\">\"\"</span>)\n    }\n\n    <span class=\"s-keyword\">let</span> key = <span class=\"s-string\">\"category-</span>\\(id)<span class=\"s-string\">\"</span>\n    <span class=\"s-keyword\">let</span> string = <span class=\"s-type\">NSLocalizedString</span>(key, comment: <span class=\"s-string\">\"\"</span>)\n\n    <span class=\"s-comment\">// Handling unknown cases by returning a capitalized version\n    // of their key as a fallback title:</span>\n    <span class=\"s-keyword\">guard</span> string != key <span class=\"s-keyword\">else</span> {\n        <span class=\"s-keyword\">return</span> key.<span class=\"s-property\">capitalized</span>\n    }\n\n    <span class=\"s-keyword\">return</span> string\n}</code></pre><p class=\"info\">Another option would be to resolve our localized titles within the <code>Category</code> type itself, and to perhaps also add an optional <code>title</code> property which would enable our server to send pre-localized titles for custom categories that our app doesn’t yet natively support.</p><h2>Auto-named static properties</h2><p>As a quick bonus tip, one downside of the above struct-based approach is that we now have to manually define the underlying string raw values for each of our static properties, but that’s something that we could solve using Swift’s <code>#function</code> keyword. Since that keyword will be automatically replaced by the name of the function (or, in our case, property) that its encapsulating function is being called from, that’ll give us the same automatic raw value mapping as when using an enum:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span>.<span class=\"s-type\">Category</span> {\n    <span class=\"s-keyword\">static func</span> autoNamed(<span class=\"s-keyword\">_</span> rawValue: <span class=\"s-type\">StaticString</span> = <span class=\"s-keyword\">#function</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span>(rawValue: <span class=\"s-string\">\"</span>\\(rawValue)<span class=\"s-string\">\"</span>)\n    }\n}</code></pre><p>With the above utility in place, we can now simply call <code>autoNamed()</code> within each of our built-in category APIs, and Swift will automatically fill in those raw values for us:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Podcast</span>.<span class=\"s-type\">Category</span> {\n    <span class=\"s-keyword\">static var</span> entertainment: <span class=\"s-type\">Self</span> { <span class=\"s-call\">autoNamed</span>() }\n    <span class=\"s-keyword\">static var</span> technology: <span class=\"s-type\">Self</span> { <span class=\"s-call\">autoNamed</span>() }\n    <span class=\"s-keyword\">static var</span> news: <span class=\"s-type\">Self</span> { <span class=\"s-call\">autoNamed</span>() }\n    ...\n\n    <span class=\"s-keyword\">static func</span> custom(<span class=\"s-keyword\">_</span> id: <span class=\"s-type\">String</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span>(rawValue: id)\n    }\n}</code></pre><p>Worth noting, though, is that we have to be a bit careful not to rename any of the above static properties when using that <code>#function</code>-based technique, since doing so will also change the underlying raw value for that property’s <code>Category</code>. However, that’s also the case when using enums, and on the flip side, we’re now also preventing typos and other mistakes that can happen when defining each raw string manually.</p><h2>Conclusion</h2><p>Swift enums are awesome (in fact, I’ve written <a href=\"https://www.swiftbysundell.com/tags/enums\">over 15 articles</a> on that topic alone), but there are certain situations in which another language mechanism might be a better choice for what we’re looking to build, and it’s always possible that we might need to switch between several different mechanisms and approaches as our project grows and evolves.</p><p>Hopefully, this article has given you a few ideas on how those kinds of situations and problems could be solved, and if you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or email.</p><p>Thanks for reading!</p>",
      "summary": "Swift’s enums are awesome, but they’re not always the best choice for modeling a given piece of data. Let’s explore why that is, and what other tools that can be good to keep in mind in order to avoid certain problematic enum cases.",
      "date_published": "2021-05-27T14:20:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/97",
      "url": "https://www.swiftbysundell.com/podcast/97",
      "title": "Podcast: “Anything can happen during WWDC”, with special guest Ish ShaBazz",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell97.mp3\" type=\"audio/mpeg\"/></audio><p>Ish ShaBazz returns to the show for a special pre-WWDC episode about what new APIs and developer tools that Apple might announce at this year’s edition of the conference. What’s in store for Swift and SwiftPM, how might UIKit and SwiftUI continue to evolve, and will this be the year when we’ll finally see Apple’s new AR/VR platform?</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Incredibly useful bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to start your free trial.</li><li><strong><a href=\"https://macstadium.com/sundell\">MacStadium</a>:</strong> The leading provider of cloud solutions built on real Mac hardware. Get started at <a href=\"https://macstadium.com/sundell\">macstadium.com/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/ishabazz\">Ish on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://capsicum.app\">Capsicum</a></li><li><a href=\"https://9to5mac.com/guides/stacktrace\">Stacktrace</a></li><li><a href=\"https://github.com/apple/swift/blob/main/CHANGELOG.md#swift-55\">The official changelog for Swift 5.5</a></li><li><a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0306-actors.md\">Actors</a></li><li><a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md\">Async/await</a></li><li><a href=\"https://www.swiftbysundell.com/tips/chained-implicit-member-expressions\">Chained implicit member expressions</a></li><li><a href=\"https://www.swiftbysundell.com/basics/grand-central-dispatch\">Grand Central Dispatch</a></li><li><a href=\"https://developer.apple.com/documentation/foundation/operationqueue\">OperationQueue</a></li><li><a href=\"https://www.swiftbysundell.com/discover/combine\">Combine</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/texteditor\">TextEditor</a></li><li><a href=\"https://wwdcbysundell.com/2020/building-entire-apps-with-swiftui\">Using the SwiftUI app lifecycle</a></li><li><a href=\"https://developer.apple.com/widgets/\">WidgetKit</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">SwiftUI’s state management system</a></li><li><a href=\"https://apps.apple.com/us/app/widgetsmith/id1523682319\">Widgetsmith</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/nshostingview\">NSHostingView</a></li><li><a href=\"https://developer.apple.com/augmented-reality/arkit\">ARKit</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Ish ShaBazz returns to the show for a special pre-WWDC episode about what new APIs and developer tools that Apple might announce at this year’s edition of the conference. What’s in store for Swift and SwiftPM, how might UIKit and SwiftUI continue to evolve, and will this be the year when we’ll finally see Apple’s new AR/VR platform?",
      "date_published": "2021-05-21T17:20:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/avoiding-swiftui-value-recomputation",
      "url": "https://www.swiftbysundell.com/articles/avoiding-swiftui-value-recomputation",
      "title": "Avoiding having to recompute values within SwiftUI views",
      "content_html": "<p>In general, using computed properties can be a great way to model view-specific data that we want to create on-demand, when need — especially within SwiftUI views, since each such view already uses a computed property (<code>body</code>) to implement its actual UI.</p><p>For example, here we’re using two computed properties to determine what title and button text that a <code>UserSessionView</code> should render based on the app’s current <code>LoginState</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserSessionView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> buttonAction: () -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">@Environment</span>(\\.<span class=\"s-property\">loginState</span>) <span class=\"s-keyword\">private var</span> state\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">Text</span>(title)\n                .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">headline</span>)\n                .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            <span class=\"s-type\">Button</span>(buttonText, action: buttonAction)\n                .<span class=\"s-call\">padding</span>()\n                .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">white</span>)\n                .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n        }\n        .<span class=\"s-call\">padding</span>()\n        .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n        .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">15</span>)\n    }\n\n    <span class=\"s-keyword\">private var</span> title: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">switch</span> state {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loggedIn</span>(<span class=\"s-keyword\">let</span> user):\n            <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Welcome back,</span> \\(user.<span class=\"s-property\">name</span>)<span class=\"s-string\">!\"</span>\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loggedOut</span>:\n            <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Not logged in\"</span>\n        }\n    }\n\n    <span class=\"s-keyword\">private var</span> buttonText: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">switch</span> state {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loggedIn</span>:\n            <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Log out\"</span>\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loggedOut</span>:\n            <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"Log in\"</span>\n        }\n    }\n}</code></pre><p class=\"info\">To learn more about the <code>Environment</code> property wrapper that’s being used above, check out my <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">guide to SwiftUI’s state management system</a>.</p><p>Implementing a SwiftUI view like that, using multiple computed properties, can often be a great approach — as it lets us keep our <code>body</code> implementations as simple as possible, and since it gives us a clear overview of how we’re computing the different content that a given view will render.</p><h2>Recomputed properties</h2><p>But, we also have to keep in mind that computed properties are just that — computed — there’s no form of caching or other kind of in-memory storage involved, meaning that each such values will always be recomputed each time that it’s being accessed.</p><p>That’s not an issue in our first example, because each of our properties can be quickly computed with constant (or <code>O(1)</code>) <a href=\"https://www.swiftbysundell.com/basics/time-complexity\">time complexity</a>. However, let’s now take a look at another example, which is quite different in terms of performance characteristics, since we’re now computing a property by sorting a collection:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RemindersList: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Reminder</span>.<span class=\"s-type\">ID</span>: <span class=\"s-type\">Reminder</span>]\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span>(sortedItems) { reminder <span class=\"s-keyword\">in</span>\n            ...\n        }\n    }\n\n    <span class=\"s-keyword\">private var</span> sortedItems: [<span class=\"s-type\">Reminder</span>] {\n        items.<span class=\"s-property\">values</span>.<span class=\"s-call\">sorted</span>(by: {\n            $0.<span class=\"s-property\">dueDate</span> &lt; $1.<span class=\"s-property\">dueDate</span>\n        })\n    }\n}</code></pre><p>On one hand, the above implementation could become quite problematic if the passed <code>items</code> dictionary ends up containing a very large amount of items, since that collection will be re-sorted every single time that we’ll access the <code>sortedItems</code> property. But, on the other hand, it’s a private property that’s only accessed from within our view’s <code>body</code>, and since our view doesn’t have any kind of mutable state, it’s not very likely that our property will actually be accessed that often.</p><p>However, that could quickly change if we were to add any kind of local state to our view — for example to enable the user to add a new <code>Reminder</code> using an inline <code>TextField</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RemindersList: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Reminder</span>.<span class=\"s-type\">ID</span>: <span class=\"s-type\">Reminder</span>]\n    <span class=\"s-keyword\">var</span> newItemHandler: (<span class=\"s-type\">Reminder</span>) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">@State private var</span> newItemName = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">List</span>(sortedItems) { reminder <span class=\"s-keyword\">in</span>\n                ...\n            }\n            <span class=\"s-type\">HStack</span> {\n                <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Add a new reminder\"</span>, text: <span class=\"s-property\">$newItemName</span>)\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Add\"</span>) {\n                    <span class=\"s-call\">newItemHandler</span>(<span class=\"s-type\">Reminder</span>(name: newItemName))\n                }\n                .<span class=\"s-call\">disabled</span>(newItemName.<span class=\"s-property\">isEmpty</span>)\n            }\n            .<span class=\"s-call\">padding</span>()\n        }\n    }\n\n    <span class=\"s-keyword\">private var</span> sortedItems: [<span class=\"s-type\">Reminder</span>] {\n        items.<span class=\"s-property\">values</span>.<span class=\"s-call\">sorted</span>(by: {\n            $0.<span class=\"s-property\">dueDate</span> &lt; $1.<span class=\"s-property\">dueDate</span>\n        })\n    }\n}</code></pre><p>Now, every time that the user types a new character into the text field, our <code>sortedItems</code> property will be called and our <code>items</code> dictionary will be re-sorted. While that might not <em>initially</em> cause any obvious dips in performance, it’s a very inefficient implementation, and it’s very likely to cause problems at one point or another, especially for users with a large amount of reminders.</p><p>It’s important to remember that, although SwiftUI does use a type-based diffing algorithm to determine what underlying views to redraw for each state change, and does what it can to ensure that our UI remains performant, it’s not magic — if we write highly inefficient code, there’s not much that SwiftUI can do to fix that.</p><h2>Going back to the source</h2><p>So how can we fix this issue? One way would be to go back to the root source of our <code>items</code> data and update it to perform the necessary sorting right up front. Doing that has two main benefits — one, it lets us perform that operation once, instead of during every single view update, and two, it moves what is essentially a model-level operation into our actual model layer. Big win! Here’s what that could look like if we’re using <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a> to load our items through some form of <a href=\"https://www.swiftbysundell.com/articles/model-controllers-in-swift\">model controller</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> loadItems() -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">Error</span>&gt; {\n    controller\n        .<span class=\"s-call\">loadReminders</span>()\n        .<span class=\"s-call\">map</span> { items <span class=\"s-keyword\">in</span>\n            items.<span class=\"s-property\">values</span>.<span class=\"s-call\">sorted</span>(by: {\n                $0.<span class=\"s-property\">dueDate</span> &lt; $1.<span class=\"s-property\">dueDate</span>\n            })\n        }\n        ...\n        .<span class=\"s-call\">eraseToAnyPublisher</span>()\n}</code></pre><p>With the above change in place, we can now simply make our <code>RemindersList</code> view accept a pre-sorted array of reminders which we can just render as-is:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RemindersList: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Reminder</span>]\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">List</span>(items) { reminder <span class=\"s-keyword\">in</span>\n                ...\n            }\n            ...\n        }\n    }\n}</code></pre><p>However, while the above approach is certainly preferable in many cases, there might be good reasons why we were modeling our core model collection as a dictionary, rather than using an array, and changing that might not be so simple, or even feasible at all. So let’s also explore a few other options as well.</p><h2>Initialization logic</h2><p>One way that we could solve our problem at the view level itself is by still having our <code>RemindersList</code> view accept a dictionary, just like before, but to instead perform our sorting within our view’s initializer, rather than using a computed property — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RemindersList: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Reminder</span>]\n    <span class=\"s-keyword\">var</span> newItemHandler: (<span class=\"s-type\">Reminder</span>) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">init</span>(items: [<span class=\"s-type\">Reminder</span>.<span class=\"s-type\">ID</span>: <span class=\"s-type\">Reminder</span>],\n         newItemHandler: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Reminder</span>) -&gt; <span class=\"s-type\">Void</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">items</span> = items.<span class=\"s-property\">values</span>.<span class=\"s-call\">sorted</span>(by: {\n            $0.<span class=\"s-property\">dueDate</span> &lt; $1.<span class=\"s-property\">dueDate</span>\n        })\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">newItemHandler</span> = newItemHandler\n    }\n\n    <span class=\"s-keyword\">@State private var</span> newItemName = <span class=\"s-string\">\"\"</span>\n\n    ...\n}</code></pre><p>With the above change in place, we’re now only sorting our collection once per <code>RemindersList</code> instance, rather than after every key stroke, without actually having to change the way our view is created or how our app’s data is managed. So while my general recommendation is to <a href=\"https://www.swiftbysundell.com/articles/initializers-in-swift\">keep initializers focused on simple setup work</a>, rather than performing data mutations, that’s a tradeoff that we might be willing to make in this case.</p><p>Worth keeping in mind, though, is that if the parent of our <code>RemindersList</code> view does update (or more specifically, if that parent’s <code>body</code> property gets re-evaluated), then a new instance of our view is likely going to be created, meaning that we’ll once again perform our <code>item</code> sorting operation.</p><p>Basically, when writing code within SwiftUI views, it’s close to impossible to gain complete control over when and how that code will be executed. After all, a core part of the design of a declarative UI framework like SwiftUI is that the framework takes care of orchestrating all of our UI updates for us.</p><p>So if we wanted to improve our control over the lifecycle of our actual model logic, then a better approach will likely be to move that logic out from our view implementations and into objects that we have complete control over.</p><h2>Dedicated model logic</h2><p>One way to do that would be to use something like a <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift\">view model</a> to encapsulate the logic associated with handling our <code>items</code> array. If we then make that view model an <code>ObservableObject</code>, then we’ll be able to easily observe it and connect to it within our SwiftUI views:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> RemindersListViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> items: [<span class=\"s-type\">Reminder</span>]\n\n    <span class=\"s-keyword\">init</span>(items: [<span class=\"s-type\">Reminder</span>.<span class=\"s-type\">ID</span>: <span class=\"s-type\">Reminder</span>]) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">items</span> = items.<span class=\"s-property\">values</span>.<span class=\"s-call\">sorted</span>(by: {\n            $0.<span class=\"s-property\">dueDate</span> &lt; $1.<span class=\"s-property\">dueDate</span>\n        })\n    }\n\n    <span class=\"s-keyword\">func</span> addItem(named name: <span class=\"s-type\">String</span>) {\n        ...\n    }\n}</code></pre><p>With the above in place, we can now simplify our view quite heavily, and we’re also free to choose how we want to manage the above <code>RemindersListViewModel</code> ourselves, without having to take view updates and other SwiftUI implementation details into account:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RemindersList: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">RemindersListViewModel</span>\n    <span class=\"s-keyword\">@State private var</span> newItemName = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">List</span>(viewModel.<span class=\"s-property\">items</span>) { reminder <span class=\"s-keyword\">in</span>\n                ...\n            }\n            <span class=\"s-type\">HStack</span> {\n                <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Add a new reminder\"</span>, text: <span class=\"s-property\">$newItemName</span>)\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Add\"</span>) {\n                    viewModel.<span class=\"s-call\">addItem</span>(named: newItemName)\n                }\n                .<span class=\"s-call\">disabled</span>(newItemName.<span class=\"s-property\">isEmpty</span>)\n            }\n            .<span class=\"s-call\">padding</span>()\n        }\n    }\n}</code></pre><p>Very nice! That of course doesn’t mean that every single view within our app now needs to have a view model. It just so happens that in this particular case, a view model turned out to be a quite nice solution to our problem, since it enabled us to move our view-related model logic out from our view hierarchy itself (which also heavily improves that code’s testability).</p><h2>Conclusion</h2><p>Recomputing some of our view-related values every time that a SwiftUI view updates is typically not an issue. After all, that’s the way that each view’s <code>body</code> property works, and as long as those computations can happen quickly (and ideally, with constant time complexity) then we’re not very likely to run into any kind of major performance issues.</p><p>However, that’s not always the case, and sometimes we might need to be particularly careful with how we consume our model data within our views, especially if doing so involves any kind of potentially heavy operations that could slow down our overall UI performance.</p><p>Hopefully this article has illustrated my overall approach to solving those kinds of problems, and if you have any questions, comments or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "When using multiple computed properties within SwiftUI views could become problematic, and various approaches to fix those kinds of problems.",
      "date_published": "2021-05-20T17:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/rendering-a-swiftui-view-in-a-playground",
      "url": "https://www.swiftbysundell.com/tips/rendering-a-swiftui-view-in-a-playground",
      "title": "Three ways to render a SwiftUI view in a playground",
      "content_html": "<p>Although Xcode Previews is quickly becoming the go-to development tool for quick iterations and prototyping when building SwiftUI views, there are still situations when firing up a Swift playground can be the quickest and easiest way to try out a new UI idea.</p><h2>Using UIHostingController</h2><p>One of the ways to render a SwiftUI view within a playground’s live view is to wrap it in a <code>UIHostingController</code>, which can then be assigned to the <code>liveView</code> property of the current <code>PlaygroundPage</code> — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">import</span> SwiftUI\n<span class=\"s-keyword\">import</span> PlaygroundSupport\n\n<span class=\"s-keyword\">struct</span> MyExperimentalView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        ...\n    }\n}\n\n<span class=\"s-keyword\">let</span> view = <span class=\"s-type\">MyExperimentalView</span>()\n<span class=\"s-keyword\">let</span> hostingVC = <span class=\"s-type\">UIHostingController</span>(rootView: view)\n<span class=\"s-type\">PlaygroundPage</span>.<span class=\"s-property\">current</span>.<span class=\"s-property\">liveView</span> = hostingVC</code></pre><h2>Calling setLiveView</h2><p>Although the above setup is not super verbose by any stretch of the imagination, it turns out that there’s an even simpler way to perform the above <code>liveView</code> assignment — and that’s by using the <code>setLiveView</code> method, which essentially performs the exact same <code>UIHostingController</code> wrapping that we did above, but in a way that doesn’t require any additional code on our part:</p><pre class=\"splash\"><code><span class=\"s-keyword\">import</span> SwiftUI\n<span class=\"s-keyword\">import</span> PlaygroundSupport\n\n<span class=\"s-keyword\">struct</span> MyExperimentalView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        ...\n    }\n}\n\n<span class=\"s-keyword\">let</span> view = <span class=\"s-type\">MyExperimentalView</span>()\n<span class=\"s-type\">PlaygroundPage</span>.<span class=\"s-property\">current</span>.<span class=\"s-call\">setLiveView</span>(view)</code></pre><h2>Pinning views to a playground’s timeline</h2><p>While both of the above two methods work great in many different kinds of situations, it’s definitely possible to encounter various kinds of SwiftUI errors that seem to only happen when rendering a view within a playground. Thankfully, if you ever do encounter any of those errors, there’s a third option that can be surprisingly powerful.</p><p>A feature that Swift playgrounds have supported since day one is that any value can be pinned to a playground’s timeline, which enables us to visualize the outcomes of our expressions in various ways. In the case of SwiftUI views, pinning a <code>View</code> expression actually results in that view being rendered inline, right within Xcode’s code editor.</p><p>For example, if we pin our above <code>MyExperimentalView()</code> expression by using the rectangular icon in the timeline on the right, it’ll now be rendered inline like this:</p><img src=\"https://www.swiftbysundell.com/images/tips/rendering-a-swiftui-view-in-a-playground.png\" alt=\"Inline rendering of a SwiftUI view\"/><p>What’s especially cool about this last technique is that it enables us to render multiple views at the same time, just like we can when using Xcode’s Preview feature.</p><h2>Conclusion</h2><p>So, there you have it. Three different ways to render a SwiftUI view within a playground. I still use playgrounds almost every single day. As someone who experiments a lot with both UI development and other Swift techniques, I find playgrounds to be an incredibly convenient tool, since I don’t have to create a whole proper Xcode project just to try out a quick idea.</p><p>Thanks for reading!</p>",
      "summary": "Great options for when we don’t want to create a whole new Xcode project just to try out a quick UI idea.",
      "date_published": "2021-05-19T17:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/essential-developer-may-2021",
      "url": "https://www.swiftbysundell.com/sponsor/essential-developer-may-2021",
      "title": "Sponsor: Essential Developer",
      "content_html": "<p>My thanks to Caio Zullo and Mike Apostolakis for sponsoring Swift by Sundell to promote Essential Developer and their <a href=\"https://iosacademy.essentialdeveloper.com/p/ios-career-crash-course-sbs3ea9\">iOS Career Crash Course</a> — a free online course for iOS developers.</p><p>While many iOS development courses out there are focused on helping beginners learn the fundamentals of app development, this quick crash course is for mid- and senior level developers who wish to improve their skills and advance their career. It touches on topics like refactoring legacy code, avoiding common anti-patterns, composition, and how to keep moving forward in your career.</p><p>The May edition of the course is starting today, on May 17th, so if you’re reading this article before May 23rd, then simply head over to <a href=\"https://iosacademy.essentialdeveloper.com/p/ios-career-crash-course-sbs3ea9\">the Essential Developer website</a> to sign up for this week’s course (it’s completely free!).</p><p>Or, if you’re reading this at a later point in time, then there will be many future editions of the course as well — all that you have to do is to <a href=\"https://iosacademy.essentialdeveloper.com/p/ios-career-crash-course-sbs3ea9\">enter your email here</a> and Caio and Mike will let you know once their next edition is starting.</p>",
      "summary": "Thanks a lot to Essential Developer for sponsoring Swift by Sundell.",
      "date_published": "2021-05-17T14:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/same-name-assignments",
      "url": "https://www.swiftbysundell.com/tips/same-name-assignments",
      "title": "Assigning an expression to a variable with the same name",
      "content_html": "<p><strong>New in Swift 5.4:</strong> It’s now possible to create a local variable that’s assigned to an expression that has the same name, without having to manually disambiguate with <code>self</code>.</p><p>For example, the following <code>ItemListViewController</code> has a method that lets us retrieve an <code>Item</code> for a given <code>IndexPath</code>, which we’ve chosen to simply call <code>item(at:)</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ItemListViewController: <span class=\"s-type\">UIViewController</span> {\n    ...\n\n    <span class=\"s-keyword\">private func</span> item(at indexPath: <span class=\"s-type\">IndexPath</span>) -&gt; <span class=\"s-type\">Item</span> {\n        ...\n    }\n}</code></pre><p>When using Swift 5.3 and earlier, if we wanted to call the above method and assign its result to a local <code>let</code> or <code>var</code> that’s also called <code>item</code>, we’d then have to prefix our method call with <code>self</code> in order for the compiler to be able to separate the two — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ItemListViewController: <span class=\"s-type\">UIViewController</span> {\n    ...\n\n    <span class=\"s-keyword\">private func</span> showDetailViewForItem(at indexPath: <span class=\"s-type\">IndexPath</span>) {\n        <span class=\"s-keyword\">let</span> item = <span class=\"s-keyword\">self</span>.<span class=\"s-call\">item</span>(at: indexPath)\n        ...\n    }\n}</code></pre><p>Starting in Swift 5.4, however, that’s no longer required, and the compiler will now automatically understand that the right-hand <code>item</code> symbol refers to a call to our method, regardless of whether we refer to it using <code>self</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ItemListViewController: <span class=\"s-type\">UIViewController</span> {\n    ...\n\n    <span class=\"s-keyword\">private func</span> showDetailViewForItem(at indexPath: <span class=\"s-type\">IndexPath</span>) {\n        <span class=\"s-keyword\">let</span> item = <span class=\"s-call\">item</span>(at: indexPath)\n        ...\n    }\n}</code></pre><p>Perhaps my favorite way of using this new syntax feature is when writing <a href=\"https://www.swiftbysundell.com/articles/unit-testing-asynchronous-swift-code\">unit tests for asynchronous code</a>, which typically involves creating <code>XCTestExpectation</code> instances using the built-in <code>expectation</code> API. Because the most natural name for such expectations is often simply <code>expectation</code>, it’s really nice to now be able to do the following:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ItemLoaderTests: <span class=\"s-type\">XCTestCase</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> testLoadingItem() {\n        <span class=\"s-keyword\">let</span> expectation = <span class=\"s-call\">expectation</span>(description: <span class=\"s-string\">\"Loading item\"</span>)\n        ...\n    }\n}</code></pre><p>Another type of situation in which the above feature could come in handy is when we want to create a local, mutable copy of a property. That can now also be done without having to use <code>self</code> when referring to the property that we’re copying — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Item {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> prefix: <span class=\"s-type\">String</span>?\n    <span class=\"s-keyword\">var</span> suffix: <span class=\"s-type\">String</span>?\n    \n    <span class=\"s-keyword\">func</span> fullTitle() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">var</span> title = title\n\n        <span class=\"s-keyword\">if let</span> prefix = prefix {\n            title = prefix + title\n        }\n\n        <span class=\"s-keyword\">if let</span> suffix = suffix {\n            title += suffix\n        }\n\n        <span class=\"s-keyword\">return</span> title\n    }\n}</code></pre><p>Granted, this might not be a revolutionary new syntax feature that will completely change the way we write Swift code — but hey, not every feature or change needs to be. I personally think that these kinds of “quality of life” improvements are incredibly welcome, and can make certain kinds of code feel quite a bit more lightweight.</p>",
      "summary": "It’s now possible to create a local variable that’s assigned to an expression that has the same name, without having to manually disambiguate with ‘self’.",
      "date_published": "2021-05-14T15:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/introducing-plot-components",
      "url": "https://www.swiftbysundell.com/articles/introducing-plot-components",
      "title": "Introducing Plot Components: A new way to build HTML pages using Swift",
      "content_html": "<p>Today I’m launching a huge update to my suite of Swift static site generation tools — specifically a brand <a href=\"https://github.com/JohnSundell/Plot\">new version of Plot</a>, the library that’s used to generate all of this website’s HTML, which adds a new API for building HTML components in a very SwiftUI-like way.</p><p>This new version has been in the works for over a year, and has been properly battle-tested in production. In fact, it was used to render the HTML for the article that you’re reading right now! So I couldn’t be more excited to now finally make it <a href=\"https://github.com/JohnSundell/Plot\">publicly available</a> for the entire Swift community.</p><h2>From nodes to components</h2><p>Up until this point, Plot has been using an API that represents all of the elements and attributes within an HTML page as <em>nodes</em>, which can then be composed and combined in various ways.</p><p>For example, here’s how an array of <code>BlogPost</code> models could be turned into a <code>&lt;ul&gt;</code>-element based feed of blog posts:</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> makeBlogFeed(containing posts: [<span class=\"s-type\">BlogPost</span>]) -&gt; <span class=\"s-type\">Node</span>&lt;<span class=\"s-type\">HTML</span>.<span class=\"s-type\">BodyContext</span>&gt; {\n    .<span class=\"s-call\">ul</span>(\n        .<span class=\"s-call\">class</span>(<span class=\"s-string\">\"blog-feed\"</span>),\n        .<span class=\"s-call\">forEach</span>(posts) { post <span class=\"s-keyword\">in</span>\n            .<span class=\"s-call\">li</span>(.<span class=\"s-call\">article</span>(\n                .<span class=\"s-call\">img</span>(.<span class=\"s-call\">src</span>(post.<span class=\"s-property\">imageURL</span>)),\n                .<span class=\"s-call\">h1</span>(.<span class=\"s-call\">text</span>(post.<span class=\"s-property\">title</span>)),\n                .<span class=\"s-call\">p</span>(.<span class=\"s-call\">text</span>(post.<span class=\"s-property\">description</span>)),\n                .<span class=\"s-call\">a</span>(<span class=\"s-string\">\"Continue reading\"</span>, .<span class=\"s-dotAccess\">href</span>(post.<span class=\"s-property\">url</span>))\n            ))\n        }\n    )\n}</code></pre><p>I’m still incredibly happy with the design of the API that’s used above, as it’s in many ways a perfect match for the very hierarchical nature of HTML and XML-based documents — but at the same time, I’ve become increasingly curious to see what a “SwiftUI makeover” of that API could look like.</p><p>Now, I don’t mean actually using SwiftUI itself to render HTML. Since it’s a closed-sourced project that was developed exclusively for building native views on Apple’s platforms, there’s really no reasonable way for a third party developer (like myself) to use it to render arbitrary HTML strings.</p><p>However, like we’ve taken a look at in articles like <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api\">“The Swift 5.1 features that power SwiftUI’s API”</a>, the public APIs that SwiftUI offers are all implemented using official language features (as of Swift 5.4 when <em><a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">result builders</a></em> finally became a proper part of the language). So, rather than attempting to turn SwiftUI into an HTML renderer, I built my own SwiftUI-inspired API that’s been tailor-made for the task of building HTML components.</p><p>This is what our blog feed from before would look like if we instead implemented it using that new component-based API:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> BlogFeed: <span class=\"s-type\">Component</span> {\n    <span class=\"s-keyword\">var</span> posts: [<span class=\"s-type\">BlogPost</span>]\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-type\">Component</span> {\n        <span class=\"s-type\">List</span>(posts) { post <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">Article</span> {\n                <span class=\"s-type\">Image</span>(post.<span class=\"s-property\">imageURL</span>)\n                <span class=\"s-type\">H1</span>(post.<span class=\"s-property\">title</span>)\n                <span class=\"s-type\">Paragraph</span>(post.<span class=\"s-property\">description</span>)\n                <span class=\"s-type\">Link</span>(<span class=\"s-string\">\"Continue reading\"</span>, url: post.<span class=\"s-property\">url</span>)\n            }\n        }\n        .<span class=\"s-call\">class</span>(<span class=\"s-string\">\"blog-feed\"</span>)\n    }\n}</code></pre><p>Even though we’re now using a substantially different syntax to render our HTML, the end result will actually be identical to our earlier implementation. What’s really cool, though, is that we no longer need to manually construct elements like the <code>&lt;ul&gt;</code> and <code>&lt;li&gt;</code> tags that’s used to render our list — we can now simply create a <code>List</code> component and Plot will take care of all of those details for us.</p><h2>Adapting some of SwiftUI’s core concepts for the web</h2><p>Something that’s very important, though, is that the goal of this project wasn’t simply to copy SwiftUI’s API directly. After all, building statically generated websites is fundamentally different from native app development, so while I wanted this new API to feel <em>familiar</em> to developers who know SwiftUI, I also wanted it to feel right at home within the context of HTML.</p><p>One concrete example of that is Plot’s <em>environment API</em>, which — just like <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-and-modifying-the-environment\">the one that SwiftUI offers</a> — lets you modify the behavior of certain components by entering values into the overall environment that they’re being rendered in.</p><p>On the surface level, that API works the exact same way as when you apply modifiers like <code>font</code> and <code>foregroundColor</code> to a SwiftUI view hierarchy — you can apply such modifiers to a given component, and they will then be automatically forwarded to that component’s children.</p><p>For example, here’s how we could apply a certain list style and link target to every <code>List</code>/<code>Link</code> that appears within a given hierarchy:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ExternalLinks: <span class=\"s-type\">Component</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-type\">Component</span> {\n        <span class=\"s-type\">Div</span> {\n            <span class=\"s-type\">H2</span>(<span class=\"s-string\">\"External Links\"</span>)\n            <span class=\"s-type\">List</span> {\n                <span class=\"s-type\">Link</span>(<span class=\"s-string\">\"My apps on the App Store\"</span>, url: <span class=\"s-string\">\"...\"</span>)\n                <span class=\"s-type\">Link</span>(<span class=\"s-string\">\"Twitter\"</span>, url: <span class=\"s-string\">\"...\"</span>)\n                <span class=\"s-type\">Link</span>(<span class=\"s-string\">\"GitHub\"</span>, url: <span class=\"s-string\">\"...\"</span>)\n            }\n        }\n        .<span class=\"s-call\">class</span>(<span class=\"s-string\">\"external-links\"</span>)\n        .<span class=\"s-call\">listStyle</span>(.<span class=\"s-dotAccess\">ordered</span>)\n        .<span class=\"s-call\">linkTarget</span>(.<span class=\"s-dotAccess\">blank</span>)\n    }\n}</code></pre><p class=\"info\">The result of the above is that our <code>List</code> will be rendered as ordered (using the <code>&lt;ol&gt;</code> element), and that each of the <code>&lt;a&gt;</code> elements that will be generated for our <code>Link</code> components will be assigned the attribute <code>target=\"_blank\"</code>, which will make their URLs open in a new tab.</p><p>But if we now dive a little bit deeper into this feature and take a look at how we can define our very own environment values and keys, we can see that I made a few different decisions compared to how SwiftUI’s environment API is designed.</p><p>As an example, let’s take a look at this simplified version of the <code>Menu</code> component that I use to render the main menu of this very website — which uses Plot’s environment API to retrieve what section that’s currently selected:</p><pre class=\"splash\"><code><span class=\"s-comment\">// In Plot, environment keys are defined by extending a concrete\n// EnvironmentKey type, rather than by conforming to a protocol:</span>\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">EnvironmentKey</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Value</span> == <span class=\"s-type\">SwiftBySundell</span>.<span class=\"s-type\">SectionID</span>? {\n    <span class=\"s-keyword\">static var</span> selectedSectionID: <span class=\"s-type\">Self</span> { <span class=\"s-type\">Self</span>() }\n}\n\n<span class=\"s-keyword\">struct</span> Menu: <span class=\"s-type\">Component</span> {\n    <span class=\"s-comment\">// Environment values can be retrieved using the EnvironmentValue\n    // property wrapper (which is the Plot equivalent of SwiftUI's\n    // Environment wrapper):</span>\n    <span class=\"s-keyword\">@EnvironmentValue</span>(.<span class=\"s-dotAccess\">selectedSectionID</span>) <span class=\"s-keyword\">private var</span> selectedSectionID\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-type\">Component</span> {\n        <span class=\"s-type\">Navigation</span> {\n            <span class=\"s-type\">List</span>(<span class=\"s-type\">SwiftBySundell</span>.<span class=\"s-type\">SectionID</span>.<span class=\"s-property\">allCases</span>) { sectionID <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Link</span>(\n                    sectionID.<span class=\"s-property\">menuTitle</span>,\n                    url: sectionID.<span class=\"s-property\">url</span>\n                )\n                .<span class=\"s-call\">class</span>(<span class=\"s-call\">classForSection</span>(withID: sectionID))\n            }\n        }\n    }\n\n    <span class=\"s-keyword\">private func</span> classForSection(\n        withID id: <span class=\"s-type\">SwiftBySundell</span>.<span class=\"s-type\">SectionID</span>\n    ) -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-comment\">// We can now use our environment value to make decisions\n        // within this component — in this case in order to determine\n        // whether a given menu item should be marked as selected:</span>\n        id == selectedSectionID ? <span class=\"s-string\">\"selected\"</span> : <span class=\"s-string\">\"\"</span>\n    }\n}</code></pre><p>So while SwiftUI offers several different ways to interact with its environment API (through the <code>Environment</code> and <code>EnvironmentObject</code> property wrappers, the <code>EnvironmentKey</code> protocol, and so on), I chose to implement a simplified version that still offers enough power to be incredibly useful within the context of static site generation. After all, it wouldn’t make much sense for me to implement support for things like observable objects, since (unlike SwiftUI) Plot is not generating any dynamic views that need to be updated according to state changes.</p><h2>Conclusion</h2><p>So, essentially, this new version of Plot is my take on a SwiftUI-like API that’s specifically made for generating static HTML. It’s not meant to be a replacement for dynamic client-side web frameworks (like React or Vue.js), nor does it offer any APIs for applying custom styles to its components (that still has to be done using CSS).</p><p>In the future, I do hope to be able to continue to extend Plot to also support CSS generation, but that’s a project for another day. In the meantime, I’m incredibly excited to share this new component-based API with you and the rest of the Swift community. I hope that you’ll find it useful, and like our friends at Apple always like to say — I can’t wait to see what you’ll build with it!</p><p>If you’re looking for more examples of how this new API can be used, check out <a href=\"https://github.com/JohnSundell/Plot\">Plot’s README</a>, or <a href=\"https://github.com/JohnSundell/Publish\">the new version of Publish</a>, which has also been updated to support this new component-based API. In fact, all of Publish’s built-in <a href=\"https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Theme%2BFoundation.swift\">Foundation theme</a> has been rewritten using this new API. And if you’re an existing user of either Plot or Publish, then you just have to upgrade to the latest version — this new API is fully backward compatible, so you shouldn’t encounter any breaking changes.</p><p>I hope you’ll enjoy this new version of Plot, and feel free to send me either <a href=\"https://twitter.com/johnsundell\">a tweet</a> or <a href=\"https://www.swiftbysundell.com/contact\">an email</a> if you have any questions, comments, or feedback.</p><p>Thanks for reading!</p>",
      "summary": "A huge update to my suite of Swift static site generation tools, which adds a new API for building HTML components in a very SwiftUI-like way.",
      "date_published": "2021-05-11T15:50:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/matteo-manferdini-may-2021",
      "url": "https://www.swiftbysundell.com/sponsor/matteo-manferdini-may-2021",
      "title": "Sponsor: Architecting SwiftUI apps with MVC and MVVM",
      "content_html": "<p>Thanks a lot to Matteo Manferdini for sponsoring Swift by Sundell last week to promote his SwiftUI guide <em><a href=\"https://matteomanferdini.com/architecting-swiftui-apps-with-mvc-and-mvvm/swiftbysundell\">“Architecting SwiftUI apps with MVC and MVVM”</a></em>. The guide is completely free to <a href=\"https://matteomanferdini.com/architecting-swiftui-apps-with-mvc-and-mvvm/swiftbysundell\">download</a>, and contains lots of practical tips and examples on how to setup robust architectures for SwiftUI-based apps.</p><p>Rather than just promoting a single architectural pattern as a “silver bullet”-style solution, Matteo’s guide instead discusses the pros and cons of various approaches, including how to adopt traditionally object-oriented concepts (like controllers) to the declarative world of SwiftUI, the role of view models, and much more.</p><p>It also contains tips and advice around many other general coding principles (such as separation of concerns), and each technique is neatly explained using code samples, screenshots and flow charts.</p><p>Get the guide <a href=\"https://matteomanferdini.com/architecting-swiftui-apps-with-mvc-and-mvvm/swiftbysundell\">for free right here</a>, and just by downloading Matteo’s free guide you’ll also directly help support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to Architecting SwiftUI apps with MVC and MVVM for sponsoring Swift by Sundell.",
      "date_published": "2021-05-10T10:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/deciding-what-queue-to-run-a-completion-handler-on",
      "url": "https://www.swiftbysundell.com/articles/deciding-what-queue-to-run-a-completion-handler-on",
      "title": "Deciding what DispatchQueue to run a completion handler on",
      "content_html": "<p>When it comes to calling completion handlers for asynchronous operations, the established convention within the Apple developer community has for long been to simply continue executing on whatever <code>DispatchQueue</code> that the operation itself (or at least its final part) was performed on.</p><p>For example, when using the built-in <code>URLSession</code> API to perform a data task-based network call, our attached completion handler will be executed on a queue that’s managed internally by <code>URLSession</code> itself:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> task = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>.<span class=\"s-call\">dataTask</span>(with: url) {\n    data, response, error <span class=\"s-keyword\">in</span>\n\n    <span class=\"s-comment\">// This code will be executed on an internal URLSession queue,\n    // regardless of what queue that we created our task on.</span>\n    ...\n}</code></pre><p>The above convention does arguably make complete sense <em>in theory</em> — as it encourages us to write asynchronous code that’s non-blocking, and since it tends to reduce the overhead involved in jumping between queues when doing so isn’t needed. However, it can also very often lead to different kinds of bugs and race conditions if we’re not careful.</p><p>That’s because, at the end of the day, the vast majority of the code within the vast majority of applications isn’t going to be thread-safe. Making a class, function, or another kind of implementation thread-safe typically involves a fair amount of work, especially when it comes to UI-related code, since all of Apple’s core UI frameworks (including both UIKit and SwiftUI) can only be safely used from the main thread.</p><h2>Remembering to dispatch UI updates on the main queue</h2><p>Let’s take a look at an example, in which we’ve built a <code>ProductLoader</code> that uses the above mentioned <code>URLSession</code> API to load a given <code>Product</code> based on its ID:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProductLoader {\n    <span class=\"s-keyword\">typealias</span> Handler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Product</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n    <span class=\"s-keyword\">private let</span> urlResolver: (<span class=\"s-type\">Product</span>.<span class=\"s-type\">ID</span>) -&gt; <span class=\"s-type\">URL</span>\n    \n    ...\n\n    <span class=\"s-keyword\">func</span> loadProduct(withID id: <span class=\"s-type\">UUID</span>,\n                     completionHandler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: <span class=\"s-call\">urlResolver</span>(id)) {\n            data, response, error <span class=\"s-keyword\">in</span>\n\n            <span class=\"s-comment\">// Decode data, perform error handling, and so on...</span>\n            ...\n            \n            <span class=\"s-call\">handler</span>(result)\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>The above class follows that established convention of not dispatching its <code>completionHandler</code> call on any specific queue, and instead simply calls that closure inline within its own completion handler, which is in turn called by <code>URLSession</code> on that previously mentioned internal background queue.</p><p>Because of that, whenever we’re using our <code>ProductLoader</code> within any kind of UI-related code, we need to remember to always explicitly dispatch any resulting UI updates on our application’s main <code>DispatchQueue</code> — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProductViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> productID: <span class=\"s-type\">Product</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">ProductLoader</span>\n    <span class=\"s-keyword\">private lazy var</span> nameLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private lazy var</span> descriptionLabel = <span class=\"s-type\">UILabel</span>()\n    \n    ...\n\n    <span class=\"s-keyword\">func</span> update() {\n        loader.<span class=\"s-call\">loadProduct</span>(withID: productID) { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>.<span class=\"s-property\">async</span> {\n                <span class=\"s-keyword\">switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> product):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">nameLabel</span>.<span class=\"s-property\">text</span> = product.<span class=\"s-property\">name</span>\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">descriptionLabel</span>.<span class=\"s-property\">text</span> = product.<span class=\"s-property\">description</span>\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">handle</span>(error)\n                }\n            }\n        }\n    }\n}</code></pre><p>Having to remember to perform the above kind of <code>DispatchQueue</code> calls within our asynchronous closures might not actually be a <em>huge</em> issue in practice, since (just like the classic <code>weak self</code> dance) it’s something that we have to do incredibly often when developing apps for Apple’s platforms, so it’s not something that we’re likely to forget.</p><p>Plus, if we ever do forget to add that call (or if someone’s just getting started with app development and haven’t learned about that aspect yet), then Xcode’s <em>Main Thread Checker</em> will quickly trigger one of its purple warnings as soon as we run any code that accidentally calls a main queue-only API from a background thread.</p><p>However, what if we’re not using closures? For example, let’s imagine that our <code>ProductLoader</code> instead used the <a href=\"https://www.swiftbysundell.com/articles/delegation-in-swift\">delegate pattern</a>, and rather than calling a completion handler, it would instead call a delegate method whenever it finished one of its operations:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProductLoader {\n    <span class=\"s-keyword\">weak var</span> delegate: <span class=\"s-type\">ProductLoaderDelegate</span>?\n    ...\n\n    <span class=\"s-keyword\">func</span> loadProduct(withID id: <span class=\"s-type\">UUID</span>) {\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: <span class=\"s-call\">urlResolver</span>(id)) {\n            [<span class=\"s-keyword\">weak self</span>] data, response, error <span class=\"s-keyword\">in\n\n            guard let self</span> = <span class=\"s-keyword\">self else</span> { <span class=\"s-keyword\">return</span> }\n\n            <span class=\"s-comment\">// Decode data, perform error handling, and so on...</span>\n            ...\n            \n            <span class=\"s-keyword\">self</span>.<span class=\"s-property\">delegate</span>?.<span class=\"s-call\">productLoader</span>(<span class=\"s-keyword\">self</span>,\n                didFinishLoadingWithResult: result\n            )\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>If we now go back to our <code>ProductViewController</code> and update it accordingly, it’s no longer very clear that the call site (its delegate protocol implementation in this case) is handling the result of an asynchronous operation, which makes it much more likely that we’ll forget to perform our UI updates asynchronously on the main queue.</p><p>So although Xcode will still give us a runtime error when the following method is called (and our UI updates are performed on a background queue), it’s not very obvious that its implementation is incorrect just by looking at it:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ProductViewController</span>: <span class=\"s-type\">ProductLoaderDelegate</span> {\n    <span class=\"s-keyword\">func</span> productLoader(\n        <span class=\"s-keyword\">_</span> loader: <span class=\"s-type\">ProductLoader</span>,\n        didFinishLoadingWithResult result: <span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Product</span>, <span class=\"s-type\">Error</span>&gt;\n    ) {\n        <span class=\"s-keyword\">switch</span> result {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> product):\n            nameLabel.<span class=\"s-property\">text</span> = product.<span class=\"s-property\">name</span>\n            descriptionLabel.<span class=\"s-property\">text</span> = product.<span class=\"s-property\">description</span>\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-call\">handle</span>(error)\n        }\n    }\n}</code></pre><p>Granted, the delegate pattern is not as hip and trendy as it used to be (I still like it, though), but the above problem is definitely not unique to that particular pattern. In fact, if we now look at a very modern, <a href=\"https://www.swiftbysundell.com/discover/combine\">Combine</a>-based version of our <code>ProductLoader</code> and its associated view controller — we can see that it has the exact same problem as our delegate-based implementation — it’s not at all obvious that our UI updates will currently end up being performed on a background queue:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProductLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> loadProduct(withID id: <span class=\"s-type\">UUID</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Product</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: <span class=\"s-call\">urlResolver</span>(id))\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Product</span>.<span class=\"s-keyword\">self</span>, decoder: <span class=\"s-type\">JSONDecoder</span>())\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}\n\n<span class=\"s-keyword\">class</span> ProductViewController: <span class=\"s-type\">UIViewController</span> {\n    ...\n    <span class=\"s-keyword\">private var</span> updateCancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    <span class=\"s-keyword\">func</span> update() {\n        updateCancellable = loader\n            .<span class=\"s-call\">loadProduct</span>(withID: productID)\n            .<span class=\"s-call\">convertToResult</span>()\n            .<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n                switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> product):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">nameLabel</span>.<span class=\"s-property\">text</span> = product.<span class=\"s-property\">name</span>\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">descriptionLabel</span>.<span class=\"s-property\">text</span> = product.<span class=\"s-property\">description</span>\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">handle</span>(error)\n                }\n            }\n    }\n}</code></pre><p class=\"info\">Above we’re using the custom <code>convertToResult</code> operator from <a href=\"https://www.swiftbysundell.com/articles/extending-combine-with-convenience-apis/#result-conversions\">“Extending Combine with convenience APIs”</a> to be able to easily handle our Combine pipeline’s output as a <code>Result</code> value.</p><p>So, to summarize, regardless of which pattern that we choose to implement our asynchronous operations, there’s always a risk that we’ll forget to manually dispatch our UI updates on the main queue — especially when it’s not obvious that a given callback might be performed on a background queue.</p><h2>Explicit queue injection</h2><p>So how can we fix the above problem? Is it even worth fixing, or should we just assume that every Swift developer with a certain amount of experience will always remember to ensure that their UI updates will be performed on the main queue?</p><p>If you ask me, I think that any truly great API shouldn’t rely on its caller remembering (or even knowing) certain conventions — those conventions should ideally be baked into the <a href=\"https://www.swiftbysundell.com/articles/designing-swift-apis\">API design itself</a>. After all, a quite rock-solid way to ensure that an API doesn’t ever get used incorrectly is to make it impossible (or at least <em>very hard</em>) to do so — by leveraging tools like Swift’s type system to validate each call at compile time.</p><p>One way to do that in this case would be to <em>always</em> call our completion handlers on the main queue, which would completely eliminate the risk of having any of our call sites accidentally perform UI updates on a background queue:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ProductLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> loadProduct(withID id: <span class=\"s-type\">UUID</span>,\n                     completionHandler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: <span class=\"s-call\">urlResolver</span>(id)) {\n            data, response, error <span class=\"s-keyword\">in</span>\n\n            ...\n\n            <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>.<span class=\"s-call\">async</span> {\n                <span class=\"s-call\">completionHandler</span>(result)\n            }\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>However, the above pattern can also end up causing issues of its own, especially if we’re looking to use our <code>ProductLoader</code> within contexts where we <em>do want</em> to continue executing on a background queue in a non-blocking way.</p><p>So here’s a much more dynamic version, which still uses the main queue as the default for all completion handler calls, but also enables an explicit <code>DispatchQueue</code> to be injected — giving us the flexibility to both use our <code>ProductLoader</code> within concurrent environments that operate away from the main thread, and within our UI code, all while significantly reducing the risk of performing UI updates on the wrong queue:</p><pre class=\"splash\"><code><span class=\"s-comment\">// Completion handler-based version:</span>\n\n<span class=\"s-keyword\">class</span> ProductLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> loadProduct(\n        withID id: <span class=\"s-type\">UUID</span>,\n        resultQueue: <span class=\"s-type\">DispatchQueue</span> = .<span class=\"s-dotAccess\">main</span>,\n        completionHandler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>\n    ) {\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: <span class=\"s-call\">urlResolver</span>(id)) {\n            data, response, error <span class=\"s-keyword\">in</span>\n\n            ...\n\n            resultQueue.<span class=\"s-call\">async</span> {\n                <span class=\"s-call\">completionHandler</span>(result)\n            }\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}\n\n<span class=\"s-comment\">// Combine-based version:</span>\n\n<span class=\"s-keyword\">class</span> ProductLoader {\n    ...\n    \n    <span class=\"s-keyword\">func</span> loadProduct(\n        withID id: <span class=\"s-type\">UUID</span>,\n        resultQueue: <span class=\"s-type\">DispatchQueue</span> = .<span class=\"s-dotAccess\">main</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Product</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: <span class=\"s-call\">urlResolver</span>(id))\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Product</span>.<span class=\"s-keyword\">self</span>, decoder: <span class=\"s-type\">JSONDecoder</span>())\n            .<span class=\"s-call\">receive</span>(on: resultQueue)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Of course, the above pattern does rely on us remembering to add that <code>resultQueue</code> argument to each of our asynchronous APIs (we could’ve also implemented it as an initializer parameter instead), but at least now we don’t have to remember to always use <code>DispatchQueue.main.async</code> at <em>every single call site</em> — which I personally think is a big win.</p><h2>Conclusion</h2><p>While there’s no such thing as a completely error-proof API, and developing apps for any kind of platform is always going to involve learning and remembering certain conventions, if we can make the APIs that we design within our own apps as easy to use (or as hard to misuse) as possible, then that tends to result in code bases that are robust and straightforward to work with.</p><p>Defaulting to calling completion handlers on the main queue might just be a small part of that, but it might turn out to be a quite important part, especially within code bases that make heavy use of asynchronous operations that result in UI updates.</p><p>If you want to hear more thoughts on this topic, then I really recommend listening to <a href=\"https://www.swiftbysundell.com/podcast/95\">my recent podcast conversation with Brent Simmons</a>, which focused on how to orchestrate concurrent code within iOS and Mac apps.</p><p>Thanks for reading!</p>",
      "summary": "What’s the issue with calling UI-related completion handlers on background queues, and how can we ensure that all of our UI updates are performed on the main queue?",
      "date_published": "2021-05-06T14:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/controlling-the-timing-of-a-combine-pipeline",
      "url": "https://www.swiftbysundell.com/articles/controlling-the-timing-of-a-combine-pipeline",
      "title": "Controlling the timing of a Combine pipeline",
      "content_html": "<p>Often when writing Combine-powered data pipelines, we want those pipelines to emit values as quickly as possible, as soon as each operation finishes. However, sometimes we might also want to introduce certain delays in order to prevent unnecessary work from being performed, or to be able to retry a failed operation after a certain amount of time.</p><h2>Debouncing</h2><p>One type of situation in which we might want to wait for a small amount of time before triggering a given pipeline is when our operations are based on some kind of free-form user input.</p><p>For example, let’s say that we’re building a controller that manages a list of items that are loaded from a <code>Database</code>, and that the user can choose to apply a string-based <code>filter</code> to the items that are being loaded.</p><p>To prevent too many database queries from being performed if the user rapidly types into the text field that our <code>filter</code> value is connected to, we could apply the <code>debounce</code> operator right before we perform our database call. That way, Combine will only continue executing our pipeline once no new values have come in for a certain amount of time (0,3 seconds in this case):</p><pre class=\"splash\"><code><span class=\"s-keyword\">final class</span> ItemListController: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> items = [<span class=\"s-type\">Item</span>]()\n    <span class=\"s-keyword\">@Published var</span> filter = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">init</span>(database: <span class=\"s-type\">Database</span>) {\n        <span class=\"s-property\">$filter</span>\n            .<span class=\"s-call\">removeDuplicates</span>()\n            .<span class=\"s-call\">debounce</span>(for: <span class=\"s-number\">0.3</span>, scheduler: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">map</span>(database.<span class=\"s-property\">loadItemsMatchingFilter</span>)\n            .<span class=\"s-call\">switchToLatest</span>()\n            .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$items</span>)\n    }\n}</code></pre><p class=\"info\">To learn more about the above technique, including why the <code>switchToLatest</code> operator is used, check out <a href=\"https://www.swiftbysundell.com/articles/connecting-and-merging-combine-publishers-in-swift\">\"Connecting and merging Combine publishers in Swift\"</a>, which goes into much more detail on this topic.</p><h2>Delayed retries</h2><p>Like its name implies, Combine’s built-in <code>retry</code> operator lets us automatically retry a pipeline’s operations if an error was encountered. When using it, we simply have to specify the maximum amount of retries that we’d like to perform, and Combine will take care of the rest. Here we’re using that operator within a customized version of the standard Combine-powered <code>URLSession</code> data task API, which will let us automatically retry any failed network request a certain amount of times:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLSession</span> {\n    <span class=\"s-keyword\">func</span> decodedDataTaskPublisher&lt;T: <span class=\"s-type\">Decodable</span>&gt;(\n        for url: <span class=\"s-type\">URL</span>,\n        retryCount: <span class=\"s-type\">Int</span> = <span class=\"s-number\">3</span>,\n        decodingResultAs resultType: <span class=\"s-type\">T</span>.<span class=\"s-type\">Type</span> = <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>,\n        decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>(),\n        returnQueue: <span class=\"s-type\">DispatchQueue</span> = .<span class=\"s-dotAccess\">main</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">retry</span>(retryCount)\n            .<span class=\"s-call\">receive</span>(on: returnQueue)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>However, with the above implementation, each retry will be performed instantly as soon as an error was encountered, but what if we instead wanted to apply a certain delay between each retried operation?</p><p>For that, let’s turn to Combine’s <code>delay</code> operator, which lets us introduce a fixed amount of delay between two operations. Since we’re only looking to delay our retries in this case, we’ll use the <code>catch</code> operator to create a separate pipeline that applies our desired delay to a constant <code>Void</code> output value, and then calls <code>flatMap</code> to trigger our upstream pipeline once more -- like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> retry&lt;T: <span class=\"s-type\">Scheduler</span>&gt;(\n        <span class=\"s-keyword\">_</span> retries: <span class=\"s-type\">Int</span>,\n        delay: <span class=\"s-type\">T</span>.<span class=\"s-type\">SchedulerTimeType</span>.<span class=\"s-type\">Stride</span>,\n        scheduler: <span class=\"s-type\">T</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Output</span>, <span class=\"s-type\">Failure</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-call\">catch</span> { <span class=\"s-keyword\">_ in</span>\n            <span class=\"s-type\">Just</span>(())\n                .<span class=\"s-call\">delay</span>(for: delay, scheduler: scheduler)\n                .<span class=\"s-call\">flatMap</span> { <span class=\"s-keyword\">_ in self</span> }\n                .<span class=\"s-call\">retry</span>(retries &gt; <span class=\"s-number\">0</span> ? retries - <span class=\"s-number\">1</span> : <span class=\"s-number\">0</span>)\n        }\n        .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p class=\"info\">Note that we have to subtract <code>1</code> from the passed number of <code>retries</code>, since our <code>flatMap</code> operator will always run at least once. However, we also have to be careful not to turn that number negative, since that will cause Combine to perform an infinite number of retries.</p><p>With the above in place, we can update our custom data task API from before to now look like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLSession</span> {\n    <span class=\"s-keyword\">func</span> decodedDataTaskPublisher&lt;T: <span class=\"s-type\">Decodable</span>&gt;(\n        for url: <span class=\"s-type\">URL</span>,\n        retryCount: <span class=\"s-type\">Int</span> = <span class=\"s-number\">3</span>,\n        decodingResultAs resultType: <span class=\"s-type\">T</span>.<span class=\"s-type\">Type</span> = <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>,\n        decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>(),\n        returnQueue: <span class=\"s-type\">DispatchQueue</span> = .<span class=\"s-dotAccess\">main</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">retry</span>(retryCount, delay: <span class=\"s-number\">3</span>, scheduler: returnQueue)\n            .<span class=\"s-call\">receive</span>(on: returnQueue)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>A three-second delay will now be applied between each retry, which is particularly useful in this case, since the user’s connection might’ve been temporarily offline when we first initiated our network call.</p><p>However, worth pointing out is that the above code sample is not meant to be a complete ready-to-use networking implementation, since we’d probably want to only retry when certain errors were encountered. For example, if we’re performing an authenticated network call and the user’s access token has become outdated, retrying such a call with the same parameters would just be a waste of battery and bandwidth.</p><p>To implement that kind of per-error logic, we could use the <code>tryCatch</code> operator instead, and then <code>throw</code> the errors that we don’t wish to perform a retry for. When doing that, our pipeline would immediately fail, and trigger whatever error handling that we’ve added at the call site.</p><p>Just like how we sometimes might want to introduce artificial delays within certain pipelines, there are also cases when we might want to completely defer a publisher’s execution until a subscriber was attached to it. This is exactly what the special <code>Deferred</code> publisher lets us do, which often becomes particularly useful when using Combine’s <a href=\"https://www.swiftbysundell.com/articles/using-combine-futures-and-subjects/#retrofitting-with-futures\"><code>Future</code></a> type.</p><p>For example, let’s say that we’re currently using <code>Future</code> to retrofit a <code>FeaturedItemsLoader</code> with Combine support -- by sending the <code>promise</code> closure that’s passed into our future to our previous, closure-based API as a completion handler:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">FeaturedItemsLoader</span> {\n    <span class=\"s-keyword\">var</span> itemsPublisher: <span class=\"s-type\">Future</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-type\">Future</span> { [<span class=\"s-keyword\">weak self</span>] promise <span class=\"s-keyword\">in\n            self</span>?.<span class=\"s-call\">loadItems</span>(then: promise)\n        }\n    }\n}</code></pre><p>The above works perfectly fine if we want each loading operation to start immediately, and if we never want to retry such an operation. However, doing something like the following won’t actually work as expected:</p><pre class=\"splash\"><code>featuredItemsLoader.<span class=\"s-property\">itemsPublisher</span>\n    .<span class=\"s-call\">retry</span>(<span class=\"s-number\">5</span>)\n    .<span class=\"s-call\">replaceError</span>(with: [])\n    .<span class=\"s-call\">sink</span> { items <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle items</span>\n        ...\n    }</code></pre><p>The reason the above doesn’t work is because a <code>Future</code> is always only run once, and then caches its result regardless if it succeeded or failed -- meaning that even if the above pipeline will indeed be retried 5 times if an error was encountered, each of those retries will receive the exact same output from our <code>Future</code>-based <code>itemsPublisher</code>.</p><p>To fix that problem, let’s wrap our <code>Future</code> creation code within a <code>Deferred</code> publisher -- which will both defer the creation of our underlying publisher until a subscriber started requesting values from it, and will also let us properly retry our pipeline, since doing so will now cause a new <code>Future</code> instance to be created for each retry:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">FeaturedItemsLoader</span> {\n    <span class=\"s-keyword\">var</span> itemsPublisher: <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-type\">Deferred</span> {\n            <span class=\"s-type\">Future</span> { [<span class=\"s-keyword\">weak self</span>] promise <span class=\"s-keyword\">in\n                self</span>?.<span class=\"s-call\">loadItems</span>(then: promise)\n            }\n        }\n        .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>However, while <code>Deferred</code> is incredibly useful, we shouldn’t necessarily use it every single time that we use a <code>Future</code>. Think of <code>Deferred</code> as the Combine equivalent of a <a href=\"https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift\">lazy property</a> -- it doesn’t make sense to make every single property lazy, but it’s a useful tool to have in our toolbox for when we want the characteristics that lazy evaluation gives us.</p><h2>Conclusion</h2><p>Just like how Combine’s pipeline-oriented design can be truly wonderful when it comes to setting up reactive data flows and observations, it can also make implementing things like precise timing and retries a bit challenging, but hopefully this article has provided you with a few insights on how to do just that.</p><p>If you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>. If you enjoyed this article and want to support my work, then two fantastic ways to do so are to either share this article with a friend, or to check out this week’s sponsor.</p><p>Thanks for reading!</p>",
      "summary": "How to implement timing features like debouncing, deferring, and delayed retries when building Combine-based data pipelines.",
      "date_published": "2021-04-30T17:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/96",
      "url": "https://www.swiftbysundell.com/podcast/96",
      "title": "Podcast: “Gesture-driven animations”, with special guest Adam Bell",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell96.mp3\" type=\"audio/mpeg\"/></audio><p>Adam Bell returns to the show to talk about animations, both how to make great use of the built-in animation tools that the iOS SDK ships with, but also how to drive custom, gesture-driven animation logic and the sort of performance optimizations that are typically required when writing that sort of code.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://macstadium.com/sundell\">MacStadium</a>:</strong> The leading provider of cloud solutions built on real Mac hardware. Get started at <a href=\"https://macstadium.com/sundell\">macstadium.com/sundell</a>.</li><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Incredibly useful bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to start your free trial.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/b3ll\">Adam on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://github.com/b3ll/Motion\">Motion</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/57\">The previous episode with Adam</a></li><li><a href=\"https://github.com/b3ll/Decomposed\">Decomposed</a></li><li><a href=\"https://developer.apple.com/documentation/quartzcore/catransform3d\">CATransform3D</a></li><li><a href=\"https://en.wikipedia.org/wiki/SIMD\">SIMD</a></li><li><a href=\"https://developer.apple.com/documentation/quartzcore\">Core Animation</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uiviewpropertyanimator\">UIViewPropertyAnimator</a></li><li><a href=\"https://developer.apple.com/documentation/quartzcore/cadisplaylink\">CADisplayLink</a></li><li><a href=\"https://www.swiftbysundell.com/basics/time-complexity\">Time complexity</a></li><li><a href=\"https://github.com/johnsundell/imagineengine\">Imagine Engine</a></li><li><a href=\"https://github.com/apple/swift/blob/main/docs/Generics.rst#specialization\">Swift’s @_specialize attribute</a></li><li><a href=\"https://github.com/apple/swift/blob/main/docs/OptimizationTips.rst#dynamic-dispatch\">Static vs dynamic dispatch in Swift</a></li><li><a href=\"https://docs.swift.org/swift-book/ReferenceManual/Attributes.html#ID587\">Swift’s @inlinable attribute</a></li><li><a href=\"https://developer.apple.com/documentation/quartzcore/catransaction\">CATransaction</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uispringtimingparameters\">UISpringTimingParameters</a></li><li><a href=\"https://developer.apple.com/documentation/quartzcore/cakeyframeanimation\">CAKeyFrameAnimation</a></li><li><a href=\"https://developer.apple.com/tutorials/swiftui/animating-views-and-transitions\">SwiftUI’s animation API</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uiaccessibility/1615133-isreducemotionenabled\">Detecting whether the “reduce motion” accessibility setting is enabled</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Adam Bell returns to the show to talk about animations, both how to make great use of the built-in animation tools that the iOS SDK ships with, but also how to drive custom, gesture-driven animation logic and the sort of performance optimizations that are typically required when writing that sort of code.",
      "date_published": "2021-04-29T18:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/swiftui-frame-modifier",
      "url": "https://www.swiftbysundell.com/articles/swiftui-frame-modifier",
      "title": "Using SwiftUI’s frame modifier to resize and align views",
      "content_html": "<p>SwiftUI’s built-in <code>frame</code> modifier can both be used to assign a static width or height to a given view, or to apply “constraints-like” bounds within which the view can grow or shrink depending on its contents and surroundings.</p><p>At the very basic level, this is what two common usages of the <code>frame</code> modifier could look like:</p><pre class=\"splash\"><code><span class=\"s-comment\">// A view that displays a 30x30 fixed-sized icon using an SFSymbol:</span>\n<span class=\"s-keyword\">struct</span> Icon: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> tintColor: <span class=\"s-type\">Color</span> = .<span class=\"s-dotAccess\">blue</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Image</span>(systemName: name)\n            .<span class=\"s-call\">foregroundColor</span>(tintColor)\n            .<span class=\"s-call\">frame</span>(width: <span class=\"s-number\">30</span>, height: <span class=\"s-number\">30</span>)\n    }\n}\n\n<span class=\"s-comment\">// A view that displays a decorative image that's resized according\n// to its aspect ratio, with a maximum width of 200 points:</span>\n<span class=\"s-keyword\">struct</span> DecorativeImage: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Image</span>(name)\n            .<span class=\"s-call\">resizable</span>()\n            .<span class=\"s-call\">aspectRatio</span>(contentMode: .<span class=\"s-dotAccess\">fit</span>)\n            .<span class=\"s-call\">frame</span>(maxWidth: <span class=\"s-number\">200</span>)\n    }\n}</code></pre><p>While the above two ways of using the <code>frame</code> modifier are both incredibly useful, sometimes we might not want to specify any kind of fixed metric when deciding how our views should be sized. Thankfully, there’s also a way to make a given view expand <em>infinitely</em>, which can come in handy in many different kinds of situations.</p><p>For example, let’s say that we’re working on a view that displays an array of categories as a two-column grid using SwiftUI’s <code>LazyVGrid</code> type:</p><pre data-preview=\"grid-initial\"><code><span class=\"s-keyword\">struct</span> CategoryGrid: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> categories: [<span class=\"s-type\">Category</span>]\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">LazyVGrid</span>(columns: columns) {\n            <span class=\"s-type\">ForEach</span>(categories) { category <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Text</span>(category.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">padding</span>()\n                    .<span class=\"s-call\">background</span>(category.<span class=\"s-property\">color</span>)\n                    .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                    .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n            }\n        }\n        .<span class=\"s-call\">padding</span>()\n    }\n\n    <span class=\"s-keyword\">private var</span> columns: [<span class=\"s-type\">GridItem</span>] {\n        <span class=\"s-keyword\">let</span> item = <span class=\"s-type\">GridItem</span>(.<span class=\"s-call\">flexible</span>(minimum: <span class=\"s-number\">50</span>, maximum: .<span class=\"s-dotAccess\">infinity</span>))\n        <span class=\"s-keyword\">return</span> [item, item]\n    }\n}</code></pre><p>As you can see by using the above <code>PREVIEW</code> button, our grid currently doesn’t look <em>that great</em>, since each cell ends up being a different size based on the text that it’s rendering.</p><p>That might initially seem a little bit strange — given that we’re specifying that both of our columns should be flexible with an infinite max width — but since a <code>Text</code> view doesn’t stretch itself to fit its container, each view’s background color will just end up occupying the size of the text itself.</p><p>Thankfully, this is another problem that can easily be solved using the <code>frame</code> modifier in combination with the <code>CGFloat.infinity</code> constant that we also used above when creating the <code>GridItem</code> values representing our columns. By inserting such a modifier before rendering our background, we can now make our grid look much nicer:</p><pre data-preview=\"grid-fixed\"><code><span class=\"s-keyword\">struct</span> CategoryGrid: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> categories: [<span class=\"s-type\">Category</span>]\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">LazyVGrid</span>(columns: columns) {\n            <span class=\"s-type\">ForEach</span>(categories) { category <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Text</span>(category.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">padding</span>()\n                    .<span class=\"s-call\">frame</span>(maxWidth: .<span class=\"s-dotAccess\">infinity</span>)\n                    .<span class=\"s-call\">background</span>(category.<span class=\"s-property\">color</span>)\n                    .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                    .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n            }\n        }\n        .<span class=\"s-call\">padding</span>()\n    }\n\n    ...\n}</code></pre><p class=\"info\">Once again, you can use the <code>PREVIEW</code> button to see what the above code sample looks like when rendered.</p><p>So applying the <code>frame</code> modifier with either an infinite max width or max height can be a great way to tell a given SwiftUI view to stretch itself to fill all available space on either the horizontal or vertical axis.</p><p>Let’s take a look at another example, in which we’ve built an <code>InfoView</code> that can be used to display a piece of information text along with a title. Our intent is for these info views to always be displayed across the entire width of the screen (minus some padding), which they most likely will on iPhones running in portrait orientation, but in landscape (or on iPads) there might not be enough text to cover the entire width of the screen:</p><pre data-preview=\"info-view-initial\"><code><span class=\"s-keyword\">struct</span> InfoView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> text: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span>(alignment: .<span class=\"s-dotAccess\">top</span>, spacing: <span class=\"s-number\">15</span>) {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"info.circle\"</span>)\n            <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>, spacing: <span class=\"s-number\">10</span>) {\n                <span class=\"s-type\">Text</span>(title).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">headline</span>)\n                <span class=\"s-type\">Text</span>(text)\n            }\n        }\n        .<span class=\"s-call\">padding</span>()\n        .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n        .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n        .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">20</span>)\n    }\n}</code></pre><p>One way to fix that problem would be to use a <code>Spacer</code> to <a href=\"https://www.swiftbysundell.com/clips/3\">fill out the remaining horizontal space</a> — which would effectively make our <code>InfoView</code> always render across the full width of its container. However, while spacers are truly an essential part of <a href=\"https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1\">SwiftUI’s layout system</a>, in this case, adding a <code>Spacer</code> to our view could actually end up breaking its portrait layout — since spacers always occupy a minimum amount of space by default, and since our <code>HStack</code> applies 15 points of spacing between each of its elements:</p><pre data-preview=\"info-view-with-spacer\"><code><span class=\"s-keyword\">struct</span> InfoView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span>(alignment: .<span class=\"s-dotAccess\">top</span>, spacing: <span class=\"s-number\">15</span>) {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"info.circle\"</span>)\n            <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>, spacing: <span class=\"s-number\">10</span>) {\n                <span class=\"s-type\">Text</span>(title).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">headline</span>)\n                <span class=\"s-type\">Text</span>(text)\n            }\n            <span class=\"s-type\">Spacer</span>()\n        }\n        ...\n    }\n}</code></pre><p class=\"info\">Like the above <code>PREVIEW</code> shows, because of our added <code>Spacer</code>, our text can no longer be rendered across all of our view’s available width.</p><p>This is once again another great use case for the <code>frame</code> modifier, which in this case can sort of act as a spacer if we not only specify <code>infinity</code> as its <code>maxWidth</code>, but also tell it to align its contents according to the leading edge — like this:</p><pre data-preview=\"info-view-fixed\"><code><span class=\"s-keyword\">struct</span> InfoView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span>(alignment: .<span class=\"s-dotAccess\">top</span>, spacing: <span class=\"s-number\">15</span>) {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"info.circle\"</span>)\n            <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>, spacing: <span class=\"s-number\">10</span>) {\n                <span class=\"s-type\">Text</span>(title).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">headline</span>)\n                <span class=\"s-type\">Text</span>(text)\n            }\n            .<span class=\"s-call\">frame</span>(maxWidth: .<span class=\"s-dotAccess\">infinity</span>, alignment: .<span class=\"s-dotAccess\">leading</span>)\n        }\n        ...\n    }\n}</code></pre><p>Note how we need to specify <code>.leading</code> as the alignment for <em>both</em> our <code>VStack</code> and its <code>frame</code> modifier, since the former aligns the stack’s content (or two texts), while the latter aligns the stack itself within its surrounding frame.</p><p>Of course, rather than using <code>.infinity</code> as our <code>maxWidth</code>, we could’ve also opted to specify a fixed value in order to prevent our view from stretching <em>too much</em> on larger devices, such as the iPad. But that’s a decision that’ll ultimately come down to what sort of design that we’re going for when implementing each view.</p>",
      "summary": "How the frame modifier can be used to create resizable views that fill the container they’re rendered in.",
      "date_published": "2021-04-22T16:05:00.000Z"
    },
    {
      "guid": "swiftbysundell/links/-discover-standard-library",
      "url": "https://www.swiftbysundell.com/discover/standard-library",
      "title": "New Discover page: The Standard Library",
      "content_html": "<p>Learn how to make great use of Swift’s standard library and the collections, algorithms, types and functionality that it ships with.</p><p><strong>→ <a href=\"https://www.swiftbysundell.com/discover/standard-library\">Check it out</a></strong></p>",
      "summary": "Learn how to make great use of Swift’s standard library and the collections, algorithms, types and functionality that it ships with.",
      "date_published": "2021-04-16T14:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/95",
      "url": "https://www.swiftbysundell.com/podcast/95",
      "title": "Podcast: “Concurrency orchestration”, with special guest Brent Simmons",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell95.mp3\" type=\"audio/mpeg\"/></audio><p>Brent Simmons returns to the show to discuss multi-threading and concurrency, and how to make good use of tools like Grand Central Dispatch. Also, building NetNewsWire in the open, the current state of SwiftUI, and the type of responsibilities that senior developers typically have.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://nordvpn.com/sundell\">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on, and unlock your video streaming services. Get a massive discount on their two-year plan, and an extra free month, at <a href=\"https://nordvpn.com/sundell\">nordvpn.com/sundell</a>.</li><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Rock-solid continuous integration for your Swift project, which now also supports ad-ons for things like automatic deployment. Go to <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a> to get started for free.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/brentsimmons\">Brent on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://netnewswire.com\">NetNewsWire</a></li><li><a href=\"https://inessential.com\">Brent’s blog: inessential.com</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/53\">The previous episode with Brent</a></li><li><a href=\"https://github.com/Ranchero-Software/NetNewsWire\">NetNewsWire on GitHub</a></li><li><a href=\"https://inessential.com/2021/03/20/how_netnewswire_handles_threading\">How NetNewsWire Handles Threading</a></li><li><a href=\"https://www.swiftbysundell.com/basics/grand-central-dispatch\">Basics: Grand Central Dispatch</a></li><li><a href=\"https://www.swiftbysundell.com/articles/a-deep-dive-into-grand-central-dispatch-in-swift\">Using the more advanced features of Grand Central Dispatch</a></li><li><a href=\"https://developer.apple.com/documentation/foundation/operationqueue\">OperationQueue</a></li><li><a href=\"https://www.swiftbysundell.com/articles/pure-functions-in-swift\">Pure functions</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Brent Simmons returns to the show to discuss multi-threading and concurrency, and how to make good use of tools like Grand Central Dispatch. Also, building NetNewsWire in the open, the current state of SwiftUI, and the type of responsibilities that senior developers typically have.",
      "date_published": "2021-04-15T19:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/styled-localized-strings-in-swift",
      "url": "https://www.swiftbysundell.com/articles/styled-localized-strings-in-swift",
      "title": "Styling localized strings in Swift",
      "content_html": "<p>Localizing an app into multiple languages can often significantly boost its chances for success on the App Store, as many users tend to prefer using apps that support their own, native language.</p><p>However, while Apple does provide many APIs and other kinds of infrastructure for handling resources like localized strings, things can often get quite tricky if we want to incorporate some form of mixed styling into the strings that we render within our apps.</p><p>For example, let’s say that we’re working on an app that shows lists of new movies, and that we’d like to emphasize the word “New” within the title of one of our UIs. If our app wasn’t localized, then doing so would be quite straightforward — we could simply search the title string for that particular word and then treat it differently when rendering its label — but what if our app does indeed support multiple languages?</p><p>One approach on how to handle that type of situation would be to mark what part of each string that we wish to emphasize within our localized string files — like this:</p><pre class=\"splash\"><code><span class=\"s-comment\">// English</span>\n<span class=\"s-string\">\"NewMovies\"</span> = <span class=\"s-string\">\"**New** movies\"</span>;\n\n<span class=\"s-comment\">// Swedish</span>\n<span class=\"s-string\">\"NewMovies\"</span> = <span class=\"s-string\">\"**Nya** filmer\"</span>;\n\n<span class=\"s-comment\">// Polish</span>\n<span class=\"s-string\">\"NewMovies\"</span> = <span class=\"s-string\">\"**Nowe** filmy\"</span>;</code></pre><p class=\"info\">Looking at the above example, it might seem like another option could be to simply emphasize the first word within each string. However, that would be a quite fragile solution, since not all languages use the same word order, and what if we’d add some form of prefix to our strings in the future?</p><p>Next, we’re going to have to parse the above string format in order to turn each piece of text into either an <code>NSAttributedString</code> (for UIKIt-based UIs), or a SwiftUI <code>Text</code> instance.</p><p>To get started, let’s define a dedicated <code>LocalizedString</code> type, in which we’ll be able to implement all of the required logic. Initially, we could implement APIs for initializing an instance with a localized string key, as well as for resolving a raw <code>String</code> using the built-in <code>NSLocalizedString</code> function:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> LocalizedString {\n    <span class=\"s-keyword\">var</span> key: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">init</span>(<span class=\"s-keyword\">_</span> key: <span class=\"s-type\">String</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">key</span> = key\n    }\n\n    <span class=\"s-keyword\">func</span> resolve() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-type\">NSLocalizedString</span>(key, comment: <span class=\"s-string\">\"\"</span>)\n    }\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">LocalizedString</span>: <span class=\"s-type\">ExpressibleByStringLiteral</span> {\n    <span class=\"s-keyword\">init</span>(stringLiteral value: <span class=\"s-type\">StringLiteralType</span>) {\n        key = value\n    }\n}</code></pre><p class=\"info\">We also make it possible to express a <code>LocalizedString</code> value using a string literal, which will come very much in handy once we start to integrate our new type with both UIKit and SwiftUI.</p><p>With the above type in place, let’s now move on to our actual parsing and rendering, starting with <code>NSAttributedString</code>.</p><h2>Attributed strings</h2><p>Like the name of the type implies, an <code>NSAttributedString</code> enables us to add rendering attributes to a plain <code>String</code>, which in this case make it possible for us to encode that certain parts of a given localized string should be emphasized.</p><p>To make that happen, let’s extend our <code>LocalizedString</code> type with a method that splits a given raw localized string into components using our chosen marker (<code>**</code>, Markdown-style), and then picks either a default or bold font depending on whether the index of a given component is even or odd:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LocalizedString</span> {\n    <span class=\"s-keyword\">typealias</span> Fonts = (default: <span class=\"s-type\">UIFont</span>, bold: <span class=\"s-type\">UIFont</span>)\n\n    <span class=\"s-keyword\">static func</span> defaultFonts() -&gt; <span class=\"s-type\">Fonts</span> {\n        <span class=\"s-keyword\">let</span> font = <span class=\"s-type\">UIFont</span>.<span class=\"s-call\">preferredFont</span>(forTextStyle: .<span class=\"s-dotAccess\">body</span>)\n        <span class=\"s-keyword\">return</span> (font, .<span class=\"s-dotAccess\">boldSystemFont</span>(ofSize: font.<span class=\"s-property\">pointSize</span>))\n    }\n\n    <span class=\"s-keyword\">func</span> attributedString(\n        withFonts fonts: <span class=\"s-type\">Fonts</span> = <span class=\"s-call\">defaultFonts</span>()\n    ) -&gt; <span class=\"s-type\">NSAttributedString</span> {\n        <span class=\"s-keyword\">let</span> components = <span class=\"s-call\">resolve</span>().<span class=\"s-call\">components</span>(separatedBy: <span class=\"s-string\">\"**\"</span>)\n        <span class=\"s-keyword\">let</span> sequence = components.<span class=\"s-call\">enumerated</span>()\n        <span class=\"s-keyword\">let</span> attributedString = <span class=\"s-type\">NSMutableAttributedString</span>()\n\n        <span class=\"s-keyword\">return</span> sequence.<span class=\"s-call\">reduce</span>(into: attributedString) { string, pair <span class=\"s-keyword\">in\n            let</span> isBold = !pair.<span class=\"s-property\">offset</span>.<span class=\"s-call\">isMultiple</span>(of: <span class=\"s-number\">2</span>)\n            <span class=\"s-keyword\">let</span> font = isBold ? fonts.<span class=\"s-property\">bold</span> : fonts.<span class=\"s-property\">default</span>\n\n            string.<span class=\"s-call\">append</span>(<span class=\"s-type\">NSAttributedString</span>(\n                string: pair.<span class=\"s-property\">element</span>,\n                attributes: [.<span class=\"s-dotAccess\">font</span>: font]\n            ))\n        }\n    }\n}</code></pre><p class=\"info\">To learn more about the above use of tuples to define lightweight types, <a href=\"https://www.swiftbysundell.com/articles/using-tuples-as-lightweight-types-in-swift\">check out this article</a>.</p><p>Using the above new API, we’ll now be able to render localized strings with mixed styling using UIKit classes like <code>UILabel</code> and <code>UITextView</code>, which both support attributed strings.</p><p>Now, before we continue by implementing a SwiftUI equivalent of the above functionality, let’s take a quick moment to refactor our actual string parsing and rendering logic into a reusable utility that we’ll be able to call from both implementations, as to avoid code duplication.</p><p>One way to do that would be to implement a generic, <code>reduce</code>-style rendering function that takes an initial result, as well as a handler that performs the actual string concatenation — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">LocalizedString</span> {\n    <span class=\"s-keyword\">func</span> render&lt;T&gt;(\n        into initialResult: <span class=\"s-type\">T</span>,\n        handler: (<span class=\"s-keyword\">inout</span> <span class=\"s-type\">T</span>, <span class=\"s-type\">String</span>, <span class=\"s-keyword\">_</span> isBold: <span class=\"s-type\">Bool</span>) -&gt; <span class=\"s-type\">Void</span>\n    ) -&gt; <span class=\"s-type\">T</span> {\n        <span class=\"s-keyword\">let</span> components = <span class=\"s-call\">resolve</span>().<span class=\"s-call\">components</span>(separatedBy: <span class=\"s-string\">\"**\"</span>)\n        <span class=\"s-keyword\">let</span> sequence = components.<span class=\"s-call\">enumerated</span>()\n\n        <span class=\"s-keyword\">return</span> sequence.<span class=\"s-call\">reduce</span>(into: initialResult) { result, pair <span class=\"s-keyword\">in\n            let</span> isBold = !pair.<span class=\"s-property\">offset</span>.<span class=\"s-call\">isMultiple</span>(of: <span class=\"s-number\">2</span>)\n            <span class=\"s-call\">handler</span>(&amp;result, pair.<span class=\"s-property\">element</span>, isBold)\n        }\n    }\n}</code></pre><p>With the above in place, we can heavily simplify our <code>NSAttributedString</code>-based method from before, since it can now be focused on just annotating and combining the strings that were passed into its <code>handler</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LocalizedString</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> attributedString(\n        withFonts fonts: <span class=\"s-type\">Fonts</span> = <span class=\"s-call\">defaultFonts</span>()\n    ) -&gt; <span class=\"s-type\">NSAttributedString</span> {\n        <span class=\"s-call\">render</span>(\n            into: <span class=\"s-type\">NSMutableAttributedString</span>(),\n            handler: { fullString, string, isBold <span class=\"s-keyword\">in\n                let</span> font = isBold ? fonts.<span class=\"s-property\">bold</span> : fonts.<span class=\"s-property\">default</span>\n\n                fullString.<span class=\"s-call\">append</span>(<span class=\"s-type\">NSAttributedString</span>(\n                    string: string,\n                    attributes: [.<span class=\"s-dotAccess\">font</span>: font]\n                ))\n            }\n        )\n    }\n}</code></pre><p>With that little refactoring task finished, let’s now start implementing our SwiftUI-based string rendering.</p><h2>SwiftUI texts</h2><p>One somewhat “hidden” feature of SwiftUI’s <code>Text</code> type is that multiple text values can be directly <a href=\"https://www.swiftbysundell.com/questions/swiftui-text-mixed-styles\">concatenated using the add operator</a>, just as if they were raw <code>String</code> values — which still preserves the styling of each individual instance.</p><p>So all that we have to do to add a SwiftUI-based rendering API to our <code>LocalizedString</code> type is to call our new <code>render</code> method, and to then combine each of strings that it gives us — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LocalizedString</span> {\n    <span class=\"s-keyword\">func</span> styledText() -&gt; <span class=\"s-type\">Text</span> {\n        <span class=\"s-call\">render</span>(into: <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"\"</span>)) { fullText, string, isBold <span class=\"s-keyword\">in\n            var</span> text = <span class=\"s-type\">Text</span>(string)\n\n            <span class=\"s-keyword\">if</span> isBold {\n                text = text.<span class=\"s-call\">bold</span>()\n            }\n\n            fullText = fullText + text\n        }\n    }\n}</code></pre><h2>Time to integrate</h2><p>Next, to make both our UIKit and SwiftUI-based methods a bit easier to use, let’s also extend both <code>UILabel</code> and <code>Text</code> with convenience APIs that let us directly initialize a label using a <code>LocalizedString</code> value:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">UILabel</span> {\n    <span class=\"s-keyword\">convenience init</span>(styledLocalizedString string: <span class=\"s-type\">LocalizedString</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(frame: .<span class=\"s-dotAccess\">zero</span>)\n        attributedText = string.<span class=\"s-call\">attributedString</span>()\n    }\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Text</span> {\n    <span class=\"s-keyword\">init</span>(styledLocalizedString string: <span class=\"s-type\">LocalizedString</span>) {\n        <span class=\"s-keyword\">self</span> = string.<span class=\"s-call\">styledText</span>()\n    }\n}</code></pre><p>With the above in place, we can now use the fact that <code>LocalizedString</code> values can be expressed using string literals to create styled, localized labels using either SwiftUI or UIKit, simply by doing this:</p><pre class=\"splash\"><code><span class=\"s-comment\">// UIKit</span>\n<span class=\"s-type\">UILabel</span>(styledLocalizedString: <span class=\"s-string\">\"NewMovies\"</span>)\n\n<span class=\"s-comment\">// SwiftUI</span>\n<span class=\"s-type\">Text</span>(styledLocalizedString: <span class=\"s-string\">\"NewMovies\"</span>)</code></pre><p>Very nice! However, currently we’re always re-parsing each string every time that it’s requested, which might not be an issue if we’re not updating our UI too often, but let’s also explore how we could add caching to our implementation as well.</p><h2>Caching</h2><p>Since all of the strings that we’re parsing are loaded from a static resource (our localized strings file for the user’s current language), we should be able to cache them quite aggressively. One way to do that would be to use the <code>Cache</code> type that we built in <a href=\"https://www.swiftbysundell.com/articles/caching-in-swift\">“Caching in Swift”</a>, and to then modify our <code>render</code> function so that it supports reading and writing from such a cache — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">LocalizedString</span> {\n    <span class=\"s-keyword\">static let</span> attributedStringCache = <span class=\"s-type\">Cache</span>&lt;<span class=\"s-type\">String</span>, <span class=\"s-type\">NSMutableAttributedString</span>&gt;()\n    <span class=\"s-keyword\">static let</span> swiftUITextCache = <span class=\"s-type\">Cache</span>&lt;<span class=\"s-type\">String</span>, <span class=\"s-type\">Text</span>&gt;()\n\n    <span class=\"s-keyword\">func</span> render&lt;T&gt;(\n        into initialResult: <span class=\"s-keyword\">@autoclosure</span> () -&gt; <span class=\"s-type\">T</span>,\n        cache: <span class=\"s-type\">Cache</span>&lt;<span class=\"s-type\">String</span>, <span class=\"s-type\">T</span>&gt;,\n        handler: (<span class=\"s-keyword\">inout</span> <span class=\"s-type\">T</span>, <span class=\"s-type\">String</span>, <span class=\"s-keyword\">_</span> isBold: <span class=\"s-type\">Bool</span>) -&gt; <span class=\"s-type\">Void</span>\n    ) -&gt; <span class=\"s-type\">T</span> {\n        <span class=\"s-keyword\">if let</span> cached = cache.<span class=\"s-call\">value</span>(forKey: key) {\n            <span class=\"s-keyword\">return</span> cached\n        }\n\n        <span class=\"s-keyword\">let</span> components = <span class=\"s-call\">resolve</span>().<span class=\"s-call\">components</span>(separatedBy: <span class=\"s-string\">\"**\"</span>)\n        <span class=\"s-keyword\">let</span> sequence = components.<span class=\"s-call\">enumerated</span>()\n\n        <span class=\"s-keyword\">let</span> result = sequence.<span class=\"s-call\">reduce</span>(into: <span class=\"s-call\">initialResult</span>()) { result, pair <span class=\"s-keyword\">in\n            let</span> isBold = !pair.<span class=\"s-property\">offset</span>.<span class=\"s-call\">isMultiple</span>(of: <span class=\"s-number\">2</span>)\n            <span class=\"s-call\">handler</span>(&amp;result, pair.<span class=\"s-property\">element</span>, isBold)\n        }\n\n        cache.<span class=\"s-call\">insert</span>(result, forKey: key)\n        <span class=\"s-keyword\">return</span> result\n    }\n}</code></pre><p class=\"info\">The reason we now mark our <code>initialResult</code> parameter with the <code>@autoclosure</code> attribute is to prevent it from being evaluated in case a cached value was found. To learn more, <a href=\"https://www.swiftbysundell.com/articles/using-autoclosure-when-designing-swift-apis\">check out this article</a>.</p><p>Note that our <code>attributedStringCache</code> stores <code>NSMutableAttributedString</code> instances, which is because that’s the type that we’re working with when calling <code>render</code> from our <code>attributedString</code> method. While there’s no real harm in using such mutable instances internally within our <code>LocalizedString</code> type, we should now definitely copy all attributed strings before returning them, as to prevent any accidental sharing of mutable state.</p><p>So let’s do that, while also updating both of our string rendering methods to support our new caching functionality:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LocalizedString</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> attributedString(\n        withFonts fonts: <span class=\"s-type\">Fonts</span> = <span class=\"s-call\">defaultFonts</span>()\n    ) -&gt; <span class=\"s-type\">NSAttributedString</span> {\n        <span class=\"s-keyword\">let</span> string = <span class=\"s-call\">render</span>(\n            into: <span class=\"s-type\">NSMutableAttributedString</span>(),\n            cache: <span class=\"s-type\">Self</span>.<span class=\"s-property\">attributedStringCache</span>,\n            handler: { fullString, string, isBold <span class=\"s-keyword\">in</span>\n                ...\n            }\n        )\n\n        <span class=\"s-keyword\">return</span> <span class=\"s-type\">NSAttributedString</span>(attributedString: string)\n    }\n\n    <span class=\"s-keyword\">func</span> styledText() -&gt; <span class=\"s-type\">Text</span> {\n        <span class=\"s-call\">render</span>(\n            into: <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"\"</span>),\n            cache: <span class=\"s-type\">Self</span>.<span class=\"s-property\">swiftUITextCache</span>,\n            handler: { fullText, string, isBold <span class=\"s-keyword\">in</span>\n                ...\n            }\n        )\n    }\n}</code></pre><p>And with that final piece in place, our new <code>LocalizedString</code> API is finished, and we can now render fully localized, styled strings in a performant and predictable manner, using either SwiftUI or UIKit.</p><h2>Supporting multiple styles, and HTML as an alternative</h2><p>Of course, the system that we built in this article currently only supports turning parts of a string bold, but we could always continue iterating on it in case we wanted to add support for multiple kinds of styles, although that might require somewhat more sophisticated string parsing techniques.</p><p>For example, we could either use the <a href=\"https://github.com/johnsundell/sweep\">open source Sweep library</a> to identify ranges that should be styled with a given set of attributes, or use techniques like the ones that were covered in <a href=\"https://www.swiftbysundell.com/articles/string-parsing-in-swift\">“String parsing in Swift”</a> to make that happen.</p><p>Another option, which has its own set of tradeoffs, would be to render certain strings as HTML, which <code>NSAttributedString</code> actually has complete support for. That way, we could place any sort of HTML styles (such as <code>&lt;b&gt;</code> or <code>&lt;em&gt;</code>) within our localized strings and then turn them into fully renderable attributed strings like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LocalizedString</span> {\n    <span class=\"s-keyword\">func</span> attributedString() <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">NSAttributedString</span> {\n        <span class=\"s-keyword\">let</span> data = <span class=\"s-type\">Data</span>(<span class=\"s-call\">resolve</span>().<span class=\"s-property\">utf8</span>)\n\n        <span class=\"s-keyword\">return try</span> <span class=\"s-type\">NSAttributedString</span>(\n            data: data,\n            options: [\n                .<span class=\"s-dotAccess\">documentType</span>: <span class=\"s-type\">NSAttributedString</span>.<span class=\"s-type\">DocumentType</span>.<span class=\"s-property\">html</span>,\n                .<span class=\"s-dotAccess\">characterEncoding</span>: <span class=\"s-type\">String</span>.<span class=\"s-type\">Encoding</span>.<span class=\"s-property\">utf8</span>.<span class=\"s-property\">rawValue</span>\n            ],\n            documentAttributes: <span class=\"s-keyword\">nil</span>\n        )\n    }\n}</code></pre><p>However, one big downside of the above technique is that it requires our localized string files to contain HTML code (which could easily get malformed as multiple people, including external translators, might edit those files over time). Also, since we would be rendering those strings as if they were web clips, we’d then also have to style each such label using web technologies as well, which could quickly make our setup quite complex and hard to maintain.</p><h2>Conclusion</h2><p>Combining localization with dynamically rendered content or styles can at times be quite difficult — even something relatively simple as emphasizing parts of a given string can require a fair bit of code to implement. Hopefully this article has shown you a few tips and tricks on how that can be done, and perhaps the techniques covered can provide a starting point for building your own system for rendering styled, localized strings.</p><p>If you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "How to render localized strings that contain mixed styling using either UIKit or SwiftUI.",
      "date_published": "2021-04-13T15:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/mobile-apps-at-scale-april-2021",
      "url": "https://www.swiftbysundell.com/sponsor/mobile-apps-at-scale-april-2021",
      "title": "Sponsor: Building Mobile Apps at Scale",
      "content_html": "<p>Thanks a lot to Gergely Orosz for sponsoring Swift by Sundell last week to promote his new book ‌<em>Building Mobile Apps at Scale 39: Engineering Challenges</em>. The book is completely free to download until May 31st, so I really recommend <a href=\"https://go.mobileatscale.com/swift-by-sundell\">grabbing your copy before then</a>.</p><p>Based on his own experience of scaling the development of the Uber iOS app, as well as numerous interviews with mobile developers from across the industry, Gergely’s new book is focused on some of the most major challenges that mobile teams commonly face once their user base, code base, and team all start to grow.</p><p>For example, the book discusses topics like tooling, navigation, continuous integration, app architecture, modularity, and testing — with lots of links to articles and other resources that contain potential solutions to issues that larger teams commonly face (you’ll even find a few Swift by Sundell links within the book as well).</p><p>So if you’re interested in learning more about what’s involved in creating a truly scalable mobile code base, then check out Gergely Orosz’s <em><a href=\"https://go.mobileatscale.com/swift-by-sundell\">Building Mobile Apps at Scale</a></em> book today. You can download the PDF version of book for free until May 31st, and there’s also a paperback edition available for purchase as well.</p>",
      "summary": "Thanks a lot to Gergely Orosz for sponsoring Swift by Sundell last week to promote his new book “Building Mobile Apps at Scale: 39 Engineering Challenges”.",
      "date_published": "2021-04-12T10:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/annotating-properties-with-result-builder-attributes",
      "url": "https://www.swiftbysundell.com/tips/annotating-properties-with-result-builder-attributes",
      "title": "Annotating properties with result builder attributes",
      "content_html": "<p><strong>New in Swift 5.4:</strong> Result builder attributes can now be attached directly to closure-based properties, which can make it much easier to write things like custom SwiftUI containers, and other code that utilizes Swift’s <a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">result builders feature</a>.</p><p>Let’s start by taking a look at an example from <a href=\"https://www.swiftbysundell.com/tips/creating-custom-swiftui-container-views\">“Creating custom SwiftUI container views”</a>, in which we’ve built our own SwiftUI container view that renders a horizontal stack of subviews within a <code>ScrollView</code>.</p><p>Since we want to be able to use the full power of <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api\">SwiftUI’s DSL</a> when creating instances of that container view, we’ve given it an initializer that takes a closure marked with SwiftUI’s <code>@ViewBuilder</code> attribute, which in turn lets us use it the exact same way as we’d use the built-in containers that SwiftUI ships with:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Carousel&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> content: () -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">init</span>(<span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Content</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">content</span> = content\n    }\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span>(.<span class=\"s-dotAccess\">horizontal</span>) {\n            <span class=\"s-type\">HStack</span>(content: content).<span class=\"s-call\">padding</span>()\n        }\n    }\n}</code></pre><p>Starting in Swift 5.4, though, we no longer need that explicit initializer, and can instead directly mark our <code>content</code> property itself with the <code>@ViewBuilder</code> attribute — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Carousel&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ViewBuilder var</span> content: () -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span>(.<span class=\"s-dotAccess\">horizontal</span>) {\n            <span class=\"s-type\">HStack</span>(content: content).<span class=\"s-call\">padding</span>()\n        }\n    }\n}</code></pre><p>Really nice! Even with the above change in place, we can keep using our <code>Carousel</code> view just like before, thanks to Swift’s <a href=\"https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used\">memberwise initializers feature</a>.</p><p>This change also applies to any custom result builders that we’ve defined as well. For example, in <a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">“A deep dive into Swift’s result builders”</a>, we built a <code>SettingsGroup</code> type using a custom result builder called <code>SettingsBuilder</code>. Before Swift 5.4, we’d once again have to manually implement that type’s initializer in order to be able to use our result builder within its <code>settings</code> closure:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SettingsGroup {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> settings: () -&gt; [<span class=\"s-type\">Setting</span>]\n\n    <span class=\"s-keyword\">init</span>(name: <span class=\"s-type\">String</span>,\n         <span class=\"s-keyword\">@SettingsBuilder</span> settings: () -&gt; [<span class=\"s-type\">Setting</span>]) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">name</span> = name\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">settings</span> = settings\n    }\n}</code></pre><p>But now we can refactor the above type to instead simply look like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SettingsGroup {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">@SettingsBuilder var</span> settings: () -&gt; [<span class=\"s-type\">Setting</span>]\n}</code></pre><p>Granted, this is a very small change in the grand scheme of things, but a very welcome one if you ask me. Also, the fact that result builder attributes now behave the same way that <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">property wrapper ones do</a> is definitely a big win in terms of consistency.</p>",
      "summary": "Starting in Swift 5.4, result builder attributes can now be attached directly to closure-based properties. Let’s take a look at how that new feature can be used.",
      "date_published": "2021-04-07T12:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/stream-april-2021",
      "url": "https://www.swiftbysundell.com/sponsor/stream-april-2021",
      "title": "Sponsor: Stream",
      "content_html": "<p>My thanks to <a href=\"https://getstream.io/chat/sdk/ios/?utm_medium=promotion_podcast&utm_source=swiftbysundell\">Stream</a> for sponsoring Swift by Sundell last week. Stream is an open source SDK that makes it easy to add social features, like messaging and activity feeds, to your iOS, Android, or web app.</p><p>Not only can Stream help you implement such social features much quicker than if you were to build them completely from scratch, but all of the tools that they provide are also backed by enterprise-grade server infrastructure that scales smoothly based on your app’s needs.</p><p>Of course, Stream fully supports all of the main features that users have come to expect from modern social experiences — such as the ability to react to and comment on posts, share images and other files, threaded conversations, both AI-powered and manual moderation, and much more.</p><p>So if you’re planning to add social features to either a new or existing application, then I really recommend <a href=\"https://getstream.io/chat/sdk/ios/?utm_medium=promotion_podcast&utm_source=swiftbysundell\">checking out Stream</a> before taking on the huge amount of work that’s required to build those kinds of features from scratch. It’s completely free to get started, plus, if you use <a href=\"https://getstream.io/chat/sdk/ios/?utm_medium=promotion_podcast&utm_source=swiftbysundell\">this link</a> to check out Stream, then you’ll also directly support Swift by Sundell in the process.</p>",
      "summary": "Thanks a lot to Stream for sponsoring Swift by Sundell.",
      "date_published": "2021-04-05T13:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/exploring-some-of-the-lesser-known-formatter-types",
      "url": "https://www.swiftbysundell.com/articles/exploring-some-of-the-lesser-known-formatter-types",
      "title": "Exploring some of the lesser-known, built-in Formatter types",
      "content_html": "<p>Generating formatted string representations of various kinds of values can often be quite tricky, especially if we want those strings to be fully adapted to the user’s language, locale and other system-wide preferences.</p><p>Thankfully, Apple ships a quite comprehensive suite of fully localized formatters as part of each of their platforms, and while we’ve already taken a look at the most commonly used among those — like <a href=\"https://www.swiftbysundell.com/tips/statically-computed-default-property-values\"><code>DateFormatter</code></a> and <a href=\"https://www.swiftbysundell.com/articles/formatting-numbers-in-swift\"><code>NumberFormatter</code></a> — in this article, let’s instead explore some of the <em>lesser-known</em> <code>Formatter</code> subclasses, and how they can prove to be incredibly useful in certain situations.</p><h2>Names of people</h2><p>If there’s one thing that all <code>Formatter</code> types that come built into the system have in common is that they’re all performing tasks that are much more complicated than what they initially might seem like.</p><p>Take user names, or names of people in general, as an example. Let’s say that we’re working on an app that stores each user’s full name using a single <code>fullName</code> property defined within a <code>User</code> data model — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> User {\n    <span class=\"s-keyword\">var</span> fullName: <span class=\"s-type\">String</span>\n    ...\n}</code></pre><p>Then, let’s say that we’re currently making the assumption that if we split a given user’s <code>fullName</code> string into space-separated components, then the first component will always be the user’s “first name” — which we then use as that user’s “display name” across our app’s UI:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">User</span> {\n    <span class=\"s-keyword\">func</span> displayName() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-type\">String</span>(fullName.<span class=\"s-call\">split</span>(separator: <span class=\"s-string\">\" \"</span>)[<span class=\"s-number\">0</span>])\n    }\n}</code></pre><p>The above is an incredibly common mistake to make. Not only does the preferred order of a name’s various components differ between different languages, countries, and cultures around the world — names can also often have many more components than just “first name” and “last name”, which our code currently doesn’t account for.</p><p>For example, what if a user entered “Dr. John Appleseed” as their full name? Then that user’s display name would currently be computed as “Dr.”. Not great.</p><p>Thankfully, this is a problem that our friends at Apple have already solved. Enter <code>PersonNameComponentsFormatter</code>, which handles all of the complexities involved in correctly parsing and formatting a person’s name. Here’s how we could update our <code>displayName</code> method to use that formatter instead:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">User</span> {\n    <span class=\"s-keyword\">func</span> displayName() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">PersonNameComponentsFormatter</span>()\n        <span class=\"s-keyword\">let</span> components = formatter.<span class=\"s-call\">personNameComponents</span>(from: fullName)\n        <span class=\"s-keyword\">return</span> components?.<span class=\"s-property\">givenName</span> ?? name\n    }\n}</code></pre><p>Not only will the above new version yield results that are much more correct regardless of the user’s name or locale, but the intent of our code is now arguably much more clear as well.</p><p><code>PersonNameComponentsFormatter</code> also enables us to turn a set of name components into a fully localized name as well, which can be incredibly useful when dealing with user names that are already split up into separate components — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> User {\n    <span class=\"s-keyword\">var</span> firstName: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> lastName: <span class=\"s-type\">String</span>\n    ...\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">User</span> {\n    <span class=\"s-keyword\">func</span> fullName() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">PersonNameComponentsFormatter</span>()\n\n        <span class=\"s-keyword\">var</span> components = <span class=\"s-type\">PersonNameComponents</span>()\n        components.<span class=\"s-property\">givenName</span> = firstName\n        components.<span class=\"s-property\">familyName</span> = lastName\n\n        <span class=\"s-keyword\">return</span> formatter.<span class=\"s-call\">string</span>(from: components)\n    }\n}</code></pre><p class=\"info\">The reason that we’ve implemented all of our name computation code as methods, rather than computed properties, is to clearly show that our logic requires some amount of processing, since it’s not just returning a value that can be computed in <code>O(1)</code> time. To learn more about that approach, check out <a href=\"https://www.swiftbysundell.com/articles/computed-properties-in-swift\">“Computed properties in Swift”</a>.</p><h2>Addresses</h2><p>Next, let’s take a look at a <code>Formatter</code> type that ships as part of the <code>Contacts</code> framework — <code>CNPostalAddressFormatter</code>, which provides an easy way to format addresses into localized strings.</p><p>Just like names, the way addresses are supposed to be formatted varies a lot between different countries, and handling all of that complexity ourselves would be quite overwhelming.</p><p>As an example, let’s say that we’re working on some form of shopping app that contains the following <code>ShippingAddress</code> type:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ShippingAddress {\n    <span class=\"s-keyword\">var</span> street: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> postalCode: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> city: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> country: <span class=\"s-type\">String</span>\n}</code></pre><p>If we now wanted to generate a formatted string representation of such an address (for example to show the user what address that a given product will be shipped to), then all that we have to do is to convert our shipping address data into a <code>CNPostalAddress</code> instance (which can be done using its mutable counterpart, <code>CNMutablePostalAddress</code>), and then ask <code>CNPostalAddressFormatter</code> to convert that instance into a string — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">import</span> Contacts\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">ShippingAddress</span> {\n    <span class=\"s-keyword\">func</span> formattedString() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">CNPostalAddressFormatter</span>()\n\n        <span class=\"s-keyword\">let</span> address = <span class=\"s-type\">CNMutablePostalAddress</span>()\n        address.<span class=\"s-property\">street</span> = street\n        address.<span class=\"s-property\">postalCode</span> = postalCode\n        address.<span class=\"s-property\">city</span> = city\n        address.<span class=\"s-property\">country</span> = country\n\n        <span class=\"s-keyword\">return</span> formatter.<span class=\"s-call\">string</span>(from: address)\n    }\n}</code></pre><p>Of course, if we’re dealing with addresses retrieved using the <code>Contacts</code> framework itself, then those will already be represented using <code>CNPostalAddress</code> instances, so the above type conversion is only necessary when working with a custom way of storing addresses.</p><h2>Relative time</h2><p>Although the standard <code>DateFormatter</code> type is quite well-known and commonly used within all sorts of applications, it also has a somewhat lesser-known “cousin” called <code>RelativeDateTimeFormatter</code> which can be used to generate localized strings that describe the relative time interval between two dates.</p><p>For example, here’s how we could use that specialized formatter to compute a string that tells the user how much time that’s left until a given <code>Event</code> starts:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Event {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> startDate: <span class=\"s-type\">Date</span>\n    ...\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Event</span> {\n    <span class=\"s-keyword\">func</span> relativeTimeString() -&gt; <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">RelativeDateTimeFormatter</span>()\n        formatter.<span class=\"s-property\">dateTimeStyle</span> = .<span class=\"s-dotAccess\">named</span>\n        formatter.<span class=\"s-property\">formattingContext</span> = .<span class=\"s-dotAccess\">beginningOfSentence</span>\n        <span class=\"s-keyword\">return</span> formatter.<span class=\"s-call\">localizedString</span>(for: startDate, relativeTo: <span class=\"s-type\">Date</span>())\n    }\n}</code></pre><p>What’s really cool is that by specifying that we want to use the <code>named</code> date time style (like we do above), words like “Tomorrow” and “Yesterday” will be used to describe intervals that have specific names.</p><h2>Lists</h2><p>Finally, let’s take a quick look at <code>ListFormatter</code>, which perhaps isn’t as complex as some of the other formatters that we’ve explored so far, but it can still be useful in certain situations.</p><p>Essentially, <code>ListFormatter</code> enables us to concatenate an array of strings into a single, localized list-like string. Using it is as easy as passing the array of strings that we wish to join to its static <code>localizedString</code> method, and it’ll then return a formatted string based on the user’s locale and language settings:</p><pre class=\"splash\"><code><span class=\"s-comment\">// In English:</span>\n\n<span class=\"s-keyword\">let</span> ingredientsList = <span class=\"s-type\">ListFormatter</span>.<span class=\"s-call\">localizedString</span>(\n    byJoining: [<span class=\"s-string\">\"Apples\"</span>, <span class=\"s-string\">\"Sugar\"</span>, <span class=\"s-string\">\"Flour\"</span>, <span class=\"s-string\">\"Butter\"</span>]\n)\n\n<span class=\"s-call\">print</span>(ingredientsList) <span class=\"s-comment\">// \"Apples, Sugar, Flour, and Butter\"\n\n// In Swedish:</span>\n\n<span class=\"s-keyword\">let</span> ingredientsList = <span class=\"s-type\">ListFormatter</span>.<span class=\"s-call\">localizedString</span>(\n    byJoining: [<span class=\"s-string\">\"Äpplen\"</span>, <span class=\"s-string\">\"Socker\"</span>, <span class=\"s-string\">\"Mjöl\"</span>, <span class=\"s-string\">\"Smör\"</span>]\n)\n\n<span class=\"s-call\">print</span>(ingredientsList) <span class=\"s-comment\">// \"Äpplen, Socker, Mjöl och Smör\"</span></code></pre><p>Note how the English and Swedish versions doesn’t just differ in terms of language, but also in how commas are used. Those kinds of details might seem insignificant, but can really make an app feel much more thoroughly localized — and once again, we didn’t have to write any custom code to account for those variances — it’s all handled for us by the system.</p><h2>Conclusion</h2><p>It’s very clear that Apple’s dedication to high-quality localization isn’t just limited to their own apps and system features — their various platform SDKs also ship with numerous APIs, tools and features that we can use to elevate the localization of our own apps as well. All that we have to do is to use the right APIs when dealing with locale-dependent values — such as names, numbers, addresses and dates.</p><p>Hopefully this article has given you a few insights on how to do just that, and feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a> if you have any questions or comments.</p><p>Thanks for reading!</p>",
      "summary": "Let’s explore some of the lesser-known Formatter subclasses that ship as part of Apple’s platforms, and how those formatters can be really useful in certain situations.",
      "date_published": "2021-04-02T15:10:00.000Z"
    },
    {
      "guid": "swiftbysundell/links/using-instabug-in-a-swiftui-based-ios-app",
      "url": "https://instabug.com/blog/using-instabug-in-a-swiftui-based-ios-app/",
      "title": "Link: Using Instabug in a SwiftUI-based iOS app",
      "content_html": "<p>Earlier this week, I published a guest article on the Instabug blog that shows a few different ways to augment their SDK to make it an even better fit for SwiftUI-based iOS apps.</p><p>So, if you’re already using Instabug, or if you’re planning to use it within a project that uses SwiftUI to some extent, then check out <a href=\"https://instabug.com/blog/using-instabug-in-a-swiftui-based-ios-app/\">my article over on the Instabug blog</a>.</p><p>I hope you’ll find it useful, and feel free to let me know if you have any questions or feedback.</p>",
      "summary": "A guest article that I wrote for the Instabug blog that shows a few different ways to augment their SDK to make it an even better fit for SwiftUI-based iOS apps.",
      "date_published": "2021-04-02T10:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/94",
      "url": "https://www.swiftbysundell.com/podcast/94",
      "title": "Podcast: “A Mac-like Mac app”, with special guest Benedikt Terhechte",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell94.mp3\" type=\"audio/mpeg\"/></audio><p>Benedikt Terhechte returns to the show to discuss the pros and cons of using technologies like Catalyst and SwiftUI to build Mac apps, and also to share tips and tricks on how to use AppKit for use cases that Apple’s more modern frameworks do not yet support.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://getstream.io/sundell\">Stream</a>:</strong> Build scalable in-app chat or activity feeds in record time using Stream’s open source, Swift-native SDK that’s backed by enterprise-grade server infrastructure. Get started for free at <a href=\"https://getstream.io/sundell\">getstream.io/sundell</a>.</li><li><strong><a href=\"https://clubhouse.io/sundell\">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s built specifically for software teams. Try it for free for two months at <a href=\"https://clubhouse.io/sundell\">clubhouse.io/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/terhechte\">Benedikt on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://twitter.com/hyperdeck_io\">Hyperdeck on Twitter</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/21\">The previous episode with Benedikt</a></li><li><a href=\"https://hyperdeck.io\">Hyperdeck</a></li><li><a href=\"https://contravariance.rocks\">The Contravariance podcast</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/mac_catalyst\">Mac Catalyst</a></li><li><a href=\"https://developer.apple.com/documentation/appkit/nsdocument\">NSDocument</a></li><li><a href=\"https://www.swiftbysundell.com/questions/syncing-the-width-or-height-of-two-swiftui-views\">An example of embedding a GeometryReader as a background</a></li><li><a href=\"https://developer.apple.com/documentation/appkit/nsview/1483532-isflipped\">The isFlipped property</a></li><li><a href=\"https://developer.apple.com/documentation/appkit/nsanimatablepropertycontainer/1530511-animator\">The NSView animator API</a></li><li><a href=\"https://developer.apple.com/documentation/foundation/nsproxy\">NSProxy</a></li><li><a href=\"https://developer.apple.com/documentation/appkit/nscollectionview\">NSCollectionView</a></li><li><a href=\"https://github.com/JohnSundell/ShellOut\">Triggering terminal commands from Swift</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Benedikt Terhechte returns to the show to discuss the pros and cons of using technologies like Catalyst and SwiftUI to build Mac apps, and also to share tips and tricks on how to use AppKit for use cases that Apple’s more modern frameworks do not yet support.",
      "date_published": "2021-03-30T18:00:00.000Z"
    },
    {
      "guid": "swiftbysundell/links/-discover-combine",
      "url": "https://www.swiftbysundell.com/discover/combine",
      "title": "New Discover page: Combine",
      "content_html": "<p>Discover how Apple’s Combine framework can be used to model increasingly complex asynchronous operations as reactive pipelines that emit values over time.</p><p><strong>→ <a href=\"https://www.swiftbysundell.com/discover/combine\">Check it out</a></strong></p>",
      "summary": "Discover how Apple’s Combine framework can be used to model increasingly complex asynchronous operations as reactive pipelines that emit values over time.",
      "date_published": "2021-03-26T13:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/using-combine-futures-and-subjects",
      "url": "https://www.swiftbysundell.com/articles/using-combine-futures-and-subjects",
      "title": "Using Combine’s futures and subjects",
      "content_html": "<p>Although Combine is mainly focused around the concept of <em>publishers</em> that emit sequences of values over time, it also includes a set of convenience APIs that enable us to leverage the full power of the framework without necessarily having to write completely <a href=\"https://www.swiftbysundell.com/articles/building-custom-combine-publishers-in-swift\">custom publisher implementations</a> from scratch.</p><p>For example, let’s say that we wanted to add Combine support to an existing, closure-based API — such as this <code>ImageProcessor</code>, which uses the classic completion handler pattern to asynchronously notify its callers when the processing for a given image either finished or failed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ImageProcessor {\n    <span class=\"s-keyword\">func</span> process(\n        <span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>,\n        then handler: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n    ) {\n        <span class=\"s-comment\">// Process the image and call the handler when done</span>\n        ...\n    }\n}</code></pre><p class=\"info\">The above API uses Swift’s built-in <code>Result</code> type to encapsulate either a successfully processed image, or any error that was encountered. To learn more, check out <a href=\"https://www.swiftbysundell.com/basics/result\">this Basics article</a>.</p><p>Now, rather than rewriting our <code>ImageProcessor</code>, let’s actually add a new, Combine-powered API to it in a completely additive way. Not only will that keep all of our existing code intact, but it’ll also let us choose whether to use Combine or a completion handler on a case-by-case basis even as we write new code.</p><h2>Retrofitting with futures</h2><p>To make that happen, let’s use Combine’s <code>Future</code> type, which is an adaptation of the <a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift\">Futures/Promises pattern</a> that’s very commonly used across a wide range of different programming languages. Essentially, a Combine <code>Future</code> gives us a <code>promise</code> closure that we can call when an asynchronous operation was completed, and Combine will then automatically map the <code>Result</code> that we give that closure into proper publisher events.</p><p>What’s really convenient in this case is that our existing completion handler closure already uses a <code>Result</code> type as its input, so all that we have to do within our <code>Future</code>-based implementation is to simply pass the <code>promise</code> closure that Combine gives us into a call to our existing <code>process</code> API — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageProcessor</span> {\n    <span class=\"s-keyword\">func</span> process(<span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>) -&gt; <span class=\"s-type\">Future</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-type\">Future</span> { promise <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">process</span>(image, then: promise)\n        }\n    }\n}</code></pre><p>Just to illustrate, here’s what the above implementation would’ve looked like if we were to instead use a dedicated completion handler closure and then manually pass its result to our <code>promise</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageProcessor</span> {\n    <span class=\"s-keyword\">func</span> process(<span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>) -&gt; <span class=\"s-type\">Future</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-type\">Future</span> { promise <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">process</span>(image) { result <span class=\"s-keyword\">in</span>\n                <span class=\"s-call\">promise</span>(result)\n            }\n        }\n    }\n}</code></pre><p>So the <code>Future</code> type offers a very neat way to convert existing, closure-based APIs into ones that can be used within the reactive world of Combine — and, since those futures are really just publishers like any other, that means that we can use Combine’s entire suite of operators to transform and observe them:</p><pre class=\"splash\"><code>processor.<span class=\"s-call\">process</span>(image)\n    .<span class=\"s-call\">replaceError</span>(with: .<span class=\"s-dotAccess\">errorIcon</span>)\n    .<span class=\"s-call\">map</span> { $0.<span class=\"s-call\">withRenderingMode</span>(.<span class=\"s-dotAccess\">alwaysTemplate</span>) }\n    .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n    .<span class=\"s-call\">assign</span>(to: \\.<span class=\"s-property\">image</span>, on: imageView)\n    .<span class=\"s-call\">store</span>(in: &amp;cancellables)</code></pre><p>However, just like Futures and Promises in general, Combine’s <code>Future</code> type can only emit a single result, as it will immediately complete and get closed down once its <code>promise</code> closure was called.</p><p>So what if we instead wanted to emit multiple values over time, which is really what Combine was mainly designed to do?</p><h2>Handling multiple output values</h2><p>Let’s go back to our closure-based <code>ImageProcessor</code> API from before and imagine that it instead accepted two closures — one that gets called periodically with progress updates as an image is being processed, and one that’s called once the operation was fully completed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ImageProcessor {\n    <span class=\"s-keyword\">typealias</span> CompletionRatio = <span class=\"s-type\">Double</span>\n    <span class=\"s-keyword\">typealias</span> ProgressHandler = (<span class=\"s-type\">CompletionRatio</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">typealias</span> CompletionHandler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">func</span> process(\n        <span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>,\n        onProgress: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">ProgressHandler</span>,\n        onComplete: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">CompletionHandler</span>\n    ) {\n        <span class=\"s-comment\">// Process the image and call the progress handler to\n        // report the operation's ongoing progress, and then\n        // call the completion handler once the image has finished\n        // processing, or if an error was encountered.</span>\n        ...\n    }\n}</code></pre><p class=\"info\">Above we’re using type aliases, both to make our actual method definition a bit easier to read, and to contextualize the <code>Double</code> that gets passed into our <code>ProgressHandler</code>. To learn more, check out <a href=\"https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift\">“The power of type aliases in Swift”</a>.</p><p>Before we start updating our Combine-based extension for the above new API, let’s introduce an enum called <code>ProgressEvent</code>, which we’ll use as the output type for the Combine publishers that we’ll create (since publishers can only emit a single type of values). It’ll include two cases, one for update events, and one for completion events:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageProcessor</span> {\n    <span class=\"s-keyword\">enum</span> ProgressEvent {\n        <span class=\"s-keyword\">case</span> updated(completionRatio: <span class=\"s-type\">CompletionRatio</span>)\n        <span class=\"s-keyword\">case</span> completed(<span class=\"s-type\">UIImage</span>)\n    }\n}</code></pre><p>An initial idea on how to update our Combine API might be to keep using the <code>Future</code> type, just like we did before, but to now call its <code>promise</code> closure multiple times to report both update and completion events — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageProcessor</span> {\n    <span class=\"s-keyword\">func</span> process(<span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>) -&gt; <span class=\"s-type\">Future</span>&lt;<span class=\"s-type\">ProgressEvent</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-type\">Future</span> { promise <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">process</span>(image,\n                onProgress: { ratio <span class=\"s-keyword\">in</span>\n                    <span class=\"s-call\">promise</span>(.<span class=\"s-call\">success</span>(\n                        .<span class=\"s-call\">updated</span>(completionRatio: ratio)\n                    ))\n                },\n                onComplete: { result <span class=\"s-keyword\">in</span>\n                    <span class=\"s-call\">promise</span>(result.<span class=\"s-call\">map</span>(<span class=\"s-type\">ProgressEvent</span>.<span class=\"s-property\">completed</span>))\n                }\n            )\n        }\n    }\n}</code></pre><p>However, the above won’t work, since — as mentioned earlier — Combine futures can only emit a single value, which means that with the above setup, we’ll only receive the very first <code>updated</code> event before our entire pipeline will complete.</p><h2>Sending values using subjects</h2><p>Instead, this is a great use case for a <em>subject</em> — which lets us send as many values as we’d like before manually completing it. Combine ships with two main subject implementations: <code>PassthroughSubject</code> and <code>CurrentValueSubject</code>. Let’s start by using the former, which doesn’t hold on to any of the values that we’ll send it, but will rather <em>pass them through</em> to each of its subscribers.</p><p>Here’s how we could use such a subject to update our Combine-powered <code>ImageProcessing</code> API to now fully support both progress updates and completion events:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageProcessor</span> {\n    <span class=\"s-keyword\">func</span> process(<span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">ProgressEvent</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-comment\">// First, we create our subject:</span>\n        <span class=\"s-keyword\">let</span> subject = <span class=\"s-type\">PassthroughSubject</span>&lt;<span class=\"s-type\">ProgressEvent</span>, <span class=\"s-type\">Error</span>&gt;()\n\n        <span class=\"s-comment\">// Then, we call our closure-based API, and whenever it\n        // sends us a new event, then we'll pass that along to\n        // our subject. Finally, when our operation was finished,\n        // then we'll send a competion event to our subject:</span>\n        <span class=\"s-call\">process</span>(image,\n            onProgress: { ratio <span class=\"s-keyword\">in</span>\n                subject.<span class=\"s-call\">send</span>(.<span class=\"s-call\">updated</span>(completionRatio: ratio))\n            },\n            onComplete: { result <span class=\"s-keyword\">in\n                switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> image):\n                    subject.<span class=\"s-call\">send</span>(.<span class=\"s-call\">completed</span>(image))\n                    subject.<span class=\"s-call\">send</span>(completion: .<span class=\"s-dotAccess\">finished</span>)\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    subject.<span class=\"s-call\">send</span>(completion: .<span class=\"s-call\">failure</span>(error))\n                }\n            }\n        )\n        \n        <span class=\"s-comment\">// To avoid returning a mutable object, we convert our\n        // subject into a type-erased publisher before returning it:</span>\n        <span class=\"s-keyword\">return</span> subject.<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Now all that we have to do is to update our call site from before to handle <code>ProgressEvent</code> values, rather than just <code>UIImage</code> instances — like this:</p><pre class=\"splash\"><code>processor.<span class=\"s-call\">process</span>(image)\n    .<span class=\"s-call\">replaceError</span>(with: .<span class=\"s-call\">completed</span>(.<span class=\"s-dotAccess\">errorIcon</span>))\n    .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n    .<span class=\"s-call\">sink</span> { event <span class=\"s-keyword\">in\n        switch</span> event {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">updated</span>(<span class=\"s-keyword\">let</span> completionRatio):\n            progressView.<span class=\"s-property\">completionRatio</span> = completionRatio\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">completed</span>(<span class=\"s-keyword\">let</span> image):\n            imageView.<span class=\"s-property\">image</span> = image.<span class=\"s-call\">withRenderingMode</span>(\n                .<span class=\"s-dotAccess\">alwaysTemplate</span>\n            )\n        }\n    }\n    .<span class=\"s-call\">store</span>(in: &amp;cancellables)</code></pre><p>However, one thing to keep in mind when using <code>PassthroughSubject</code> is that each subscriber that attaches to it will only receive the values that were sent <em>after</em> that subscription became active.</p><p>So in our case, since we’re starting each image processing operation immediately, and since we don’t know whether a caller might apply some form of delay to the way it handles our emitted values, we might instead want to use a <code>CurrentValueSubject</code>. Like its name implies, such a subject will keep track of the current (or last) value that we sent to it, and will in turn send that to all new subscribers once they connect to our subject.</p><p>Thankfully, switching between those two subject variants is typically really simple, since the only difference is that we have to initialize a <code>CurrentValueSubject</code> with the initial current value that we’d like it to keep track of:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageProcessor</span> {\n    <span class=\"s-keyword\">func</span> process(<span class=\"s-keyword\">_</span> image: <span class=\"s-type\">UIImage</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">ProgressEvent</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">let</span> subject = <span class=\"s-type\">CurrentValueSubject</span>&lt;<span class=\"s-type\">ProgressEvent</span>, <span class=\"s-type\">Error</span>&gt;(\n            .<span class=\"s-call\">updated</span>(completionRatio: <span class=\"s-number\">0</span>)\n        )\n\n        ...\n\n        <span class=\"s-keyword\">return</span> subject.<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Worth pointing out, though, is that the above new implementation will also cause that initial <code>ProgressEvent</code> value to be immediately emitted when our subject is created, which may or may not be what we want, depending on the situation. But, in this case, it’ll actually be really nice, as that’ll ensure that all of our progress handling code will always be reset to zero when connected to our subject.</p><h2>Conclusion</h2><p>Combine’s <code>Future</code> and subject types are definitely worth keeping in mind when building Combine-powered APIs — and often act as much simpler alternatives to building completely custom publishers from scratch. There’s of course also <code>Published</code> properties, which offer another way to emit values through stored properties, which were <a href=\"https://www.swiftbysundell.com/articles/published-properties-in-swift/\">covered in depth in this article</a> — so Combine really does offer a quite comprehensive suite of tools that we can choose from depending on what we’re looking to build.</p><p>Thanks for reading! You’re more than welcome to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a> if you have any questions, comments or feedback. Also, feel free to check out this week’s sponsor using the link above if you’d like to support my work.</p>",
      "summary": "How Combine’s Future and subject types enable us to build many different kinds of functionality without having to write custom publisher implementations from scratch.",
      "date_published": "2021-03-23T15:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/questions/when-can-the-return-keyword-be-omitted",
      "url": "https://www.swiftbysundell.com/questions/when-can-the-return-keyword-be-omitted",
      "title": "When can Swift’s return keyword be omitted?",
      "content_html": "<p>Ever since the very first version of Swift, we’ve been able to omit the <code>return</code> keyword within single-expression closures, such as this one, which attempts to convert each element within an array of <code>String</code> values into an equivalent <code>Int</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> strings = [<span class=\"s-string\">\"1\"</span>, <span class=\"s-string\">\"2\"</span>, <span class=\"s-string\">\"3\"</span>]\n\n<span class=\"s-keyword\">let</span> ints = strings.<span class=\"s-call\">compactMap</span> { string <span class=\"s-keyword\">in</span>\n    <span class=\"s-type\">Int</span>(string)\n}</code></pre><p>However, if a given closure contains multiple expressions, then the <code>return</code> keyword <em>can’t</em> be omitted, even if that closure doesn’t include any conditions or separate code branches. So the closure passed into the below call to <code>map</code> needs to explicitly mark its last expression as its return value:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> GameController {\n    <span class=\"s-keyword\">private(set) var</span> players = [<span class=\"s-type\">Player</span>]()\n\n    <span class=\"s-keyword\">func</span> reviveAllPlayers() {\n        players = players.<span class=\"s-call\">map</span> { player <span class=\"s-keyword\">in\n            var</span> player = player\n            player.<span class=\"s-property\">isActive</span> = <span class=\"s-keyword\">true</span>\n            player.<span class=\"s-property\">hitPoints</span> = <span class=\"s-number\">100</span>\n            <span class=\"s-keyword\">return</span> player\n        }\n    }\n}</code></pre><p class=\"info\">To learn more about the <code>map</code> and <code>compactMap</code> functions used above, check out <a href=\"https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap\">this Basics article</a>.</p><p>In Swift 5.1, the above behavior was expanded to also include functions and computed properties, while maintaining the exact same rules. So now, when writing a function that contains just a single expression that computes a return value, then we can also omit the <code>return</code> keyword — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">GameController</span> {\n    <span class=\"s-keyword\">func</span> playersQualifiedForNextLevel() -&gt; [<span class=\"s-type\">Player</span>] {\n        players.<span class=\"s-call\">filter</span> { player <span class=\"s-keyword\">in</span>\n            player.<span class=\"s-property\">isActive</span> &amp;&amp; player.<span class=\"s-property\">score</span> &gt; <span class=\"s-number\">1000</span>\n        }\n    }\n}</code></pre><p class=\"info\">Above we’re actually omitting two return keywords — both the top-level one within our function, and the one for the closure passed to <code>filter</code>.</p><p>Likewise, when implementing a computed property that simply returns the outcome of a single expression, then the <code>return</code> keyword can now also be omitted — which often makes it possible to fit an entire computed property implementation on a single line of code, if that’s something that we’d like to do:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">GameController</span> {\n    <span class=\"s-keyword\">var</span> gameCanBeStarted: <span class=\"s-type\">Bool</span> { players.<span class=\"s-property\">count</span> &gt; <span class=\"s-number\">1</span> }\n}</code></pre><p>Worth noting, though, is that all of these features are entirely optional. If we wanted to, we could modify each of the examples that we’ve taken a look at so far to instead always use explicit <code>return</code> keywords, and everything would keep working the exact same way.</p><p>One thing that <em>could</em> potentially make the above behaviors slightly more confusing, however, is when we start to adopt <a href=\"https://www.swiftbysundell.com/discover/swiftui\">SwiftUI</a>. When using a closure to construct the body of a SwiftUI container, it might initially seem like we’re actually able to omit the <code>return</code> keyword even within closures that contain multiple expressions or code paths — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RootView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> loginController: <span class=\"s-type\">LoginController</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">NavigationView</span> {\n            <span class=\"s-keyword\">if let</span> user = loginController.<span class=\"s-property\">loggedInUser</span> {\n                <span class=\"s-type\">HomeView</span>(user: user)\n            } <span class=\"s-keyword\">else</span> {\n                <span class=\"s-type\">LoginView</span>(handler: loginController.<span class=\"s-property\">performLogin</span>)\n            }\n        }\n    }\n}</code></pre><p>However, the above closure is not actually using multiple implicit returns, but is instead being processed by SwiftUI’s <code>ViewBuilder</code> — which is a <a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders/\">function/result builder</a> that takes each of our view expressions and combines them into a single return type.</p><p>To illustrate, let’s see what happens if we turn the above closure into a method instead:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RootView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> loginController: <span class=\"s-type\">LoginController</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">NavigationView</span>(content: makeContent)\n    }\n\n    <span class=\"s-keyword\">private func</span> makeContent() -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">if let</span> user = loginController.<span class=\"s-property\">loggedInUser</span> {\n            <span class=\"s-type\">HomeView</span>(user: user)\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-type\">LoginView</span>(handler: loginController.<span class=\"s-property\">performLogin</span>)\n        }\n    }\n}</code></pre><p>When attempting to compile the above code, we’ll now get the following build error:</p><pre><code class=\"no-highlight\">Function declares an opaque return type, but has no return\nstatements in its body from which to infer an underlying type.</code></pre><p>To fix it, we’d have to mark our new <code>makeContent</code> method with the same <code>@ViewBuilder</code> attribute that SwiftUI marks many of its closure parameters with — which once again makes it possible for us to declare multiple expressions without any <code>return</code> keywords:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RootView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> loginController: <span class=\"s-type\">LoginController</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">NavigationView</span>(content: makeContent)\n    }\n\n    <span class=\"s-keyword\">@ViewBuilder</span> <span class=\"s-keyword\">private func</span> makeContent() -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">if let</span> user = loginController.<span class=\"s-property\">loggedInUser</span> {\n            <span class=\"s-type\">HomeView</span>(user: user)\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-type\">LoginView</span>(handler: loginController.<span class=\"s-property\">performLogin</span>)\n        }\n    }\n}</code></pre><p>So, to sum things up:</p><ul><li>Swift’s <code>return</code> keyword can always be omitted within all single-expression closures, functions, and computed properties. But, if we wish, we can still use explicit returns within each of those contexts as well.</li><li>Whenever a closure, function or computed property contains multiple, top-level expressions, then we need to explicitly mark our return value expressions with the <code>return</code> keyword.</li><li>Of course, functions or closures that don’t actually return anything (or, technically, return <code>Void</code>) never need to contain any <code>return</code> keyword at all, unless we’d like to manually exit out of that scope — for example by performing an <em><a href=\"https://www.swiftbysundell.com/articles/early-returning-functions-in-swift\">early return</a></em>.</li><li>SwiftUI is a bit of a special case in this context, since it doesn’t rely on implicit returns (for the most part), but instead uses its <code>ViewBuilder</code> to combine all of our expressions within a given container into a single view value.</li></ul>",
      "summary": "Let’s take a look at exactly when we can omit the return keyword, and how that relates to SwiftUI’s DSL.",
      "date_published": "2021-03-21T14:54:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/93",
      "url": "https://www.swiftbysundell.com/podcast/93",
      "title": "Podcast: “Combine and Core Data”, with special guest Donny Wals",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell93.mp3\" type=\"audio/mpeg\"/></audio><p>Donny Wals, book author and iOS developer at Disney Streaming Services, joins John to give practical tips on Combine and Core Data. How to manage and test increasingly complex Combine pipelines, and how come the opinions on Core Data are so divisive? Also, working on internal SDKs and frameworks, and taking a pragmatic approach to unit testing.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://www.emergetools.com\">Emerge</a>:</strong> A new tool that can help you visualize and reduce your app’s binary size. Visit <a href=\"https://www.emergetools.com\">emergetools.com</a> to learn more, and to request a demo.</li><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Rock-solid continuous integration for your Swift project, which now also supports ad-ons for things like automatic deployment. Go to <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a> to get started for free.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/donnywals\">Donny on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://practicalcombine.com\">Practical Combine</a></li><li><a href=\"https://practicalcoredata.com\">Practical Core Data</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/63\">The 2019 holiday special</a></li><li><a href=\"https://en.wikipedia.org/wiki/Unified_Modeling_Language\">UML</a></li><li><a href=\"https://github.com/Quick/Quick\">Quick</a></li><li><a href=\"https://www.swiftbysundell.com/discover/unit-testing\">Unit testing</a></li><li><a href=\"https://www.youtube.com/watch?v=aUoT5w4JOoM\">Donny’s try! Swift talk about Core Data</a></li><li><a href=\"https://www.swiftbysundell.com/articles/connecting-and-merging-combine-publishers-in-swift\">Connecting and merging Combine publishers</a></li><li><a href=\"https://developer.apple.com/documentation/combine/publisher\">The Publisher protocol</a></li><li><a href=\"https://developer.apple.com/documentation/foundation/operationqueue\">OperationQueue</a></li><li><a href=\"https://www.swiftbysundell.com/basics/grand-central-dispatch\">Grand Central Dispatch</a></li><li><a href=\"https://github.com/mxcl/PromiseKit\">PromiseKit</a></li><li><a href=\"https://developer.apple.com/documentation/combine/future\">Combine’s Future type</a></li><li><a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift\">Building your own Futures and Promises system</a></li><li><a href=\"https://www.swiftbysundell.com/articles/building-custom-combine-publishers-in-swift\">Building custom Combine publishers</a></li><li><a href=\"https://developer.apple.com/documentation/combine/passthroughsubject\">PassthroughSubject</a></li><li><a href=\"https://www.swiftbysundell.com/articles/unit-testing-asynchronous-swift-code\">Unit testing asynchronous code</a></li><li><a href=\"https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code\">Unit testing Combine-based code</a></li><li><a href=\"https://developer.apple.com/documentation/coredata/nspersistentcontainer\">NSPersistentContainer</a></li><li><a href=\"https://developer.apple.com/documentation/coredata/nsmanagedobjectcontext/1506578-perform\">Core Data’s perform API</a></li><li><a href=\"https://realm.io\">Realm</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Donny Wals, book author and iOS developer at Disney Streaming Services, joins John to give practical tips on Combine and Core Data. How to manage and test increasingly complex Combine pipelines, and how come the opinions on Core Data are so divisive? Also, working on internal SDKs and frameworks, and taking a pragmatic approach to unit testing.",
      "date_published": "2021-03-14T15:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/bindable-swiftui-list-elements",
      "url": "https://www.swiftbysundell.com/articles/bindable-swiftui-list-elements",
      "title": "Bindable SwiftUI list elements",
      "content_html": "<p>SwiftUI’s <code>Binding</code> property wrapper lets us establish a <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#two-way-bindings\">two-way binding</a> between a given piece of state and any view that wishes to modify that state. Typically, creating such a binding simply involves referencing the state property that we wish to bind to using the <code>$</code> prefix, but when it comes to collections, things are often not quite as straightforward.</p><h2>Not all values are bindings</h2><p>For example, let’s say that we’re building a note-taking app, and that we’d like to bind each <code>Note</code> model within an array to a series of <code>NoteEditingView</code> instances that are being created within a SwiftUI <code>ForEach</code> loop — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Note: <span class=\"s-type\">Hashable</span>, <span class=\"s-type\">Identifiable</span> {\n    <span class=\"s-keyword\">let</span> id: <span class=\"s-type\">UUID</span>\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> text: <span class=\"s-type\">String</span>\n    ...\n}\n\n<span class=\"s-keyword\">class</span> NoteList: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published var</span> notes: [<span class=\"s-type\">Note</span>]\n    ...\n}\n\n<span class=\"s-keyword\">struct</span> NoteEditView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> note: <span class=\"s-type\">Note</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        ...\n    }\n}\n\n<span class=\"s-keyword\">struct</span> NoteListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> list: <span class=\"s-type\">NoteList</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span> {\n            <span class=\"s-type\">ForEach</span>(list.<span class=\"s-property\">notes</span>) { note <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">NavigationLink</span>(note.<span class=\"s-property\">title</span>,\n                    destination: <span class=\"s-type\">NoteEditView</span>(\n                        note: <span class=\"s-property\">$note</span>\n                    )\n                )\n            }\n        }\n    }\n}</code></pre><p>Unfortunately, the above code sample doesn’t fully compile, for the same reason that we can’t directly mutate a value within a classic <code>for</code> loop — the <code>note</code> arguments that are being passed into our <code>ForEach</code> closure are all immutable, non-bindable values.</p><h2>Xcode 13’s new element binding syntax</h2><p>Now, if we’re working on a project that’s built using Xcode 13 (which is currently in beta at the time of writing), then we’re in luck, because there’s a new syntax that lets us automatically convert a given collection’s elements into bindable values.</p><p>All that we have to do is to reference our property, and our <code>ForEach</code> closure argument, using the same <code>$</code> syntax that we typically use when generating bindings, and the system will take care of the rest:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> NoteListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> list: <span class=\"s-type\">NoteList</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span> {\n            <span class=\"s-type\">ForEach</span>(<span class=\"s-property\">$list</span>.<span class=\"s-property\">notes</span>) { <span class=\"s-property\">$note</span> <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">NavigationLink</span>(note.<span class=\"s-property\">title</span>,\n                    destination: <span class=\"s-type\">NoteEditView</span>(\n                        note: <span class=\"s-property\">$note</span>\n                    )\n                )\n            }\n        }\n    }\n}</code></pre><p class=\"info\">Note that we can reference our closure’s <code>$note</code> input either with or without its dollar prefix, depending on whether we want to access the underlying value directly, or the binding that encapsulates it.</p><p>Something that’s really nice about the above new syntax is that it’s actually fully backward compatible with all previous operating systems on which SwiftUI is supported — so on iOS, that means as far back as iOS 13. The only requirement is that we have to build our app using the compiler and SDK that’s included in Xcode 13.</p><h2>Solving the problem when using earlier Xcode versions</h2><p>However, if we’re working on a project that’s not yet using Xcode 13 and the SDKs that are bundled with it, then we’ll have to explore a few other, more custom solutions.</p><p>One option would be to iterate over the <em>indices</em> of our <code>notes</code> array, which will let us bind to mutable versions of our <code>Note</code> models by subscripting into <code>$list.notes</code> using the index that’s now passed into our <code>ForEach</code> closure:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> NoteListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> list: <span class=\"s-type\">NoteList</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span> {\n            <span class=\"s-type\">ForEach</span>(list.<span class=\"s-property\">notes</span>.<span class=\"s-property\">indices</span>) { index <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">NavigationLink</span>(list.<span class=\"s-property\">notes</span>[index].title,\n                    destination: <span class=\"s-type\">NoteEditView</span>(\n                        note: <span class=\"s-property\">$list</span>.<span class=\"s-property\">notes</span>[index]\n                    )\n                )\n            }\n        }\n    }\n}</code></pre><p>While the above code successfully compiles, and might initially even seem to be fully working — as soon as we’ll mutate our array of notes, we’ll get the following warning printed within the Xcode console:</p><pre><code class=\"no-highlight\">ForEach(_:content:) should only be used for *constant* data. Instead conform\ndata to Identifiable or use ForEach(_:id:content:) and provide an explicit id!</code></pre><p>Alright, so let’s do what SwiftUI tells us, by passing an explicit <code>id</code> <a href=\"https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift\">key path</a> when creating our <code>ForEach</code> instance — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> NoteListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> list: <span class=\"s-type\">NoteList</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span> {\n            <span class=\"s-type\">ForEach</span>(list.<span class=\"s-property\">notes</span>.<span class=\"s-property\">indices</span>, id: \\.<span class=\"s-keyword\">self</span>) { index <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">NavigationLink</span>(list.<span class=\"s-property\">notes</span>[index].title,\n                    destination: <span class=\"s-type\">NoteEditView</span>(\n                        note: <span class=\"s-property\">$list</span>.<span class=\"s-property\">notes</span>[index]\n                    )\n                )\n            }\n        }\n    }\n}</code></pre><p>At this point, we <em>might</em> have actually solved the problem. There are no more warnings being emitted, and things <em>might</em> continue to work perfectly fine even as we mutate our <code>Note</code> array. However, “might” is really the keyword here, as what we’ve essentially done is to make the index of each note its “reuse identifier”. What that means is that we might run into certain odd behaviors (or crashes, even) if our array ever changes rapidly, as SwiftUI will now consider each note’s index a stable identifier for that particular model and its associated <code>NavigationLink</code>.</p><p>So to <em>truly</em> fix the problem, we’re either going to have to refactor our <code>NoteList</code> class to also offer a way to access each <code>Note</code> by its proper <code>UUID</code>-based id (which would let us pass an array of those ids to <code>ForEach</code>, rather than using <code>Int</code>-based array indices), or we’re going to have to dive a bit deeper into Swift’s collection APIs in order to make our array indices <em>truly unique</em>.</p><h2>Identifiable indices</h2><p>In this case, let’s go for the second strategy, by introducing a custom collection that’ll combine the indices of another collection with the identifiers of the elements that it contains. To get started, let’s define a new type called <code>IdentifiableIndices</code>, which wraps a <code>Base</code> collection and also declares an <code>Index</code> and an <code>Element</code> type:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> IdentifiableIndices&lt;Base: <span class=\"s-type\">RandomAccessCollection</span>&gt;\n    <span class=\"s-keyword\">where</span> <span class=\"s-type\">Base</span>.<span class=\"s-type\">Element</span>: <span class=\"s-type\">Identifiable</span> {\n\n    <span class=\"s-keyword\">typealias</span> Index = <span class=\"s-type\">Base</span>.<span class=\"s-type\">Index</span>\n\n    <span class=\"s-keyword\">struct</span> Element: <span class=\"s-type\">Identifiable</span> {\n        <span class=\"s-keyword\">let</span> id: <span class=\"s-type\">Base</span>.<span class=\"s-type\">Element</span>.<span class=\"s-type\">ID</span>\n        <span class=\"s-keyword\">let</span> rawValue: <span class=\"s-type\">Index</span>\n    }\n\n    <span class=\"s-keyword\">fileprivate var</span> base: <span class=\"s-type\">Base</span>\n}</code></pre><p>Next, let’s make our new collection conform to the standard library’s <code>RandomAccessCollection</code> protocol, which mostly involves forwarding the required properties and methods to our underlying <code>base</code> collection — except for the implementation of <code>subscript</code>, which returns an instance of the <code>Element</code> type that we defined above:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">IdentifiableIndices</span>: <span class=\"s-type\">RandomAccessCollection</span> {\n    <span class=\"s-keyword\">var</span> startIndex: <span class=\"s-type\">Index</span> { base.<span class=\"s-property\">startIndex</span> }\n    <span class=\"s-keyword\">var</span> endIndex: <span class=\"s-type\">Index</span> { base.<span class=\"s-property\">endIndex</span> }\n\n    <span class=\"s-keyword\">subscript</span>(position: <span class=\"s-type\">Index</span>) -&gt; <span class=\"s-type\">Element</span> {\n        <span class=\"s-type\">Element</span>(id: base[position].id, rawValue: position)\n    }\n\n    <span class=\"s-keyword\">func</span> index(before index: <span class=\"s-type\">Index</span>) -&gt; <span class=\"s-type\">Index</span> {\n        base.<span class=\"s-call\">index</span>(before: index)\n    }\n\n    <span class=\"s-keyword\">func</span> index(after index: <span class=\"s-type\">Index</span>) -&gt; <span class=\"s-type\">Index</span> {\n        base.<span class=\"s-call\">index</span>(after: index)\n    }\n}</code></pre><p>That’s it! Our new collection is now ready for action. However, to make it a bit more convenient to use, let’s also introduce two small extensions that’ll heavily improve its overall ergonomics. First, let’s make it easy to create an <code>IdentifiableIndices</code> instance by adding the following computed property to all compatible base collections (that is, ones that support random access, and also contains <code>Identifiable</code> elements):</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">RandomAccessCollection</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Element</span>: <span class=\"s-type\">Identifiable</span> {\n    <span class=\"s-keyword\">var</span> identifiableIndices: <span class=\"s-type\">IdentifiableIndices</span>&lt;<span class=\"s-type\">Self</span>&gt; {\n        <span class=\"s-type\">IdentifiableIndices</span>(base: <span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p class=\"info\">The reason we can confidently make the above <a href=\"https://www.swiftbysundell.com/articles/computed-properties-in-swift\">a computed property, rather than a method</a>, is because <code>IdentifiableIndices</code> computes its elements lazily. That is, it doesn’t iterate over its base collection when first created, but rather acts more like a lens into that collection’s indices and identifiers. So creating it is an <code>O(1)</code> operation.</p><p>Finally, let’s also extend SwiftUI’s <code>ForEach</code> type with a convenience API that’ll let us iterate over an <code>IdentifiableIndices</code> collection without also having to manually access the <code>rawValue</code> of each index:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ForEach</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">ID</span> == <span class=\"s-type\">Data</span>.<span class=\"s-type\">Element</span>.<span class=\"s-type\">ID</span>,\n                        <span class=\"s-type\">Data</span>.<span class=\"s-type\">Element</span>: <span class=\"s-type\">Identifiable</span>,\n                        <span class=\"s-type\">Content</span>: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">init</span>&lt;T&gt;(\n        <span class=\"s-keyword\">_</span> indices: <span class=\"s-type\">Data</span>,\n        <span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Data</span>.<span class=\"s-type\">Index</span>) -&gt; <span class=\"s-type\">Content</span>\n    ) <span class=\"s-keyword\">where</span> <span class=\"s-type\">Data</span> == <span class=\"s-type\">IdentifiableIndices</span>&lt;<span class=\"s-type\">T</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(indices) { index <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">content</span>(index.<span class=\"s-property\">rawValue</span>)\n        }\n    }\n}</code></pre><p>With the above pieces in place, we can now go back to our <code>NoteListView</code> and make its usage of <code>ForEach</code> much more stable and reliable by making it iterate over our <code>Note</code> array’s <code>identifiableIndices</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> NoteListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> list: <span class=\"s-type\">NoteList</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span> {\n            <span class=\"s-type\">ForEach</span>(list.<span class=\"s-property\">notes</span>.<span class=\"s-property\">identifiableIndices</span>) { index <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">NavigationLink</span>(list.<span class=\"s-property\">notes</span>[index].title,\n                    destination: <span class=\"s-type\">NoteEditView</span>(\n                        note: <span class=\"s-property\">$list</span>.<span class=\"s-property\">notes</span>[index]\n                    )\n                )\n            }\n        }\n    }\n}</code></pre><p>However, while the above solution should prove to work really well in many different kinds of situations, it’s still possible to encounter crashes and other bugs if the last element of our collection is ever removed. It seems like SwiftUI applies some form of caching to the collection bindings that it creates, which can cause an outdated index to be used when subscripting into our underlying <code>Note</code> array — and if that happens when the last element was removed, then our app will crash with an out-of-bounds error. Not great.</p><h2>Custom bindings</h2><p>While this certainly seems to be a bug within SwiftUI itself, it’s still something that we can work around locally for now. Rather than using SwiftUI’s built-in API for retrieving nested bindings for each collection element, let’s instead create custom <code>Binding</code> instances, which (at least in my experience) will completely solve the problem.</p><p>To make that happen, let’s modify our previous <code>ForEach</code> extension to instead accept a <code>Binding</code> reference to the collection that we wish to iterate over (which, in turn, requires that collection to conform to <code>MutableCollection</code>), and to then use that to create custom <code>Binding</code> instances for getting and setting each element. Finally, we’ll pass each such custom binding to our <code>content</code> closure, along with the index of the current element — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ForEach</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">ID</span> == <span class=\"s-type\">Data</span>.<span class=\"s-type\">Element</span>.<span class=\"s-type\">ID</span>,\n                        <span class=\"s-type\">Data</span>.<span class=\"s-type\">Element</span>: <span class=\"s-type\">Identifiable</span>,\n                        <span class=\"s-type\">Content</span>: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">init</span>&lt;T&gt;(\n        <span class=\"s-keyword\">_</span> data: <span class=\"s-type\">Binding</span>&lt;<span class=\"s-type\">T</span>&gt;,\n        <span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">T</span>.<span class=\"s-type\">Index</span>, <span class=\"s-type\">Binding</span>&lt;<span class=\"s-type\">T</span>.<span class=\"s-type\">Element</span>&gt;) -&gt; <span class=\"s-type\">Content</span>\n    ) <span class=\"s-keyword\">where</span> <span class=\"s-type\">Data</span> == <span class=\"s-type\">IdentifiableIndices</span>&lt;<span class=\"s-type\">T</span>&gt;, <span class=\"s-type\">T</span>: <span class=\"s-type\">MutableCollection</span> {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(data.<span class=\"s-property\">wrappedValue</span>.<span class=\"s-property\">identifiableIndices</span>) { index <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">content</span>(\n                index.<span class=\"s-property\">rawValue</span>,\n                <span class=\"s-type\">Binding</span>(\n                    get: { data.<span class=\"s-property\">wrappedValue</span>[index.<span class=\"s-property\">rawValue</span>] },\n                    set: { data.<span class=\"s-property\">wrappedValue</span>[index.<span class=\"s-property\">rawValue</span>] = $0 }\n                )\n            )\n        }\n    }\n}</code></pre><p>If we now use the above new API to update our <code>NoteListView</code> to instead look like this, then we should be able to modify our <code>NoteList</code> model object however we please without encountering any kind of SwiftUI-related issues within our view:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> NoteListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> list: <span class=\"s-type\">NoteList</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span> {\n            <span class=\"s-type\">ForEach</span>(<span class=\"s-property\">$list</span>.<span class=\"s-property\">notes</span>) { index, note <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">NavigationLink</span>(note.<span class=\"s-property\">wrappedValue</span>.<span class=\"s-property\">title</span>,\n                    destination: <span class=\"s-type\">NoteEditView</span>(\n                        note: note\n                    )\n                )\n            }\n        }\n    }\n}</code></pre><h2>Conclusion</h2><p>It’s really great that Apple addressed the issue of creating bindings to a collection’s elements in the 2021 release of SwiftUI and the Swift compiler, but if we’re not yet ready to fully migrate to those toolchains, then we can also create a more custom workaround using some of Swift’s built-in protocols, such as <code>RandomAccessCollection</code> and <code>Identifiable</code>.</p><p>Thanks for reading, and feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a> if you have any questions, comments or feedback.</p>",
      "summary": "Setting up two-way bindings between the elements in a collection and a series of SwiftUI views.",
      "date_published": "2021-03-12T17:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/bitrise-march-2021",
      "url": "https://www.swiftbysundell.com/sponsor/bitrise-march-2021",
      "title": "Sponsor: Bitrise",
      "content_html": "<p>Thanks a lot to Bitrise for sponsoring Swift by Sundell last week. Bitrise is one of my longest-running sponsors, and it’s been my preferred <a href=\"https://go.bitrise.io/swift\">continuous integration service</a> for years. Using Bitrise, I’m able to super easily set up automatic testing and deployment for both my open source projects, and for the apps that I work on as a freelancer.</p><p>Bitrise now also features a powerful add-on system, which is continuously expanded with new extensions that you can add to your Bitrise workflows with just a few clicks. For example, their <em><a href=\"https://www.bitrise.io/add-ons/mobile-test-reporting\">Test reports</a></em> add-on lets you see the results of all of your automatic tests on a single dashboard, the <em><a href=\"https://www.bitrise.io/add-ons/deploy-with-bitrise-ship\">Ship</a></em> add-on enables you to automate your deployments to both TestFlight and the App Store, and <em><a href=\"https://www.bitrise.io/add-ons/trace-mobile-monitoring\">Trace</a></em> is a new add-on that adds crash reporting and performance monitoring to your app — completely automatically!</p><p>Each of these add-ons naturally extend Bitrise’s existing workflows by using the same steps and configurations that are used during the continuous integration process. For example, simply add an <code>Xcode Archive</code> step to your workflow to have Bitrise archive your app for release, and you’ll then be able to easily deploy those archives using Ship.</p><p>Ship and Trace are currently in beta, but well-worth checking out regardless. Start by creating your free Bitrise account at <a href=\"https://go.bitrise.io/swift\">bitrise.io/swift</a> (just by doing that, you’ll directly help support Swift by Sundell, by the way), add an app that you’re working on to it, and you’ll be able to start exploring their easy-to-use continuous integration workflows, and their new suite of add-ons, within minutes.</p>",
      "summary": "Thanks a lot to Bitrise for sponsoring Swift by Sundell.",
      "date_published": "2021-03-08T12:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/property-wrapper-default-values",
      "url": "https://www.swiftbysundell.com/tips/property-wrapper-default-values",
      "title": "Automatic handling of property wrapper default values",
      "content_html": "<p>Swift’s property wrappers feature enables us to encapsulate a given property value in order to run custom logic whenever that value was created or changed. For example, the following <code>Capitalized</code> type (which was borrowed from my <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">full-length article on property wrappers</a>) lets us automatically capitalize all <code>String</code> values that were assigned to any of our wrapped properties:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper struct</span> Capitalized {\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">didSet</span> { wrappedValue = wrappedValue.<span class=\"s-property\">capitalized</span> }\n    }\n\n    <span class=\"s-keyword\">init</span>(wrappedValue: <span class=\"s-type\">String</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">wrappedValue</span> = wrappedValue.<span class=\"s-property\">capitalized</span>\n    }\n}</code></pre><p>One really neat aspect of property wrappers is that the compiler will automatically map any default value that we’ve defined at the call site to the above <code>init(wrappedValue:)</code> initializer — meaning that we can keep defining default values just as we normally would, even when a property is wrapped by one of our custom types:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Document {\n    <span class=\"s-keyword\">@Capitalized var</span> name = <span class=\"s-string\">\"Untitled document\"</span>\n}</code></pre><p>That automatic default value mapping even extends to property wrappers that accept additional initializer parameters as well. For example, here we’ve defined a property wrapper that lets us override a given value using a command line argument, and simply by naming our default value parameter <code>wrappedValue</code> (and placing it first within our initializer argument list), we’ll be able to keep assigning default values to the properties that are being wrapped:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper struct</span> CommandLineOverridable {\n    <span class=\"s-keyword\">let</span> wrappedValue: <span class=\"s-type\">Bool</span>\n    <span class=\"s-keyword\">var</span> flagName: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">private let</span> defaults = <span class=\"s-type\">UserDefaults</span>.<span class=\"s-property\">standard</span>\n\n    <span class=\"s-keyword\">init</span>(wrappedValue defaultValue: <span class=\"s-type\">Bool</span>, flagName: <span class=\"s-type\">String</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">flagName</span> = flagName\n\n        <span class=\"s-preprocessing\">#if DEBUG</span>\n        <span class=\"s-comment\">// First, we check if a command line argument matching\n        // our flagName even exists, before retrieving a Bool\n        // value for it, since otherwise we'd get 'false' back\n        // for flags that weren't passed at all:</span>\n        <span class=\"s-keyword\">if</span> defaults.<span class=\"s-call\">object</span>(forKey: flagName) != <span class=\"s-keyword\">nil</span> {\n            wrappedValue = defaults.<span class=\"s-call\">bool</span>(forKey: flagName)\n            <span class=\"s-keyword\">return</span>\n        }\n        <span class=\"s-preprocessing\">#endif</span>\n\n        wrappedValue = defaultValue\n    }\n}</code></pre><p class=\"info\">Note how we’re using Foundation’s <code>UserDefaults</code> API to parse command line arguments above. To learn more about that, check out <a href=\"https://www.swiftbysundell.com/articles/launch-arguments-in-swift\">“Launch arguments in Swift”</a>.</p><p>With the above in place, we now just have to tell each <code>CommandLineOverridable</code> instance what flag that we want to use for each given property, and the compiler will automatically map that property’s default value to our <code>wrappedValue</code> initializer argument:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AppConfiguration {\n    <span class=\"s-keyword\">@CommandLineOverridable</span>(flagName: <span class=\"s-string\">\"sync\"</span>)\n    <span class=\"s-keyword\">static var</span> enableSync = <span class=\"s-keyword\">true\n    @CommandLineOverridable</span>(flagName: <span class=\"s-string\">\"rememberLogin\"</span>)\n    <span class=\"s-keyword\">static var</span> rememberLogin = <span class=\"s-keyword\">false</span>\n}</code></pre><p>To learn more about property wrappers in general, check out my full-length article <em><a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">“Property wrappers in Swift”</a></em>, which goes into a lot more detail.</p><p>Thanks for reading!</p>",
      "summary": "How the compiler can automatically map default property values to property wrapper initializers, even when a wrapper accepts multiple arguments.",
      "date_published": "2021-03-04T14:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/emerge-february-2021",
      "url": "https://www.swiftbysundell.com/sponsor/emerge-february-2021",
      "title": "Sponsor: Emerge",
      "content_html": "<p>My thanks to the team behind the new app size monitoring tool <em><a href=\"https://www.emergetools.com/?utm_campaign=sbs\">Emerge</a></em> for sponsoring Swift by Sundell last week. If you’re looking to optimize your app’s binary size, or if you’re just curious as to how much smaller your app could become with a few tweaks, then I can really recommend checking out Emerge.</p><p>Not only does Emerge seamlessly integrate with both GitHub and fastlane to show you how each Pull Request will impact your app’s total size, it also gives you direct, actionable suggestions on how you can reduce that size over time. From detecting excess image metadata, to identifying unused code-level symbols, duplicate files, and more — Emerge will help you optimize your app in many different ways, which in turn will make it faster and easier to download.</p><p>See just how much smaller you could make your app’s binary by setting up a quick demo with the Emerge team at <a href=\"https://www.emergetools.com/?utm_campaign=sbs\">emergetools.com</a>. And, when you use that referral link, you’ll also directly support Swift by Sundell in the process — win-win!</p>",
      "summary": "Thanks a lot to Emerge for sponsoring Swift by Sundell.",
      "date_published": "2021-03-01T17:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/92",
      "url": "https://www.swiftbysundell.com/podcast/92",
      "title": "Podcast: “All of our wildest Swift dreams”, with special guest Kaitlin Mahar",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell92.mp3\" type=\"audio/mpeg\"/></audio><p>Kaitlin Mahar, lead engineer at MongoDB and member of the Swift Server Work Group, joins John to discuss the current state of server-side Swift, designing APIs for server-side libraries, and Swift’s upcoming suite of structured concurrency features.</p><h2>Sponsor</h2><p><strong><a href=\"https://clubhouse.io/sundell\">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s built specifically for software teams. Try it for free for two months at <a href=\"https://clubhouse.io/sundell\">clubhouse.io/sundell</a>.</p><h2>Links</h2><ul><li><a href=\"https://twitter.com/k__mahar\">Kaitlin on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://docs.mongodb.com/drivers/swift\">MongoDB’s Swift driver</a></li><li><a href=\"https://www.mongodb.com/cloud/atlas\">MongoDB Atlas</a></li><li><a href=\"https://github.com/mongodb/mongodb-vapor\">The MongoDB + Vapor integration library</a></li><li><a href=\"https://github.com/mongodb/specifications\">MongoDB’s specifications repo</a></li><li><a href=\"https://swift.org/server\">Swift Server Work Group</a></li><li><a href=\"https://cassandra.apache.org\">Cassandra</a></li><li><a href=\"https://forums.swift.org/c/server/43\">The Server category on the Swift forums</a></li><li><a href=\"https://github.com/apple/swift-nio\">SwiftNIO</a></li><li><a href=\"https://swiftpackageindex.com\">Swift Package Index</a></li><li><a href=\"https://github.com/swift-server/sswg/blob/master/process/incubation.md\">The Swift Server Work Group’s incubation process</a></li><li><a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0296-async-await.md\">Async/await</a></li><li><a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift\">Futures and Promises</a></li><li><a href=\"https://forums.swift.org/t/concurrency-structured-concurrency/41622\">Structured concurrency in Swift</a></li><li><a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a></li><li><a href=\"https://www.swiftbysundell.com/articles/using-the-builder-pattern-in-swift/\">The Builder pattern</a></li><li><a href=\"https://www.swiftbysundell.com/articles/using-the-factory-pattern-to-avoid-shared-state-in-swift/\">The Factory pattern</a></li><li><a href=\"https://www.rust-lang.org\">Rust</a></li><li><a href=\"https://www.swiftbysundell.com/basics/codable\">Codable</a></li><li><a href=\"http://bsonspec.org\">BSON</a></li><li><a href=\"https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/Internal/MarkdownMetadataDecoder.swift\">Publish’s Markdown metadata decoder</a></li><li><a href=\"https://github.com/amzn/smoke-framework\">Amazon’s Smoke framework</a></li><li><a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift/\">Property wrappers</a></li><li><a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders/\">Result/function builders</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Kaitlin Mahar, lead engineer at MongoDB and member of the Swift Server Work Group, joins John to discuss the current state of server-side Swift, designing APIs for server-side libraries, and Swift’s upcoming suite of structured concurrency features.",
      "date_published": "2021-02-27T17:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/ignoring-invalid-json-elements-codable",
      "url": "https://www.swiftbysundell.com/articles/ignoring-invalid-json-elements-codable",
      "title": "Ignoring invalid JSON elements when using Codable",
      "content_html": "<p>By default, encoding or decoding an array using Swift’s built-in <code>Codable</code> API is an all-or-nothing type of deal. Either all elements will be successfully handled, or an error will be thrown, which is arguably a good default, since it ensures a high level of data consistency.</p><p>However, sometimes we might want to tweak that behavior so that invalid elements will be <em>ignored</em>, rather than resulting in our entire coding process failing. For example, let’s say that we’re working with a JSON-based web API that returns collections of items that we’re currently modeling in Swift like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Item: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> value: <span class=\"s-type\">Int</span>\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Item</span> {\n    <span class=\"s-keyword\">struct</span> Collection: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Item</span>]\n    }\n}</code></pre><p>Now let’s say that the web API that we’re working with occasionally returns responses such as the following, which includes a <code>null</code> value where our Swift code is expecting an <code>Int</code>:</p><pre><code class=\"no-highlight\">{\n    \"items\": [\n        {\n            \"name\": \"One\",\n            \"value\": 1\n        },\n        {\n            \"name\": \"Two\",\n            \"value\": 2\n        },\n        {\n            \"name\": \"Three\",\n            /*HL*/\"value\": null/*HL*/\n        }\n    ]\n}</code></pre><p>If we try to decode the above response into an instance of our <code>Item.Collection</code> model, then the entire decoding process will fail, even if the majority of our items did contain perfectly valid data.</p><p>The above might seem like a somewhat contrived example, but it’s incredibly common to encounter malformed or inconsistent JSON formats in the wild, and we might not always be able to adjust those formats to neatly fit Swift’s very static nature.</p><p>Of course, one potential solution would be to simply make our <code>value</code> property optional (<code>Int?</code>), but doing so could introduce all sorts of complexities across our code base, since we’d now have to unwrap those values every time that we wish to use them as concrete, non-optional <code>Int</code> values.</p><p>Another way to solve our problem could be to <a href=\"https://www.swiftbysundell.com/tips/default-decoding-values\">define default values</a> for the properties that we’re expecting to potentially be <code>null</code>, missing, or invalid — which would be a fine solution in situations when we still want to keep any elements that contained invalid data, but let’s say that this is not one of those situations.</p><p>So, instead, let’s take a look at how we could <em>ignore</em> all invalid elements when decoding <em>any</em> <code>Decodable</code> array, without having to make any major modifications to how our data is structured within our Swift types.</p><h2>Building a lossy codable list type</h2><p>What we’re essentially looking to do is to change our decoding process from being very strict to instead becoming “lossy”. To get started, let’s introduce a <a href=\"https://www.swiftbysundell.com/basics/generics\">generic</a> <code>LossyCodableList</code> type which will act as a thin wrapper around an array of <code>Element</code> values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> LossyCodableList&lt;Element&gt; {\n    <span class=\"s-keyword\">var</span> elements: [<span class=\"s-type\">Element</span>]\n}</code></pre><p>Note how we didn’t immediately make our new type conform to <code>Codable</code>, and that’s because we’d like it to conditionally support either <code>Decodable</code>, <code>Encodable</code>, or both, depending on what <code>Element</code> type that it’s being used with. After all, not <em>all</em> types will be codable both ways, and by declaring our <code>Codable</code> conformances separately we’ll make our new <code>LossyCodableList</code> type as flexible as possible.</p><p>Let’s start with <code>Decodable</code>, which we’ll conform to by using an intermediate <code>ElementWrapper</code> type to decode each element in an optional manner. We’ll then use <code>compactMap</code> to discard all <code>nil</code> elements, which will give us our final array — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LossyCodableList</span>: <span class=\"s-type\">Decodable</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Element</span>: <span class=\"s-type\">Decodable</span> {\n    <span class=\"s-keyword\">private struct</span> ElementWrapper: <span class=\"s-type\">Decodable</span> {\n        <span class=\"s-keyword\">var</span> element: <span class=\"s-type\">Element</span>?\n\n        <span class=\"s-keyword\">init</span>(from decoder: <span class=\"s-type\">Decoder</span>) <span class=\"s-keyword\">throws</span> {\n            <span class=\"s-keyword\">let</span> container = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">singleValueContainer</span>()\n            element = <span class=\"s-keyword\">try</span>? container.<span class=\"s-call\">decode</span>(<span class=\"s-type\">Element</span>.<span class=\"s-keyword\">self</span>)\n        }\n    }\n\n    <span class=\"s-keyword\">init</span>(from decoder: <span class=\"s-type\">Decoder</span>) <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> container = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">singleValueContainer</span>()\n        <span class=\"s-keyword\">let</span> wrappers = <span class=\"s-keyword\">try</span> container.<span class=\"s-call\">decode</span>([<span class=\"s-type\">ElementWrapper</span>].<span class=\"s-keyword\">self</span>)\n        elements = wrappers.<span class=\"s-call\">compactMap</span>(\\.<span class=\"s-property\">element</span>)\n    }\n}</code></pre><p class=\"info\">To learn more about the above way of conforming to protocols, check out <a href=\"https://www.swiftbysundell.com/articles/conditional-conformances-in-swift\">“Conditional conformances in Swift”</a>.</p><p>Next, <code>Encodable</code>, which might not be something that every project needs, but it could still come in handy in case we also want to give our encoding process the same lossy behavior:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">LossyCodableList</span>: <span class=\"s-type\">Encodable</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Element</span>: <span class=\"s-type\">Encodable</span> {\n    <span class=\"s-keyword\">func</span> encode(to encoder: <span class=\"s-type\">Encoder</span>) <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">var</span> container = encoder.<span class=\"s-call\">unkeyedContainer</span>()\n\n        <span class=\"s-keyword\">for</span> element <span class=\"s-keyword\">in</span> elements {\n            <span class=\"s-keyword\">try</span>? container.<span class=\"s-call\">encode</span>(element)\n        }\n    }\n}</code></pre><p>With the above in place, we’ll now be able to automatically discard all invalid <code>Item</code> values simply by making our nested <code>Collection</code> type use our new <code>LossyCodableList</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Item</span> {\n    <span class=\"s-keyword\">struct</span> Collection: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">var</span> items: <span class=\"s-type\">LossyCodableList</span>&lt;<span class=\"s-type\">Item</span>&gt;\n    }\n}</code></pre><h2>Making our list type transparent</h2><p>One quite major downside with the above approach, however, is that we now always have to use <code>items.elements</code> to access our actual item values, which isn’t ideal. It would arguably be much better if we could turn our usage of <code>LossyCodableList</code> into a completely transparent implementation detail, so that we could keep accessing our <code>items</code> property as a simple array of values.</p><p>One way to make that happen would be to store our item collection’s <code>LossyCodableList</code> as a private property, and to then use a <code>CodingKeys</code> type to point to that property when encoding or decoding. We could then implement <code>items</code> as a computed property, for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Item</span> {\n    <span class=\"s-keyword\">struct</span> Collection: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">enum</span> CodingKeys: <span class=\"s-type\">String</span>, <span class=\"s-type\">CodingKey</span> {\n            <span class=\"s-keyword\">case</span> _items = <span class=\"s-string\">\"items\"</span>\n        }\n\n        <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Item</span>] {\n            <span class=\"s-keyword\">get</span> { _items.<span class=\"s-property\">elements</span> }\n            <span class=\"s-keyword\">set</span> { _items.<span class=\"s-property\">elements</span> = newValue } \n        }\n        \n        <span class=\"s-keyword\">private var</span> _items: <span class=\"s-type\">LossyCodableList</span>&lt;<span class=\"s-type\">Item</span>&gt;\n    }\n}</code></pre><p>Another option would be to give our <code>Collection</code> type a completely custom <code>Decodable</code> implementation, which would involve decoding each JSON array using <code>LossyCodableList</code> before assigning the resulting elements to our <code>items</code> property:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Item</span> {\n    <span class=\"s-keyword\">struct</span> Collection: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">enum</span> CodingKeys: <span class=\"s-type\">String</span>, <span class=\"s-type\">CodingKey</span> {\n            <span class=\"s-keyword\">case</span> items\n        }\n\n        <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Item</span>]\n\n        <span class=\"s-keyword\">init</span>(from decoder: <span class=\"s-type\">Decoder</span>) <span class=\"s-keyword\">throws</span> {\n            <span class=\"s-keyword\">let</span> container = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">container</span>(keyedBy: <span class=\"s-type\">CodingKeys</span>.<span class=\"s-keyword\">self</span>)\n            <span class=\"s-keyword\">let</span> collection = <span class=\"s-keyword\">try</span> container.<span class=\"s-call\">decode</span>(\n                <span class=\"s-type\">LossyCodableList</span>&lt;<span class=\"s-type\">Item</span>&gt;.<span class=\"s-keyword\">self</span>,\n                forKey: .<span class=\"s-dotAccess\">items</span>\n            )\n            \n            items = collection.<span class=\"s-property\">elements</span>\n        }\n    }\n}</code></pre><p>Both of the above approaches are perfectly fine solutions, but let’s see if we could make things even nicer by using Swift’s <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">property wrappers feature</a>.</p><h2>Both a type and a property wrapper</h2><p>One really neat thing about the way that property wrappers are implemented in Swift is that they’re all just standard Swift types, which means that we can <em>retrofit</em> our <code>LossyCodableList</code> to also be able to act as a property wrapper.</p><p>All that we have to do to make that happen is to mark it with the <code>@propertyWrapper</code> attribute, and to implement the required <code>wrappedValue</code> property (which once again could be done as a computed property):</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper</span>\n<span class=\"s-keyword\">struct</span> LossyCodableList&lt;Element&gt; {\n    <span class=\"s-keyword\">var</span> elements: [<span class=\"s-type\">Element</span>]\n\n    <span class=\"s-keyword\">var</span> wrappedValue: [<span class=\"s-type\">Element</span>] {\n        <span class=\"s-keyword\">get</span> { elements }\n        <span class=\"s-keyword\">set</span> { elements = newValue }\n    }\n}</code></pre><p>With the above in place, we’ll now be able to mark <em>any</em> <code>Array</code>-based property with the <code>@LossyCodableList</code> attribute, and it’ll be lossily encoded and decoded — comparably transparently:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Item</span> {\n    <span class=\"s-keyword\">struct</span> Collection: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">@LossyCodableList</span> <span class=\"s-keyword\">var</span> items: [<span class=\"s-type\">Item</span>]\n    }\n}</code></pre><p>Of course, we’ll still be able to keep using <code>LossyCodableList</code> as a stand-alone type, just like we did before. All that we’ve done by turning it into a property wrapper is to <em>also</em> enable it to be used that way, which once again gives us a lot of added flexibility without any real cost.</p><h2>Conclusion</h2><p>At first glance, Codable might seem like an incredibly strict and somewhat limited API that either succeeds or fails, without any room for nuance or customization. However, once we get past the surface level, Codable is actually incredibly powerful, and can be customized in <a href=\"https://www.swiftbysundell.com/articles/customizing-codable-types-in-swift\">lots of different ways</a>.</p><p>Silently ignoring invalid elements is definitely not <em>always</em> the right approach — very often we <em>do</em> want our coding processes to fail whenever any invalid data was encountered — but when that’s not the case, then either of the techniques used in this article can provide a great way to make our coding code more flexible and lossy without introducing a ton of additional complexity.</p><p>If you’ve got any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>. If you want to, you can also support my work by either checking out the above sponsor, or by sharing this article to help more people discover it.</p><p>Thanks for reading!</p>",
      "summary": "How elements containing missing or invalid data can be automatically ignored when using Swift’s Codable API to parse JSON.",
      "date_published": "2021-02-22T18:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code",
      "url": "https://www.swiftbysundell.com/articles/unit-testing-combine-based-swift-code",
      "title": "Unit testing Combine-based Swift code",
      "content_html": "<p>Testing asynchronous code is often particularly tricky, and code written using Apple’s Combine framework is no exception. Since each XCTest-based unit test executes in a purely synchronous fashion, we have to find ways to tell the test runner to await the output of the various asynchronous calls that we’re looking to test — otherwise their output won’t be available until <em>after</em> our tests have already finished executing.</p><p>So, in this article, let’s take a look at how to do just that when it comes to code that’s based on Combine publishers, and also how we can augment Combine’s built-in API with a few utilities that’ll heavily improve its testing ergonomics.</p><h2>Awaiting expectations</h2><p>As an example, let’s say that we’ve been working on a <code>Tokenizer</code> that can be used to identify various tokens within a string (such as usernames, URLs, hashtags, and so on). Since we’re looking to tokenize strings of varying length and complexity, we’ve opted to make our <code>Tokenizer</code> perform its work on a background thread, and to then use Combine to asynchronously report what tokens that it found within a given <code>String</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Tokenizer {\n    <span class=\"s-keyword\">func</span> tokenize(<span class=\"s-keyword\">_</span> string: <span class=\"s-type\">String</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Token</span>], <span class=\"s-type\">Error</span>&gt; {\n        ...\n    }\n}</code></pre><p>Now let’s say that we wanted to write a series of tests to verify that our tokenization logic works as indented, and since the above API is asynchronous, we’re going to have to do a little bit of work to ensure that those tests will execute predictably.</p><p>Like we took a look at in <em><a href=\"https://www.swiftbysundell.com/articles/unit-testing-asynchronous-swift-code/\">“Unit testing asynchronous Swift code”</a></em>, XCTest’s <em>expectations</em> system enables us to tell the test runner to await the result of an asynchronous call by creating, awaiting and fulfilling an <code>XCTestExpectation</code> instance. So let’s use that system, along with Combine’s <code>sink</code> operator, to write our first test like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> TokenizerTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">private var</span> cancellables: <span class=\"s-type\">Set</span>&lt;<span class=\"s-type\">AnyCancellable</span>&gt;!\n\n    <span class=\"s-keyword\">override func</span> setUp() {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">setUp</span>()\n        cancellables = []\n    }\n\n    <span class=\"s-keyword\">func</span> testIdentifyingUsernames() {\n        <span class=\"s-keyword\">let</span> tokenizer = <span class=\"s-type\">Tokenizer</span>()\n    \n        <span class=\"s-comment\">// Declaring local variables that we'll be able to write\n        // our output to, as well as an expectation that we'll\n        // use to await our asynchronous result:</span>\n        <span class=\"s-keyword\">var</span> tokens = [<span class=\"s-type\">Token</span>]()\n        <span class=\"s-keyword\">var</span> error: <span class=\"s-type\">Error</span>?\n        <span class=\"s-keyword\">let</span> expectation = <span class=\"s-keyword\">self</span>.<span class=\"s-call\">expectation</span>(description: <span class=\"s-string\">\"Tokenization\"</span>)\n\n        <span class=\"s-comment\">// Setting up our Combine pipeline:</span>\n        tokenizer\n            .<span class=\"s-call\">tokenize</span>(<span class=\"s-string\">\"Hello @john\"</span>)\n            .<span class=\"s-call\">sink</span>(receiveCompletion: { completion <span class=\"s-keyword\">in\n                switch</span> completion {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">finished</span>:\n                    <span class=\"s-keyword\">break\n                case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> encounteredError):\n                    error = encounteredError\n                }\n\n                <span class=\"s-comment\">// Fullfilling our expectation to unblock\n                // our test execution:</span>\n                expectation.<span class=\"s-call\">fulfill</span>()\n            }, receiveValue: { value <span class=\"s-keyword\">in</span>\n                tokens = value\n            })\n            .<span class=\"s-call\">store</span>(in: &amp;cancellables)\n\n        <span class=\"s-comment\">// Awaiting fulfilment of our expecation before\n        // performing our asserts:</span>\n        <span class=\"s-call\">waitForExpectations</span>(timeout: <span class=\"s-number\">10</span>)\n\n        <span class=\"s-comment\">// Asserting that our Combine pipeline yielded the\n        // correct output:</span>\n        <span class=\"s-call\">XCTAssertNil</span>(error)\n        <span class=\"s-call\">XCTAssertEqual</span>(tokens, [.<span class=\"s-call\">text</span>(<span class=\"s-string\">\"Hello \"</span>), .<span class=\"s-dotAccess\">username</span>(<span class=\"s-string\">\"john\"</span>)])\n    }\n}</code></pre><p>While the above test works perfectly fine, it’s arguably not that pleasant to read, and it involves a lot of boilerplate code that we’ll likely have to repeat within every single <code>Tokenizer</code> test that we’ll write.</p><h2>A dedicated method for awaiting the output of a publisher</h2><p>So let’s address those issues by introducing a variant of the <code>await</code> method from <em><a href=\"https://www.swiftbysundell.com/articles/asyncawait-in-swift-unit-tests\">“Async/await in Swift unit tests”</a></em>, which essentially moves all of the setup code required to observe and await the result of a publisher into a dedicated <code>XCTestCase</code> method:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> await&lt;T: <span class=\"s-type\">Publisher</span>&gt;(\n        <span class=\"s-keyword\">_</span> publisher: <span class=\"s-type\">T</span>,\n        timeout: <span class=\"s-type\">TimeInterval</span> = <span class=\"s-number\">10</span>,\n        file: <span class=\"s-type\">StaticString</span> = <span class=\"s-keyword\">#file</span>,\n        line: <span class=\"s-type\">UInt</span> = <span class=\"s-keyword\">#line</span>\n    ) <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">T</span>.<span class=\"s-type\">Output</span> {\n        <span class=\"s-comment\">// This time, we use Swift's Result type to keep track\n        // of the result of our Combine pipeline:</span>\n        <span class=\"s-keyword\">var</span> result: <span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">T</span>.<span class=\"s-type\">Output</span>, <span class=\"s-type\">Error</span>&gt;?\n        <span class=\"s-keyword\">let</span> expectation = <span class=\"s-keyword\">self</span>.<span class=\"s-call\">expectation</span>(description: <span class=\"s-string\">\"Awaiting publisher\"</span>)\n\n        <span class=\"s-keyword\">let</span> cancellable = publisher.<span class=\"s-call\">sink</span>(\n            receiveCompletion: { completion <span class=\"s-keyword\">in\n                switch</span> completion {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    result = .<span class=\"s-call\">failure</span>(error)\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">finished</span>:\n                    <span class=\"s-keyword\">break</span>\n                }\n\n                expectation.<span class=\"s-call\">fulfill</span>()\n            },\n            receiveValue: { value <span class=\"s-keyword\">in</span>\n                result = .<span class=\"s-call\">success</span>(value)\n            }\n        )\n\n        <span class=\"s-comment\">// Just like before, we await the expectation that we\n        // created at the top of our test, and once done, we\n        // also cancel our cancellable to avoid getting any\n        // unused variable warnings:</span>\n        <span class=\"s-call\">waitForExpectations</span>(timeout: timeout)\n        cancellable.<span class=\"s-call\">cancel</span>()\n\n        <span class=\"s-comment\">// Here we pass the original file and line number that\n        // our utility was called at, to tell XCTest to report\n        // any encountered errors at that original call site:</span>\n        <span class=\"s-keyword\">let</span> unwrappedResult = <span class=\"s-keyword\">try</span> <span class=\"s-type\">XCTUnwrap</span>(\n            result,\n            <span class=\"s-string\">\"Awaited publisher did not produce any output\"</span>,\n            file: file,\n            line: line\n        )\n\n        <span class=\"s-keyword\">return try</span> unwrappedResult.<span class=\"s-call\">get</span>()\n    }\n}</code></pre><p class=\"info\">To learn more about the <code>XCTUnwrap</code> function used above, check out <a href=\"https://www.swiftbysundell.com/articles/avoiding-force-unwrapping-in-swift-unit-tests/\">“Avoiding force unwrapping in Swift unit tests”</a>.</p><p>With the above in place, we’ll now be able to drastically simplify our original test, which can now be implemented using just a few lines of code:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> TokenizerTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testIdentifyingUsernames() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> tokenizer = <span class=\"s-type\">Tokenizer</span>()\n        <span class=\"s-keyword\">let</span> tokens = <span class=\"s-keyword\">try</span> <span class=\"s-call\">await</span>(tokenizer.<span class=\"s-call\">tokenize</span>(<span class=\"s-string\">\"Hello @john\"</span>))\n        <span class=\"s-call\">XCTAssertEqual</span>(tokens, [.<span class=\"s-call\">text</span>(<span class=\"s-string\">\"Hello \"</span>), .<span class=\"s-dotAccess\">username</span>(<span class=\"s-string\">\"john\"</span>)])\n    }\n}</code></pre><p>Much better! However, one thing that we have to keep in mind is that our new <code>await</code> method assumes that each publisher passed into it will eventually complete, and it also only captures the latest value that the publisher emitted. So while it’s incredibly useful for publishers that adhere to the classic request/response model, we might need a slightly different set of tools to test publishers that continuously emit new values.</p><h2>Testing published properties</h2><p>A very common example of publishers that never complete and that keep emitting new values are <em><a href=\"https://www.swiftbysundell.com/articles/published-properties-in-swift\">published properties</a></em>. For example, let’s say that we’ve now wrapped our <code>Tokenizer</code> into an <code>ObservableObject</code> that can be used within our UI code, which might look something like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EditorViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> tokens = [<span class=\"s-type\">Token</span>]()\n    <span class=\"s-keyword\">@Published var</span> string = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">private let</span> tokenizer = <span class=\"s-type\">Tokenizer</span>()\n\n    <span class=\"s-keyword\">init</span>() {\n        <span class=\"s-comment\">// Every time that a new string is assigned, we pass\n        // that new value to our tokenizer, and we then assign\n        // the result of that operation to our 'tokens' property:</span>\n        <span class=\"s-property\">$string</span>\n            .<span class=\"s-call\">flatMap</span>(tokenizer.<span class=\"s-property\">tokenize</span>)\n            .<span class=\"s-call\">replaceError</span>(with: [])\n            .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$tokens</span>)\n    }\n}</code></pre><p class=\"info\">Note how we currently replace all errors with an empty array of tokens, in order to be able to assign our publisher directly to our <code>tokens</code> property. Alternatively, we could’ve used an operator like <code>catch</code> to perform more custom error handling, or to propagate any encountered error to the UI.</p><p>Now let’s say that we’d like to write a test that ensures that our new <code>EditorViewModel</code> keeps publishing new <code>[Token]</code> values as its <code>string</code> property is modified, which means that we’re no longer just interested in a <em>single</em> output value, but rather multiple ones.</p><p>An initial idea on how to handle that, while still being able to use our <code>await</code> method from before, might be to use Combine’s <code>collect</code> operator to emit a single array containing all of the values that our view model’s <code>tokens</code> property will publish, and to then perform a series of verifications on that array — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EditorViewModelTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testTokenizingMultipleStrings() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> viewModel = <span class=\"s-type\">EditorViewModel</span>()\n        \n        <span class=\"s-comment\">// Here we collect the first two [Token] values that\n        // our published property emitted:</span>\n        <span class=\"s-keyword\">let</span> tokenPublisher = viewModel.<span class=\"s-property\">$tokens</span>\n            .<span class=\"s-call\">collect</span>(<span class=\"s-number\">2</span>)\n            .<span class=\"s-call\">first</span>()\n    \n        <span class=\"s-comment\">// Triggering our underlying Combine pipeline by assigning\n        // new strings to our view model:</span>\n        viewModel.<span class=\"s-property\">string</span> = <span class=\"s-string\">\"Hello @john\"</span>\n        viewModel.<span class=\"s-property\">string</span> = <span class=\"s-string\">\"Check out #swift\"</span>\n\n        <span class=\"s-comment\">// Once again we wait for our publisher to complete before\n        // performing assertions on its output:</span>\n        <span class=\"s-keyword\">let</span> tokenArrays = <span class=\"s-keyword\">try</span> <span class=\"s-call\">await</span>(tokenPublisher)\n        <span class=\"s-call\">XCTAssertEqual</span>(tokenArrays.<span class=\"s-property\">count</span>, <span class=\"s-number\">2</span>)\n        <span class=\"s-call\">XCTAssertEqual</span>(tokenArrays.<span class=\"s-property\">first</span>, [.<span class=\"s-call\">text</span>(<span class=\"s-string\">\"Hello \"</span>), .<span class=\"s-dotAccess\">username</span>(<span class=\"s-string\">\"john\"</span>)])\n        <span class=\"s-call\">XCTAssertEqual</span>(tokenArrays.<span class=\"s-property\">last</span>, [.<span class=\"s-call\">text</span>(<span class=\"s-string\">\"Check out \"</span>), .<span class=\"s-dotAccess\">hashtag</span>(<span class=\"s-string\">\"swift\"</span>)])\n    }\n}</code></pre><p>However, the above test currently fails, since the first element within our <code>tokenArrays</code> output value will be an empty array. That’s because all <code>@Published</code>-marked properties always emit their <em>current value</em> when a subscriber is attached to them, meaning that the above <code>tokenPublisher</code> will always receive our <code>tokens</code> property’s initial value (an empty array) as its first input value.</p><p>Thankfully, that problem is quite easily fixed, since Combine ships with a dedicated operator that lets us ignore the first output element that a given publisher will produce — <code>dropFirst</code>. So if we simply insert that operator as the first step within our local publisher’s pipeline, then our test will now successfully pass:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EditorViewModelTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testTokenizingMultipleStrings() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> viewModel = <span class=\"s-type\">EditorViewModel</span>()\n        <span class=\"s-keyword\">let</span> tokenPublisher = viewModel.<span class=\"s-property\">$tokens</span>\n            .<span class=\"s-call\">dropFirst</span>()\n            .<span class=\"s-call\">collect</span>(<span class=\"s-number\">2</span>)\n            .<span class=\"s-call\">first</span>()\n\n        viewModel.<span class=\"s-property\">string</span> = <span class=\"s-string\">\"Hello @john\"</span>\n        viewModel.<span class=\"s-property\">string</span> = <span class=\"s-string\">\"Check out #swift\"</span>\n\n        <span class=\"s-keyword\">let</span> tokenArrays = <span class=\"s-keyword\">try</span> <span class=\"s-call\">await</span>(tokenPublisher)\n        <span class=\"s-call\">XCTAssertEqual</span>(tokenArrays.<span class=\"s-property\">count</span>, <span class=\"s-number\">2</span>)\n        <span class=\"s-call\">XCTAssertEqual</span>(tokenArrays.<span class=\"s-property\">first</span>, [.<span class=\"s-call\">text</span>(<span class=\"s-string\">\"Hello \"</span>), .<span class=\"s-dotAccess\">username</span>(<span class=\"s-string\">\"john\"</span>)])\n        <span class=\"s-call\">XCTAssertEqual</span>(tokenArrays.<span class=\"s-property\">last</span>, [.<span class=\"s-call\">text</span>(<span class=\"s-string\">\"Check out \"</span>), .<span class=\"s-dotAccess\">hashtag</span>(<span class=\"s-string\">\"swift\"</span>)])\n    }\n}</code></pre><p>However, we’re once again at a point where it would be quite tedious (and error prone) to have to write the above set of operators for each published property that we’re looking to write tests against — so let’s write another utility that’ll do that work for us. This time, we’ll extend the <code>Published</code> type’s nested <code>Publisher</code> directly, since we’re only looking to perform this particular operation when testing published properties:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Published</span>.<span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> collectNext(<span class=\"s-keyword\">_</span> count: <span class=\"s-type\">Int</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Output</span>], <span class=\"s-type\">Never</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-call\">dropFirst</span>()\n            .<span class=\"s-call\">collect</span>(count)\n            .<span class=\"s-call\">first</span>()\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>With the above in place, we’ll now be able to easily collect the <code>N</code> number of next values that a given published property will emit within any of our unit tests:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EditorViewModelTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testTokenizingMultipleStrings() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> viewModel = <span class=\"s-type\">EditorViewModel</span>()\n        <span class=\"s-keyword\">let</span> tokenPublisher = viewModel.<span class=\"s-property\">$tokens</span>.<span class=\"s-call\">collectNext</span>(<span class=\"s-number\">2</span>)\n        ...\n    }\n}</code></pre><h2>Conclusion</h2><p>Even though Combine’s stream-driven design might differ quite a bit from other kinds of asynchronous code that we might be used to (such as using completion handler closures, or something like <a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift/\">Futures and Promises</a>), we can still use XCTest’s asynchronous testing tools when verifying our Combine-based logic as well. Hopefully this article has given you a few ideas on how to do just that, and how we can make writing such tests much simpler by introducing a few lightweight utilities.</p><p>If you’ve got questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>. Thanks for reading, and happy testing!</p>",
      "summary": "How to unit test code that’s based on Combine publishers, and how Combine’s built-in API can be augmented with test-specific utilities.",
      "date_published": "2021-02-19T16:08:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/91",
      "url": "https://www.swiftbysundell.com/podcast/91",
      "title": "Podcast: “Is SwiftUI ready for production?”, with special guest David Smith",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell91.mp3\" type=\"audio/mpeg\"/></audio><p>David Smith, creator of apps like Widgetsmith, returns to the show to discuss whether SwiftUI is currently capable and stable enough to build production-level apps, and what sort of things that can be good to keep in mind when starting to deploy SwiftUI in production.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Incredibly useful bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to start your free trial.</li><li><strong><a href=\"https://clubhouse.io/sundell\">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s built specifically for software teams. Try it for free for two months at <a href=\"https://clubhouse.io/sundell\">clubhouse.io/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/_davidsmith\">David on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://apps.apple.com/us/app/widgetsmith/id1523682319\">Widgetsmith</a></li><li><a href=\"https://apps.apple.com/us/app/watchsmith/id1483088503\">Watchsmith</a></li><li><a href=\"https://www.relay.fm/radar\">Under the Radar</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/60\">The previous episode with David</a></li><li><a href=\"https://wwdcbysundell.com/2020/building-entire-apps-with-swiftui\">The new SwiftUI-based app lifecycle</a></li><li><a href=\"https://apps.apple.com/us/app/sleep/id1038440371\">Sleep++</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-2/#geometry-preferences-and-layout-dependencies\">Using the SwiftUI preferences system to build layouts</a></li><li><a href=\"https://www.swiftbysundell.com/questions/syncing-the-width-or-height-of-two-swiftui-views\">Syncing the width or height of two SwiftUI views</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/geometryreader\">GeometryReader</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\">SwiftUI and UIKit interoperability</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-and-modifying-the-environment\">SwiftUI’s environment API</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-objects\">ObservableObject</a></li><li><a href=\"https://www.swiftbysundell.com/articles/avoiding-singletons-in-swift\">Avoiding singletons in Swift</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "David Smith, creator of apps like Widgetsmith, returns to the show to discuss whether SwiftUI is currently capable and stable enough to build production-level apps, and what sort of things that can be good to keep in mind when starting to deploy SwiftUI in production.",
      "date_published": "2021-02-15T16:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/chained-implicit-member-expressions",
      "url": "https://www.swiftbysundell.com/tips/chained-implicit-member-expressions",
      "title": "Chained implicit member expressions in Swift 5.4",
      "content_html": "<p><strong>New in Swift 5.4:</strong> Implicit member expressions (also known as “dot syntax”) can now be used even when accessing a property or method on the result of such an expression, as long as the final return type remains the same.</p><p>What that means in practice is that whenever we’re creating an object or value using a static API, or when referencing an enum case, we can now directly call a method or property on that instance, and the compiler will still be able to infer what type that we’re referring to.</p><p>As an example, when creating a <code>UIColor</code> instance using one of the built-in, static APIs that ship as part of the system, we can now easily modify the alpha component of such a color without having to explicitly refer to <code>UIColor</code> itself in situations like this:</p><pre class=\"splash\"><code><span class=\"s-comment\">// In Swift 5.3 and earlier, an explicit type reference is always\n// required when dealing with chained expressions:</span>\n<span class=\"s-keyword\">let</span> view = <span class=\"s-type\">UIView</span>()\nview.<span class=\"s-property\">backgroundColor</span> = <span class=\"s-type\">UIColor</span>.<span class=\"s-property\">blue</span>.<span class=\"s-call\">withAlphaComponent</span>(<span class=\"s-number\">0.5</span>)\n...\n\n<span class=\"s-comment\">// In Swift 5.4, the type of our expression can now be inferred:</span>\n<span class=\"s-keyword\">let</span> view = <span class=\"s-type\">UIView</span>()\nview.<span class=\"s-property\">backgroundColor</span> = .<span class=\"s-property\">blue</span>.<span class=\"s-call\">withAlphaComponent</span>(<span class=\"s-number\">0.5</span>)\n...</code></pre><p>Of course, the above approach also works when using our own static APIs as well, for example any custom <code>UIColor</code> definitions that we’ve added by using an extension:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">UIColor</span> {\n    <span class=\"s-keyword\">static var</span> chiliRed: <span class=\"s-type\">UIColor</span> {\n        <span class=\"s-type\">UIColor</span>(red: <span class=\"s-number\">0.89</span>, green: <span class=\"s-number\">0.24</span>, blue: <span class=\"s-number\">0.16</span>, alpha: <span class=\"s-number\">1</span>)\n    }\n}\n\n<span class=\"s-keyword\">let</span> view = <span class=\"s-type\">UIView</span>()\nview.<span class=\"s-property\">backgroundColor</span> = .<span class=\"s-property\">chiliRed</span>.<span class=\"s-call\">withAlphaComponent</span>(<span class=\"s-number\">0.5</span>)\n...</code></pre><p>Perhaps even more interesting, though, are what doors that this new capability opens in terms of API design. As an example, in <em><a href=\"https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift\">“Lightweight API design in Swift”</a></em>, we took a look at the following API style, which involves extending a struct with static methods and properties that enables us to use it in a very “enum-like” way:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageFilter</span> {\n    <span class=\"s-keyword\">static var</span> dramatic: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">ImageFilter</span>(\n            name: <span class=\"s-string\">\"Dramatic\"</span>,\n            icon: .<span class=\"s-dotAccess\">drama</span>,\n            transforms: [\n                .<span class=\"s-call\">portrait</span>(withZoomMultipler: <span class=\"s-number\">2.1</span>),\n                .<span class=\"s-dotAccess\">contrastBoost</span>,\n                .<span class=\"s-call\">grayScale</span>(withBrightness: .<span class=\"s-dotAccess\">dark</span>)\n            ]\n        )\n    }\n}</code></pre><p>When using Swift 5.4 (or later versions in the future), we might now add something like the following — which lets us easily combine two <code>ImageFilter</code> instances by concatenating their <code>transforms</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ImageFilter</span> {\n    <span class=\"s-keyword\">func</span> combined(with filter: <span class=\"s-type\">Self</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-keyword\">var</span> newFilter = <span class=\"s-keyword\">self</span>\n        newFilter.<span class=\"s-property\">transforms</span> += filter.<span class=\"s-property\">transforms</span>\n        <span class=\"s-keyword\">return</span> newFilter\n    }\n}</code></pre><p>With the above in place, we’ll now be able to work with dynamically combined filters using the same lightweight dot syntax as we could previously only use when referencing a single, pre-defined filter:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> filtered = image.<span class=\"s-call\">withFilter</span>(.<span class=\"s-dotAccess\">dramatic</span>.<span class=\"s-call\">combined</span>(with: .<span class=\"s-dotAccess\">invert</span>))</code></pre><p>Pretty cool! I’m going to keep exploring what kind of APIs that this new language feature enables me to design, and I’ll of course keep sharing my learnings with you through future articles and <a href=\"https://www.swiftbysundell.com/podcast\">podcast episodes</a>.</p><p>Like always, let me know if you have any questions or feedback by reaching out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>. Thanks for reading!</p>",
      "summary": "How implicit member expression can now be chained, and what sort of APIs that this new feature might enable us to design.",
      "date_published": "2021-02-09T15:50:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/combine-self-cancellable-memory-management",
      "url": "https://www.swiftbysundell.com/articles/combine-self-cancellable-memory-management",
      "title": "Managing self and cancellable references when using Combine",
      "content_html": "<p>Memory management is often especially tricky when dealing with asynchronous operations, as those tend to require us to keep certain objects in memory beyond the scope in which they were defined, while still making sure that those objects <em>eventually</em> get deallocated in a predictable way.</p><p>Although Apple’s <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine framework</a> <em>can</em> make it somewhat simpler to manage such long-living references — as it encourages us to model our asynchronous code as pipelines, rather than a series of nested closures — there are still a number of potential memory management pitfalls that we have to constantly look out for.</p><p>In this article, let’s take a look at how some of those pitfalls can be avoided, specifically when it comes to <code>self</code> and <code>Cancellable</code> references.</p><h2>A cancellable manages the lifetime of a subscription</h2><p>Combine’s <code>Cancellable</code> protocol (which we typically interact with through its <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift\">type-erased</a> <code>AnyCancellable</code> wrapper) lets us control how long a given subscription should stay alive and active. Like its name implies, as soon as a cancellable is deallocated (or manually cancelled), the subscription that it’s tied to is automatically invalidated — which is why almost all of Combine’s subscription APIs (like <code>sink</code>) return an <code>AnyCancellable</code> when called.</p><p>For example, the following <code>Clock</code> type holds a strong reference to the <code>AnyCancellable</code> instance that it gets back from calling <code>sink</code> on a <code>Timer</code> publisher, which keeps that subscription active for as long as its <code>Clock</code> instance remains in memory — unless the cancellable is manually removed by setting its property to <code>nil</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> Clock: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> time = <span class=\"s-type\">Date</span>().<span class=\"s-property\">timeIntervalSince1970</span>\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    <span class=\"s-keyword\">func</span> start() {\n        cancellable = <span class=\"s-type\">Timer</span>.<span class=\"s-call\">publish</span>(\n            every: <span class=\"s-number\">1</span>,\n            on: .<span class=\"s-dotAccess\">main</span>,\n            in: .<span class=\"s-dotAccess\">default</span>\n        )\n        .<span class=\"s-call\">autoconnect</span>()\n        .<span class=\"s-call\">sink</span> { date <span class=\"s-keyword\">in\n            self</span>.<span class=\"s-property\">time</span> = date.<span class=\"s-property\">timeIntervalSince1970</span>\n        }\n    }\n\n    <span class=\"s-keyword\">func</span> stop() {\n        cancellable = <span class=\"s-keyword\">nil</span>\n    }\n}</code></pre><p>However, while the above implementation perfectly manages its <code>AnyCancellable</code> instance and the <code>Timer</code> subscription that it represents, it does have quite a major flaw in terms of memory management. Since we’re capturing <code>self</code> strongly within our <code>sink</code> closure, and since our cancellable (which is, in turn, owned by <code>self</code>) will keep that subscription alive for as long as it remains in memory, we’ll end up with a <em><a href=\"https://www.swiftbysundell.com/basics/memory-management\">retain cycle</a></em> — or in other words, a memory leak.</p><h2>Avoiding self-related memory leaks</h2><p>An initial idea on how to fix that problem might be to instead use Combine’s <code>assign</code> operator (along with a quick <code>Data</code>-to-<code>TimeInterval</code> transformation using <code>map</code>) to be able to assign the result of our pipeline directly to our clock’s <code>time</code> property — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> Clock: <span class=\"s-type\">ObservableObject</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> start() {\n        cancellable = <span class=\"s-type\">Timer</span>.<span class=\"s-call\">publish</span>(\n            every: <span class=\"s-number\">1</span>,\n            on: .<span class=\"s-dotAccess\">main</span>,\n            in: .<span class=\"s-dotAccess\">default</span>\n        )\n        .<span class=\"s-call\">autoconnect</span>()\n        .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">timeIntervalSince1970</span>)\n        .<span class=\"s-call\">assign</span>(to: \\.<span class=\"s-property\">time</span>, on: <span class=\"s-keyword\">self</span>)\n    }\n\n    ...\n}</code></pre><p>However, the above approach will still cause <code>self</code> to be retained, as the <code>assign</code> operator keeps a strong reference to each object that’s passed to it. Instead, with our current setup, we’ll have to resort to a good old fashioned “<code>weak self</code> dance” in order to capture a weak reference to our enclosing <code>Clock</code> instance, which will break our retain cycle:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> Clock: <span class=\"s-type\">ObservableObject</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> start() {\n        cancellable = <span class=\"s-type\">Timer</span>.<span class=\"s-call\">publish</span>(\n            every: <span class=\"s-number\">1</span>,\n            on: .<span class=\"s-dotAccess\">main</span>,\n            in: .<span class=\"s-dotAccess\">default</span>\n        )\n        .<span class=\"s-call\">autoconnect</span>()\n        .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">timeIntervalSince1970</span>)\n        .<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] time <span class=\"s-keyword\">in\n            self</span>?.<span class=\"s-property\">time</span> = time\n        }\n    }\n\n    ...\n}</code></pre><p>With the above in place, each <code>Clock</code> instance can now be deallocated once it’s no longer referenced by any other object, which in turn will cause our <code>AnyCancellable</code> to be deallocated as well, and our Combine pipeline will be properly dissolved. Great!</p><h2>Assigning output values directly to a Published property</h2><p>Another option that can be great to keep in mind is that (as of iOS 14 and macOS Big Sur) we can also connect a Combine pipeline <em>directly</em> to a <em><a href=\"https://www.swiftbysundell.com/articles/published-properties-in-swift\">published property</a></em>. However, while doing so can be incredibly convenient in a number of different situations, that approach doesn’t give us an <code>AnyCancellable</code> back — meaning that we won’t have any means to cancel such a subscription.</p><p>In the case of our <code>Clock</code> type, we might still be able to use that approach — if we’re fine with removing our <code>start</code> and <code>stop</code> methods, and instead automatically start each clock upon initialization, since otherwise we might end up with duplicate subscriptions. If those are tradeoffs that we’re willing to accept, then we could change our implementation into this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> Clock: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> time = <span class=\"s-type\">Date</span>().<span class=\"s-property\">timeIntervalSince1970</span>\n\n    <span class=\"s-keyword\">init</span>() {\n        <span class=\"s-type\">Timer</span>.<span class=\"s-call\">publish</span>(\n            every: <span class=\"s-number\">1</span>,\n            on: .<span class=\"s-dotAccess\">main</span>,\n            in: .<span class=\"s-dotAccess\">default</span>\n        )\n        .<span class=\"s-call\">autoconnect</span>()\n        .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">timeIntervalSince1970</span>)\n        .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$time</span>)\n    }\n}</code></pre><p class=\"info\">When calling the above flavor of <code>assign</code>, we’re passing a direct reference to our <code>Published</code> property’s <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift/#projected-values\">projected value</a>, prefixed with an ampersand to make that value mutable (since <code>assign</code> uses the <code>inout</code> keyword). To learn more about that pattern, check out the Basics article about <a href=\"https://www.swiftbysundell.com/basics/value-and-reference-types\">value and reference types</a>.</p><p>The beauty of the above approach is that Combine will now automatically manage our subscription based on the lifetime of our <code>time</code> property — meaning that we’re still avoiding any reference cycles while also significantly reducing the amount of bookkeeping code that we have to write ourselves. So for pipelines that are only configured once, and are directly tied to a <code>Published</code> property, using the above overload of the <code>assign</code> operator can often be a great choice.</p><h2>Weak property assignments</h2><p>Next, let’s take a look at a slightly more complex example, in which we’ve implemented a <code>ModelLoader</code> that lets us load and decode a <code>Decodable</code> model from a given <code>URL</code>. By using a single <code>cancellable</code> property, our loader can automatically cancel any previous data loading pipeline when a new one is triggered — as any previously assigned <code>AnyCancellable</code> instance will be deallocated when that property’s value is replaced.</p><p>Here’s what that <code>ModelLoader</code> type currently looks like:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ModelLoader&lt;Model: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">enum</span> State {\n        <span class=\"s-keyword\">case</span> idle\n        <span class=\"s-keyword\">case</span> loading\n        <span class=\"s-keyword\">case</span> loaded(<span class=\"s-type\">Model</span>)\n        <span class=\"s-keyword\">case</span> failed(<span class=\"s-type\">Error</span>)\n    }\n\n    <span class=\"s-keyword\">@Published private(set) var</span> state = <span class=\"s-type\">State</span>.<span class=\"s-property\">idle</span>\n\n    <span class=\"s-keyword\">private let</span> url: <span class=\"s-type\">URL</span>\n    <span class=\"s-keyword\">private let</span> session: <span class=\"s-type\">URLSession</span>\n    <span class=\"s-keyword\">private let</span> decoder: <span class=\"s-type\">JSONDecoder</span>\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        cancellable = session\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Model</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">map</span>(<span class=\"s-type\">State</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failed</span>(error))\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] state <span class=\"s-keyword\">in\n                self</span>?.<span class=\"s-property\">state</span> = state\n            }\n    }\n}</code></pre><p>While that automatic cancellation of old requests prevents us from simply connecting the output of our data loading pipeline to our <code>Published</code> property, if we wanted to avoid having to manually capture a weak reference to <code>self</code> every time that we use the above pattern (that is, loading a value and assigning it to a property), we could introduce the following <code>Publisher</code> extension — which adds a weak-capturing version of the standard <code>assign</code> operator that we took a look at earlier:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Failure</span> == <span class=\"s-type\">Never</span> {\n    <span class=\"s-keyword\">func</span> weakAssign&lt;T: <span class=\"s-type\">AnyObject</span>&gt;(\n        to keyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Output</span>&gt;,\n        on object: <span class=\"s-type\">T</span>\n    ) -&gt; <span class=\"s-type\">AnyCancellable</span> {\n        <span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak</span> object] value <span class=\"s-keyword\">in</span>\n            object?[keyPath: keyPath] = value\n        }\n    }\n}</code></pre><p>With the above in place, we can now simply call <code>weakAssign</code> whenever we want to assign the output of a given publisher to a property of an object that’s captured using a weak reference — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ModelLoader&lt;Model: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">ObservableObject</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        cancellable = session\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Model</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">map</span>(<span class=\"s-type\">State</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failed</span>(error))\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">weakAssign</span>(to: \\.<span class=\"s-property\">state</span>, on: <span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p>Is that new <code>weakAssign</code> method purely syntactic sugar? Yes. But is it nicer than what we were using before? Also yes 🙂</p><h2>Capturing stored objects, rather than self</h2><p>Another type of situation that’s quite commonly encountered when working with Combine is when we need to access a specific property within one of our operators, for example in order to perform a nested asynchronous call.</p><p>To illustrate, let’s say that we wanted to extend our <code>ModelLoader</code> by using a <code>Database</code> to automatically store each model that was loaded — an operation that also wraps those model instances using a generic <code>Stored</code> type (for example in order to add local metadata, such as an ID or model version). To be able to access that database instance within an operator like <code>flatMap</code>, we could once again capture a weak reference to <code>self</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ModelLoader&lt;Model: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">enum</span> State {\n        <span class=\"s-keyword\">case</span> idle\n        <span class=\"s-keyword\">case</span> loading\n        <span class=\"s-keyword\">case</span> loaded(<span class=\"s-type\">Stored</span>&lt;<span class=\"s-type\">Model</span>&gt;)\n        <span class=\"s-keyword\">case</span> failed(<span class=\"s-type\">Error</span>)\n    }\n\n    ...\n    <span class=\"s-keyword\">private let</span> database: <span class=\"s-type\">Database</span>\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        cancellable = session\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Model</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">flatMap</span> {\n                [<span class=\"s-keyword\">weak self</span>] model -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Stored</span>&lt;<span class=\"s-type\">Model</span>&gt;, <span class=\"s-type\">Error</span>&gt; <span class=\"s-keyword\">in\n                \n                guard let</span> database = <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">database</span> <span class=\"s-keyword\">else</span> {\n                    <span class=\"s-keyword\">return</span> <span class=\"s-type\">Empty</span>(completeImmediately: <span class=\"s-keyword\">true</span>)\n                        .<span class=\"s-call\">eraseToAnyPublisher</span>()\n                }\n                \n                <span class=\"s-keyword\">return</span> database.<span class=\"s-call\">store</span>(model)\n            }\n            .<span class=\"s-call\">map</span>(<span class=\"s-type\">State</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failed</span>(error))\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">weakAssign</span>(to: \\.<span class=\"s-property\">state</span>, on: <span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p class=\"info\">The reason we use the <code>flatMap</code> operator above is because our database is also asynchronous, and returns another publisher that represents the current saving operation.</p><p>However, like the above example shows, it can sometimes be tricky to come up with a reasonable default value to return from an unwrapping <code>guard</code> statement placed within an operator like <code>map</code> or <code>flatMap</code>. Above we use <code>Empty</code>, which works, but it does add a substantial amount of extra verbosity to our otherwise quite elegant pipeline.</p><p>Thankfully, that problem is quite easy to fix (at least in this case). All that we have to do is to <a href=\"https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics/#weak-references-are-not-always-the-answer\">capture our database property directly</a>, rather than capturing <code>self</code>. That way, we don’t have to deal with any optionals, and can now simply call our database’s <code>store</code> method within our <code>flatMap</code> closure — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ModelLoader&lt;Model: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">ObservableObject</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        cancellable = session\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Model</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">flatMap</span> { [database] model <span class=\"s-keyword\">in</span>\n                database.<span class=\"s-call\">store</span>(model)\n            }\n            .<span class=\"s-call\">map</span>(<span class=\"s-type\">State</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failed</span>(error))\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">weakAssign</span>(to: \\.<span class=\"s-property\">state</span>, on: <span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p>As an added bonus, we could even pass the <code>Database</code> method that we’re looking to call directly into <code>flatMap</code> in this case — since its signature perfectly matches the closure that <code>flatMap</code> expects within this context (and thanks to the fact that Swift supports <a href=\"https://www.swiftbysundell.com/clips/1\">first class functions</a>):</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ModelLoader&lt;Model: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">ObservableObject</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        cancellable = session\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Model</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">flatMap</span>(database.<span class=\"s-property\">store</span>)\n            .<span class=\"s-call\">map</span>(<span class=\"s-type\">State</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failed</span>(error))\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">weakAssign</span>(to: \\.<span class=\"s-property\">state</span>, on: <span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p>So, when possible, it’s typically a good idea to avoid capturing <code>self</code> within our Combine operators, and to instead call other objects that can be stored and directly passed into our various operators as properties.</p><h2>Conclusion</h2><p>While Combine offers many APIs and features that can help us make our asynchronous code easier to write and maintain, it still requires us to be careful when it comes to how we manage our references and their underlying memory. Capturing a strong reference to <code>self</code> in the wrong place can still often lead to a retain cycle, and if a <code>Cancellable</code> is not properly deallocated, then a subscription might stay active for longer than expected.</p><p>Hopefully this article has given you a few new tips and techniques that you can use to prevent memory-related issues when working with <code>self</code> and <code>Cancellable</code> references within your Combine-based projects, and if you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "How to avoid common memory-related issues when working with self and cancellable references within the context of Combine.",
      "date_published": "2021-02-05T17:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/passing-methods-as-swiftui-view-actions",
      "url": "https://www.swiftbysundell.com/tips/passing-methods-as-swiftui-view-actions",
      "title": "Passing methods as SwiftUI view actions",
      "content_html": "<p>Often when working with interactive SwiftUI views, we’re using closures to define the actions that we wish to perform when various events occur. For example, the following <code>AddItemView</code> has two interactive elements, a <code>TextField</code> and a <code>Button</code>, that both enable the user to add a new text-based <code>Item</code> to our app:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AddItemView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> handler: (<span class=\"s-type\">Item</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">@State private var</span> title = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Add item\"</span>,\n                text: <span class=\"s-property\">$title</span>,\n                onCommit: {\n                    <span class=\"s-keyword\">guard</span> !title.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n                        <span class=\"s-keyword\">return</span>\n                    }\n                    \n                    <span class=\"s-keyword\">let</span> item = <span class=\"s-type\">Item</span>(title: title)\n                    <span class=\"s-call\">handler</span>(item)\n                    title = <span class=\"s-string\">\"\"</span>\n                }\n            )\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Add\"</span>) {\n                <span class=\"s-keyword\">let</span> item = <span class=\"s-type\">Item</span>(title: title)\n                <span class=\"s-call\">handler</span>(item)\n                title = <span class=\"s-string\">\"\"</span>\n            }\n            .<span class=\"s-call\">disabled</span>(title.<span class=\"s-property\">isEmpty</span>)\n        }\n    }\n}</code></pre><p>Apart from the leading <code>guard</code> statement within our text field’s <code>onCommit</code> action (which isn’t needed within our button action since we’re disabling the button when the text is empty), our two closures are completely identical, so it would be quite nice to get rid of that source of code duplication by moving those actions away from our view’s <code>body</code>.</p><p>One way to do that would be to create our closures using a computed property. That would let us define our logic once, and if we also include the <code>guard</code> statement that our <code>TextField</code> needs, then we could use the exact same closure implementation for both of our UI controls:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">AddItemView</span> {\n    <span class=\"s-keyword\">var</span> addAction: () -&gt; <span class=\"s-type\">Void</span> {\n        <span class=\"s-keyword\">return</span> {\n            <span class=\"s-keyword\">guard</span> !title.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n                <span class=\"s-keyword\">return</span>\n            }\n\n            <span class=\"s-keyword\">let</span> item = <span class=\"s-type\">Item</span>(title: title)\n            <span class=\"s-call\">handler</span>(item)\n            title = <span class=\"s-string\">\"\"</span>\n        }\n    }\n}</code></pre><p>With the above in place, we can now simply pass our new <code>addAction</code> property to both of our subviews, and we’ve successfully gotten rid of our code duplication, and our view’s <code>body</code> implementation is now much more compact as well:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AddItemView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> handler: (<span class=\"s-type\">Item</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">@State private var</span> title = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Add item\"</span>,\n                text: <span class=\"s-property\">$title</span>,\n                onCommit: addAction\n            )\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Add\"</span>, action: addAction)\n                .<span class=\"s-call\">disabled</span>(title.<span class=\"s-property\">isEmpty</span>)\n        }\n    }\n}</code></pre><p>While the above is a perfectly fine solution, there’s also another option that might not initially be obvious within the context of SwiftUI, and that’s to use the same technique as when using UIKit’s target/action pattern — by defining our action handler as <em>a method</em>, rather than a closure.</p><p>To do that, let’s first refactor our <code>addAction</code> property from before into an <code>addItem</code> method that looks like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">AddItemView</span> {\n    <span class=\"s-keyword\">func</span> addItem() {\n        <span class=\"s-keyword\">guard</span> !title.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span>\n        }\n\n        <span class=\"s-keyword\">let</span> item = <span class=\"s-type\">Item</span>(title: title)\n        <span class=\"s-call\">handler</span>(item)\n        title = <span class=\"s-string\">\"\"</span>\n    }\n}</code></pre><p>Then, just like how we previously passed our <code>addAction</code> property to both our <code>TextView</code> and our <code>Button</code>, we can now do the exact same thing with our <code>addItem</code> method — which gives us the following implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AddItemView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> handler: (<span class=\"s-type\">Item</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">@State private var</span> title = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Add item\"</span>,\n                text: <span class=\"s-property\">$title</span>,\n                onCommit: addItem\n            )\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Add\"</span>, action: addItem)\n                .<span class=\"s-call\">disabled</span>(title.<span class=\"s-property\">isEmpty</span>)\n        }\n    }\n}</code></pre><p>When working with SwiftUI, it’s very common to fall into the trap of thinking that a given view’s layout, subviews and actions all need to be defined within its <code>body</code>, which — if we think about it — is exactly the same type of approach that often led to massive view controllers when working with UIKit.</p><p>However, thanks to SwiftUI’s highly composable design, it’s often quite easy to split a view’s <code>body</code> up into separate pieces, which might not even require any new <code>View</code> types to be created. Sometimes all that we have to do is to extract some of our logic into a separate method, and we’ll end up with much more elegant code that’ll be easier to both read and maintain.</p>",
      "summary": "How event handling logic can be neatly encapsulated using private methods.",
      "date_published": "2021-02-02T15:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/raycast-january-2021",
      "url": "https://www.swiftbysundell.com/sponsor/raycast-january-2021",
      "title": "Sponsor: Raycast",
      "content_html": "<p>Thanks a lot to the indie team behind the fantastic new macOS app <a href=\"https://raycast.com\">Raycast</a> for sponsoring Swift by Sundell last week. Raycast gives you a Spotlight-like interface for controlling your tools, scripts and tasks. It ships with a large collection of built-in integrations, for services like GitHub, Jira, Zoom, and Google Docs, and it also lets you invoke your own custom scripts as well.</p><p>For example, to be able to deploy Swift by Sundell using Raycast, all that I had to do was to write a simple script file containing a few pieces of metadata, and a call to <code>publish deploy</code> — like this:</p><pre><code class=\"no-highlight\">#!/bin/bash\n\n# @raycast.schemaVersion 1\n# @raycast.title Deploy Swift by Sundell\n# @raycast.mode fullOutput\n# @raycast.currentDirectoryPath ~/developer/swiftbysundell\n\npublish deploy</code></pre><p>After importing the above file, I can now simply invoke Raycast using its system-wide keyboard shortcut, type <code>deploy</code> into its search box, and hit return — and Swift by Sundell will be deployed within seconds. Really nice!</p><img src=\"https://www.swiftbysundell.com/images/sponsored-posts/raycast.png\" alt=\"Raycast screenshot\"/><p>Of course, the above just scratches the surface of what Raycast is capable of. You can use it to update GitHub issues and pull requests, search for files in your Google Drive, start or schedule Zoom calls, and much more. It even includes a clipboard manager and lots of other system integrations.</p><p>Try out the <a href=\"https://raycast.com\">completely free Raycast beta</a>, to see how it can help you improve your various workflows, and to support Swift by Sundell.</p>",
      "summary": "Thanks a lot to Raycast for sponsoring Swift by Sundell.",
      "date_published": "2021-02-01T16:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/questions/syncing-the-width-or-height-of-two-swiftui-views",
      "url": "https://www.swiftbysundell.com/questions/syncing-the-width-or-height-of-two-swiftui-views",
      "title": "How to sync the width or height of two SwiftUI views?",
      "content_html": "<p>A quite common, yet surprisingly hard problem to solve when building views using SwiftUI is how to make two dynamic views take on the same width or height. For example, here we’re working on a <code>LoginView</code> that has two buttons — one for logging in, and one that triggers a password reset — which are currently implemented like this:</p><pre data-preview=\"original\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n    \n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n            <span class=\"s-type\">Group</span> {\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                    ...\n                }\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"I forgot my password\"</span>) {\n                    ...\n                }\n            }\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">20</span>)\n        }\n    }\n}</code></pre><p>If you use the above <code>PREVIEW</code> button, you can see that our buttons have different widths, which is to be expected, since they’re displaying two different texts that aren’t equally long. But what if we <em>actually wanted</em> them to have the same width (which would arguably look a lot better) — how could that be achieved?</p><p class=\"info\">We’ll ignore approaches that involve hardcoding the width of our views (which won’t work for most modern apps that are expected to adapt to things like user accessibility settings and localized strings), or manually measuring the size of each underlying string. Instead, we’ll focus on solutions that are more robust and easier to maintain.</p><h2>Infinite frames</h2><p>If we’re fine with having our buttons stretch out to fit the width of the container that they’re displayed in, then one potential solution would be to give both buttons an <em>infinite max width</em>. That can be done using the <code>frame</code> modifier, which when combined with some additional horizontal padding could give us a quite nice result (at least when our <code>LoginView</code> will be displayed in a narrow container, such as when running on a portrait-oriented iPhone):</p><pre data-preview=\"infinite-frames\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n    \n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n            <span class=\"s-type\">Group</span> {\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                    ...\n                }\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"I forgot my password\"</span>) {\n                    ...\n                }\n            }\n            .<span class=\"s-call\">frame</span>(maxWidth: .<span class=\"s-dotAccess\">infinity</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>)\n        }\n    }\n}</code></pre><p class=\"info\">Again, feel free to use the above <code>PREVIEW</code> button to see what the rendered result looks like for that implementation.</p><h2>GeometryReader</h2><p>While we could always use other, more static <code>maxWidth</code> values in order to prevent our buttons from being stretched out too much, perhaps we’d instead like to dynamically compute that value based on the width of our container. To do that, we could use a <code>GeometryReader</code>, which gives us access to the geometry information for the context in which our buttons will be rendered.</p><p>However, a quite substantial downside of using a <code>GeometryReader</code> in this context is that it occupies all of the space that’s available within our UI — meaning that our <code>LoginView</code> could end up becoming much larger than what we’d expect, and we’d also need to make sure that our root <code>VStack</code> ends up stretching all of that available space as well, in order to retain our desired layout.</p><p>Here’s what such an implementation could look like if we wanted our buttons to not be stretched beyond 60% of the total available width:</p><pre data-preview=\"geometry-reader\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">GeometryReader</span> { geometry <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">VStack</span> {\n                ...\n                <span class=\"s-type\">Group</span> {\n                    <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                        ...\n                    }\n                    <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"I forgot my password\"</span>) {\n                        ...\n                    }\n                }\n                .<span class=\"s-call\">frame</span>(maxWidth: geometry.<span class=\"s-property\">size</span>.<span class=\"s-property\">width</span> * <span class=\"s-number\">0.6</span>)\n                .<span class=\"s-call\">padding</span>()\n                .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n                .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">20</span>)\n            }\n            .<span class=\"s-call\">frame</span>(maxWidth: .<span class=\"s-dotAccess\">infinity</span>)\n        }\n    }\n}</code></pre><p>Another potential downside of the above approach is that we have to make sure to pick a width multiplier that will work for all screen and text size combinations, which can sometimes be quite tricky.</p><h2>Using a grid</h2><p>If our app uses iOS 14 or macOS Big Sur as its minimum deployment target, then another potential solution to our width syncing problem would be to use a <code>LazyHGrid</code>. Non-adaptive, horizontal grids automatically sync the width of their cells, which lets us achieve our desired button layout like this:</p><pre data-preview=\"grid\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n            <span class=\"s-type\">LazyHGrid</span>(rows: [buttonRow, buttonRow]) {\n                <span class=\"s-type\">Group</span> {\n                    <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                        ...\n                    }\n                    <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"I forgot my password\"</span>) {\n                        ...\n                    }\n                }\n                .<span class=\"s-call\">frame</span>(maxWidth: .<span class=\"s-dotAccess\">infinity</span>)\n                .<span class=\"s-call\">padding</span>()\n                .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n                .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">20</span>)\n            }\n        }\n    }\n\n    <span class=\"s-keyword\">private var</span> buttonRow: <span class=\"s-type\">GridItem</span> {\n        <span class=\"s-type\">GridItem</span>(.<span class=\"s-call\">flexible</span>(minimum: <span class=\"s-number\">0</span>, maximum: <span class=\"s-number\">80</span>))\n    }\n}</code></pre><p>However, note that while the <em>width</em> of our two buttons is now completely dynamic (and fully synced), we have to hard-code the maximum height of each of our grid’s rows, since otherwise our grid would end up taking up all of the available space (just like a <code>GeometryReader</code>). That might not be an issue in certain situations, but it’s still something to be aware of if we end up using the above solution.</p><h2>Using a preference key</h2><p>Perhaps the most dynamic and robust solution to the problem of syncing the widths or heights of two dynamic views is to use SwiftUI’s <em>preferences system</em> to measure and then send the size of each button to their parent view. To do that, let’s start by creating a <code>PreferenceKey</code>-conforming type that reduces all transmitted button width values by picking the maximum one — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">LoginView</span> {\n    <span class=\"s-keyword\">struct</span> ButtonWidthPreferenceKey: <span class=\"s-type\">PreferenceKey</span> {\n        <span class=\"s-keyword\">static let</span> defaultValue: <span class=\"s-type\">CGFloat</span> = <span class=\"s-number\">0</span>\n\n        <span class=\"s-keyword\">static func</span> reduce(value: <span class=\"s-keyword\">inout</span> <span class=\"s-type\">CGFloat</span>,\n                           nextValue: () -&gt; <span class=\"s-type\">CGFloat</span>) {\n            value = <span class=\"s-call\">max</span>(value, <span class=\"s-call\">nextValue</span>())\n        }\n    }\n}</code></pre><p>With the above in place, we could then embed a <code>GeometryReader</code> within the <code>background</code> of each button (which makes it assume the same size as the button itself), and then send and observe our width values using our new preference key. We’d then store the maximum value in a <code>@State</code>-marked property, which will cause our view to be updated when that value was modified. Here’s what such an implementation could look like:</p><pre data-preview=\"preference-key\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n    <span class=\"s-keyword\">@State private var</span> buttonMaxWidth: <span class=\"s-type\">CGFloat</span>?\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n            <span class=\"s-type\">Group</span> {\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                    ...\n                }\n                <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"I forgot my password\"</span>) {\n                    ...\n                }\n            }\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">GeometryReader</span> { geometry <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Color</span>.<span class=\"s-property\">clear</span>.<span class=\"s-call\">preference</span>(\n                    key: <span class=\"s-type\">ButtonWidthPreferenceKey</span>.<span class=\"s-keyword\">self</span>,\n                    value: geometry.<span class=\"s-property\">size</span>.<span class=\"s-property\">width</span>\n                )\n            })\n            .<span class=\"s-call\">frame</span>(width: buttonMaxWidth)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">20</span>)\n        }\n        .<span class=\"s-call\">onPreferenceChange</span>(<span class=\"s-type\">ButtonWidthPreferenceKey</span>.<span class=\"s-keyword\">self</span>) {\n            buttonMaxWidth = $0\n        }\n    }\n}</code></pre><p class=\"info\">Note that we’re using <code>Color.clear</code> (rather than <code>EmptyView</code>) as the return value within our <code>GeometryReader</code> closure. That’s because <code>EmptyView</code> instances are completely ignored by SwiftUI, which would prevent our preferences values from being sent in this case.</p><p>While the above solution is definitely much more involved than the ones we explored earlier, it does give us the most dynamic solution (by far), since we’re no longer forced to hard-code any aspects of our layout. Instead, our buttons will now adapt according to their labels, which gives us a solution that works across a wide range of screen sizes, languages, and accessibility settings.</p><p class=\"info\">To learn more about the above technique, and many other SwiftUI layout tools, check out my three-part <a href=\"https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1\">guide to the SwiftUI layout system</a>.</p><h2>Conclusion</h2><p>While SwiftUI’s declarative design has many advantages, it does make tasks like the one we explored in this article quite difficult. Neither of the above solutions are really perfect, and things like this could sort of make us wish for an Auto Layout-like constraint-based layout system, which would make it much easier to express that two views should be synced in terms of width or height.</p><p>Regardless, I hope that the above techniques will be helpful when you’re building your SwiftUI views, and feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a> if you have any questions, comments, or feedback.</p><p>Thanks for reading!</p>",
      "summary": "Multiple solutions to one of the most commonly faced problems when working with SwiftUI.",
      "date_published": "2021-01-29T14:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/90",
      "url": "https://www.swiftbysundell.com/podcast/90",
      "title": "Podcast: “The essence of app architecture”, with special guest Matt Gallagher",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell90.mp3\" type=\"audio/mpeg\"/></audio><p>Matt Gallagher, creator of Cocoa with Love, returns to the show to discuss how the introduction of SwiftUI and Combine has impacted how apps are architected on Apple’s platforms, and what sort of principles that are good to keep in mind when designing a solid app architecture.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a>.</li><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Incredibly useful bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to start your free trial.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/cocoawithlove\">Matt on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://cocoawithlove.com\">Cocoa with Love</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/45\">Matt’s previous appearance on the show</a></li><li><a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a></li><li><a href=\"https://github.com/ReactiveX/RxSwift\">RxSwift</a></li><li><a href=\"https://www.swiftbysundell.com/articles/published-properties-in-swift\">Published properties</a></li><li><a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">Function/result builders</a></li><li><a href=\"https://github.com/apple/swift-evolution/blob/main/proposals/0298-asyncsequence.md\">SE-0298: Async/Await: Sequences</a></li><li><a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-futures-and-promises-in-swift\">Futures and Promises</a></li><li><a href=\"https://www.swiftbysundell.com/articles/connecting-and-merging-combine-publishers-in-swift\">Connecting and merging Combine publishers</a></li><li><a href=\"https://www.objc.io/books/app-architecture\">The objc.io App Architecture book</a></li><li><a href=\"https://cocoawithlove.com/blog/coding-through-iteration-and-integration.html\">Matt’s articles about SwiftUI app architecture</a></li><li><a href=\"https://www.swiftbysundell.com/discover/unit-testing\">Unit testing</a></li><li><a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift\">View models</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">SwiftUI’s state management system</a></li><li><a href=\"https://developer.apple.com/documentation/combine/passthroughsubject\">PassthroughSubject</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Matt Gallagher, creator of Cocoa with Love, returns to the show to discuss how the introduction of SwiftUI and Combine has impacted how apps are architected on Apple’s platforms, and what sort of principles that are good to keep in mind when designing a solid app architecture.",
      "date_published": "2021-01-28T19:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/genius-scan-january-2021",
      "url": "https://www.swiftbysundell.com/sponsor/genius-scan-january-2021",
      "title": "Sponsored: Genius Scan’s SDK",
      "content_html": "<p>Thanks a lot to the <a href=\"https://geniusscansdk.com\">Genius Scan</a> team for sponsoring Swift by Sundell (both the website and the podcast!) last week. Their support lets me keep all of Swift by Sundell free for the entire community, which I’m really passionate about.</p><p>You might already know Genius Scan because of their <a href=\"https://apps.apple.com/us/app/genius-scan-pdf-scanner/id377672876\">fantastic iOS app</a> that lets you scan all sorts of documents with really high-quality results. It’s used by millions of people around the world (including me), and now, you can let <em>your users</em> use that same advanced scanning functionality <em>right within your app</em> as well.</p><p>All that you have to do is to include Genius Scan’s <a href=\"https://geniusscansdk.com\">powerful, yet easy to use SDK</a>, which can be integrated into any iOS or Android app with just a single line of code. You can then dive much deeper if you wish, and customize their scanner view to fit your app’s design, and even build completely custom integrations using their suite of lower-level image processing components.</p><p>So if your app involves working with real-life documents of any kind, for example if you’re building something like a todo, finance, or project management app — then I really recommend checking out the <a href=\"https://geniusscansdk.com\">Genius Scan SDK</a>. And, when requesting a demo, simply mention Swift by Sundell, and they’ll give you a 20% discount for a whole year if you eventually end up buying a license.</p>",
      "summary": "Thanks to the Genius Scan team for sponsoring Swift by Sundell.",
      "date_published": "2021-01-25T11:55:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/rounded-corners-uikit-swiftui",
      "url": "https://www.swiftbysundell.com/articles/rounded-corners-uikit-swiftui",
      "title": "Applying rounded corners to a UIKit or SwiftUI view",
      "content_html": "<p>Rounded rectangles have been a core part of Apple’s overall UI design for many years, so when building apps using frameworks like UIKit or SwiftUI, it’s incredibly common to want to apply some form of corner radius to some of the views that we’ll create. Let’s take a quick look at the main APIs that enable us to do just that.</p><h2>UIKit and Core Animation</h2><p>Although UIKit itself doesn’t include any APIs for changing a given view’s corner radius, the fact that each <code>UIView</code> is backed by an underlying <code>CALayer</code> lets us use Core Animation to perform those kinds of tweaks.</p><p>As an example, let’s say that we’re building a button that lets the user advance to the next step within a given flow, which is currently configured like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> button = <span class=\"s-type\">UIButton</span>(type: .<span class=\"s-dotAccess\">custom</span>)\nbutton.<span class=\"s-call\">setTitle</span>(<span class=\"s-string\">\"Next\"</span>, for: .<span class=\"s-dotAccess\">normal</span>)\nbutton.<span class=\"s-call\">setTitleColor</span>(.<span class=\"s-dotAccess\">white</span>, for: .<span class=\"s-dotAccess\">normal</span>)\nbutton.<span class=\"s-property\">backgroundColor</span> = .<span class=\"s-dotAccess\">blue</span>\nbutton.<span class=\"s-property\">contentEdgeInsets</span> = <span class=\"s-type\">UIEdgeInsets</span>(\n    top: <span class=\"s-number\">4</span>,\n    left: <span class=\"s-number\">6</span>,\n    bottom: <span class=\"s-number\">4</span>,\n    right: <span class=\"s-number\">6</span>\n)</code></pre><p>If we then wanted to apply a standard corner radius to each of the above button’s corners, we could do so by modifying the <code>cornerRadius</code> property of its underlying <code>layer</code>:</p><pre data-preview=\"basic\"><code>button.<span class=\"s-property\">layer</span>.<span class=\"s-property\">cornerRadius</span> = <span class=\"s-number\">10</span></code></pre><p class=\"info\">💡 Tip: You can use the <code>PREVIEW</code> button to see the result of the above change.</p><p>While the above technique will work perfectly fine in many different situations, sometimes we might want to customize things further in order to achieve a specific kind of look.</p><p>For example, when applying a somewhat larger amount of corner radius to a given view, using the default settings can result in corners that are perhaps not as smooth as we’d expect. To demonstrate, let’s increase both the font size and the corner radius of our button, and if you use the <code>PREVIEW</code> button below, you can see that our corners now end up having quite a <em>sharp</em> look:</p><pre data-preview=\"large-button\"><code>button.<span class=\"s-property\">titleLabel</span>?.<span class=\"s-property\">font</span> = .<span class=\"s-call\">systemFont</span>(ofSize: <span class=\"s-number\">80</span>)\nbutton.<span class=\"s-property\">layer</span>.<span class=\"s-property\">cornerRadius</span> = <span class=\"s-number\">30</span></code></pre><p>Thankfully, that problem is easy to fix. All that we have to do is to instead use the <code>continuous</code> corner curve when rendering our button’s <code>layer</code>, which will give its corners a smoother look:</p><pre data-preview=\"large-button-smooth\"><code>button.<span class=\"s-property\">layer</span>.<span class=\"s-property\">cornerCurve</span> = .<span class=\"s-dotAccess\">continuous</span></code></pre><p>Another customization option that can be really useful is the <code>maskedCorners</code> property, which lets us control which of our button’s four corners that should be rounded. For example, if we’d like to place our button in the bottom-right corner of the screen, then we might want to only round our button’s top-left corner, which can be done like this:</p><pre data-preview=\"single-corner\"><code>button.<span class=\"s-property\">layer</span>.<span class=\"s-property\">maskedCorners</span> = [.<span class=\"s-dotAccess\">layerMinXMinYCorner</span>]</code></pre><p>Using the above set of properties we can gain quite detailed control over how we’d like a given view’s corners to be rounded, and since Core Animation is what powers all of UIKit (and significant parts of AppKit as well), they’re likely to be useful in many different kinds of situations.</p><h2>SwiftUI</h2><p>SwiftUI might not give us direct access to the layers used to render its views, but it does feature a dedicated modifier that lets us apply a given amount of corner radius to any view — which can be used like this:</p><pre class=\"splash\"><code><span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Next\"</span>) {\n    ...\n}\n.<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n.<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">4</span>)\n.<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">vertical</span>, <span class=\"s-number\">6</span>)\n.<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n.<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)</code></pre><p>However, the above API doesn’t let us tweak any of the other parameters that Core Animation gives us access to, meaning that we’ll have to switch to a different strategy if we’re looking for more customization options.</p><p>For example, one way to use the <em>continuous</em> style to round a view’s corners is to use a <code>RoundedRectangle</code> shape as its <code>background</code>, rather than using a color combined with the <code>cornerRadius</code> modifier:</p><pre class=\"splash\"><code><span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Next\"</span>) {\n    ...\n}\n.<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n.<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">4</span>)\n.<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">vertical</span>, <span class=\"s-number\">6</span>)\n.<span class=\"s-call\">background</span>(\n    <span class=\"s-type\">RoundedRectangle</span>(\n        cornerRadius: <span class=\"s-number\">10</span>,\n        style: .<span class=\"s-dotAccess\">continuous</span>\n    )\n    .<span class=\"s-call\">fill</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n)</code></pre><p class=\"info\">The above will give us the same result as when we were assigning the <code>.continuous</code> corner curve to our UIKit button’s <code>CALayer</code>.</p><p>Unfortunately, SwiftUI doesn’t include any built-in way to only round specific corners, but we could always accomplish that by either implementing a custom <code>Shape</code>, or a <code>UIView</code> that uses the <code>maskedCorners</code> Core Animation API that we took a look at earlier. We could then use either of those implementations as our view’s <code>background</code> (if going the UIKit route, we’d have to wrap that view using <a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\"><code>UIViewRepresentable</code></a> first), just like how we used a <code>RoundedRectangle</code> above.</p><h2>Conclusion</h2><p>I hope that this short article has given you a few ideas on how to render different kinds of rounded corners when using either UIKit or SwiftUI. If you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "How to round the corners of a UIKit or SwiftUI view in various ways.",
      "date_published": "2021-01-21T15:25:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/accessing-a-swift-property-wrappers-enclosing-instance",
      "url": "https://www.swiftbysundell.com/articles/accessing-a-swift-property-wrappers-enclosing-instance",
      "title": "Accessing a Swift property wrapper’s enclosing instance",
      "content_html": "<p>Like its name implies, Swift’s <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">property wrappers feature</a> enables us to wrap a given property value within a custom type, which in turn lets us apply transforms and run other kinds of logic whenever that value is modified.</p><p>By default, a property wrapper is completely disconnected from the enclosing types in which it’s being used, which can prove to be quite limiting in certain situations. For example, we can’t perform method calls or otherwise interact with a wrapper’s enclosing instance, since the standard API doesn’t provide us with such a reference.</p><p>However, it turns out that there is an alternative, somewhat hidden API that actually does give us access to each enclosing instance, which can enable us to adopt some really interesting patterns. Let’s take a look!</p><p class=\"info\">⚠️ Although all of the language features that are covered in this article are official parts of Swift, we’re going to make use of an API that has an underscore prefix, which should always be done with caution, since such APIs are bound to change at any point.</p><h2>Getting started</h2><p>By default, a Swift property wrapper is implemented by annotating a given type (usually a struct) with the <code>@propertyWrapper</code> attribute, and by then declaring a <code>wrappedValue</code> property within that type that’ll act as the underlying storage for the value that’s being wrapped. For example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> MyWrapper&lt;Value&gt; {\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">Value</span>\n}</code></pre><p>However, if we take a look at the <a href=\"https://github.com/apple/swift-evolution/blob/master/proposals/0258-property-wrappers.md#referencing-the-enclosing-self-in-a-wrapper-type\">Swift Evolution proposal</a> for the property wrappers feature, we can see that it also mentions a second, alternative way of handling a wrapper’s value — through a <a href=\"https://www.swiftbysundell.com/articles/the-power-of-subscripts-in-swift/#static-subscripts\">static subscript</a> that looks like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> EnclosingTypeReferencingWrapper&lt;Value&gt; {\n    <span class=\"s-keyword\">static subscript</span>&lt;T&gt;(\n        _enclosingInstance instance: <span class=\"s-type\">T</span>,\n        wrapped wrappedKeyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Value</span>&gt;,\n        storage storageKeyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Self</span>&gt;\n    ) -&gt; <span class=\"s-type\">Value</span> {\n        ...\n    }\n    \n    ...\n}</code></pre><p>Apart from the current enclosing instance, the above API lets us use Swift’s <a href=\"https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift\">key paths feature</a> to access both our wrapper itself, and the underlying value that’s being wrapped. The only requirement is that the enclosing type needs to be a class, since the above subscript uses <code>ReferenceWritableKeyPath</code>, which relies on <a href=\"https://www.swiftbysundell.com/basics/value-and-reference-types\">reference semantics</a>.</p><p>When implementing the above API, we likely also want to prevent our property from being mutated using value semantics (since we want all mutations to go through our subscript), which can be done by marking the standard <code>wrappedValue</code> property as unavailable — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> EnclosingTypeReferencingWrapper&lt;Value&gt; {\n    <span class=\"s-keyword\">static subscript</span>&lt;T&gt;(\n        _enclosingInstance instance: <span class=\"s-type\">T</span>,\n        wrapped wrappedKeyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Value</span>&gt;,\n        storage storageKeyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Self</span>&gt;\n    ) -&gt; <span class=\"s-type\">Value</span> {\n        ...\n    }\n    \n    <span class=\"s-keyword\">@available</span>(*, unavailable,\n        message: <span class=\"s-string\">\"This property wrapper can only be applied to classes\"</span>\n    )\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">get</span> { <span class=\"s-call\">fatalError</span>() }\n        <span class=\"s-keyword\">set</span> { <span class=\"s-call\">fatalError</span>() }\n    }\n}</code></pre><p class=\"info\">Note how we have to give <code>wrappedValue</code> both a getter and a setter, since otherwise the compiler will treat our property wrapper as immutable.</p><p>With the above setup in place, it’s now impossible to use our new property wrapper within a struct, and the compiler will automatically display the error message we defined using the <code>@available</code> attribute if we ever try to do so.</p><h2>Reimplementing the Published property wrapper</h2><p>To take a look at one type of situation in which the above pattern could be incredibly useful, let’s see if we can actually reimplement Combine’s <code>Published</code> property wrapper, which is often used in combination with the <code>ObservableObject</code> protocol to <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-objects\">connect a class to a SwiftUI view</a>.</p><p>While Combine is a closed-sourced framework that’s developed internally at Apple (so I haven’t actually seen its source code), we can make a few informed guesses as to how its <code>Published</code> wrapper is implemented based on the above subscript. Since each <code>ObservableObject</code> is required to have an <code>objectWillChange</code> publisher (which is automatically synthesized), the <code>Published</code> type likely calls that publisher in order to notify each observer of any changes — which might look something like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> Published&lt;Value&gt; {\n    <span class=\"s-keyword\">static subscript</span>&lt;T: <span class=\"s-type\">ObservableObject</span>&gt;(\n        _enclosingInstance instance: <span class=\"s-type\">T</span>,\n        wrapped wrappedKeyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Value</span>&gt;,\n        storage storageKeyPath: <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Self</span>&gt;\n    ) -&gt; <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">get</span> {\n            instance[keyPath: storageKeyPath].storage\n        }\n        <span class=\"s-keyword\">set</span> {\n            <span class=\"s-keyword\">let</span> publisher = instance.<span class=\"s-property\">objectWillChange</span>\n            <span class=\"s-comment\">// This assumption is definitely not safe to make in\n            // production code, but it's fine for this demo purpose:</span>\n            (publisher <span class=\"s-keyword\">as</span>! <span class=\"s-type\">ObservableObjectPublisher</span>).<span class=\"s-call\">send</span>()\n            \n            instance[keyPath: storageKeyPath].storage = newValue\n        }\n    }\n\n    <span class=\"s-keyword\">@available</span>(*, unavailable,\n        message: <span class=\"s-string\">\"@Published can only be applied to classes\"</span>\n    )\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">get</span> { <span class=\"s-call\">fatalError</span>() }\n        <span class=\"s-keyword\">set</span> { <span class=\"s-call\">fatalError</span>() }\n    }\n\n    <span class=\"s-keyword\">private var</span> storage: <span class=\"s-type\">Value</span>\n\n    <span class=\"s-keyword\">init</span>(wrappedValue: <span class=\"s-type\">Value</span>) {\n        storage = wrappedValue\n    }\n}</code></pre><p class=\"info\">Note how we’re using a separate <code>storage</code> property to store our <code>Published</code> type’s underlying value, rather than using <code>wrappedValue</code>, since we’d like that default property to remain unavailable.</p><p>What’s <em>really</em> interesting is that if we drop the above code into a SwiftUI project, everything is actually highly likely to just keep working, unless we’re doing things like converting <code>Published</code> instances into publishers using their <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift/#projected-values\">projected values</a> (which we haven’t yet added support for), and as long as all of our <code>@Published</code> properties are defined within <code>ObservableObject</code>-conforming types.</p><p>So although the above is hardly a completely accurate 1:1 reimplementation of its built-in counterpart, it definitely demonstrates just how powerful this type of functionality can be. But now, let’s actually use that functionality to build something useful.</p><h2>Proxy properties</h2><p>When using frameworks like UIKit and AppKit, it’s very common to want to hide certain subviews within their enclosing parent view, and to only enable those views to be mutated through specific APIs. For example, the following <code>HeaderView</code> has a <code>title</code> and an <code>image</code> property, but keeps the underlying views used to render those properties private, and then manually connects those pieces together:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> HeaderView: <span class=\"s-type\">UIView</span> {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>? {\n        <span class=\"s-keyword\">get</span> { titleLabel.<span class=\"s-property\">text</span> }\n        <span class=\"s-keyword\">set</span> { titleLabel.<span class=\"s-property\">text</span> = newValue }\n    }\n\n    <span class=\"s-keyword\">var</span> image: <span class=\"s-type\">UIImage</span>? {\n        <span class=\"s-keyword\">get</span> { imageView.<span class=\"s-property\">image</span> }\n        <span class=\"s-keyword\">set</span> { imageView.<span class=\"s-property\">image</span> = newValue }\n    }\n\n    <span class=\"s-keyword\">private let</span> titleLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private let</span> imageView = <span class=\"s-type\">UIImageView</span>()\n    \n    ...\n}</code></pre><p>The benefit of the above pattern is that it gives each view a much smaller API surface, which in turn makes it less likely that our views will be misused somehow (for example by configuring a subview in a way that the parent view wasn’t designed to handle). However, it also requires a fair amount of boilerplate, as we currently have to manually forward each property’s getter and setter to the underlying view that’s used for rendering.</p><p>This is another type of situation in which an <em>enclosing type referencing</em> property wrapper could be incredibly useful. Since the language mechanism used to access a wrapper’s enclosing instance is key path-based, we could build a <code>Proxy</code> wrapper that automatically syncs its wrapped value with one of its enclosing type’s key paths — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> Proxy&lt;EnclosingType, Value&gt; {\n    <span class=\"s-keyword\">typealias</span> ValueKeyPath = <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">EnclosingType</span>, <span class=\"s-type\">Value</span>&gt;\n    <span class=\"s-keyword\">typealias</span> SelfKeyPath = <span class=\"s-type\">ReferenceWritableKeyPath</span>&lt;<span class=\"s-type\">EnclosingType</span>, <span class=\"s-type\">Self</span>&gt;\n\n    <span class=\"s-keyword\">static subscript</span>(\n        _enclosingInstance instance: <span class=\"s-type\">EnclosingType</span>,\n        wrapped wrappedKeyPath: <span class=\"s-type\">ValueKeyPath</span>,\n        storage storageKeyPath: <span class=\"s-type\">SelfKeyPath</span>\n    ) -&gt; <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">get</span> {\n            <span class=\"s-keyword\">let</span> keyPath = instance[keyPath: storageKeyPath].keyPath\n            <span class=\"s-keyword\">return</span> instance[keyPath: keyPath]\n        }\n        <span class=\"s-keyword\">set</span> {\n            <span class=\"s-keyword\">let</span> keyPath = instance[keyPath: storageKeyPath].keyPath\n            instance[keyPath: keyPath] = newValue\n        }\n    }\n\n    <span class=\"s-keyword\">@available</span>(*, unavailable,\n        message: <span class=\"s-string\">\"@Proxy can only be applied to classes\"</span>\n    )\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">get</span> { <span class=\"s-call\">fatalError</span>() }\n        <span class=\"s-keyword\">set</span> { <span class=\"s-call\">fatalError</span>() }\n    }\n\n    <span class=\"s-keyword\">private let</span> keyPath: <span class=\"s-type\">ValueKeyPath</span>\n\n    <span class=\"s-keyword\">init</span>(<span class=\"s-keyword\">_</span> keyPath: <span class=\"s-type\">ValueKeyPath</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">keyPath</span> = keyPath\n    }\n}</code></pre><p>With that new property wrapper in place, we could now remove the manually implemented getters and setters from our <code>HeaderView</code>, and simply annotate the properties that we’re looking to sync to our underlying views with <code>@Proxy</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> HeaderView: <span class=\"s-type\">UIView</span> {\n    <span class=\"s-keyword\">@Proxy</span>(\\<span class=\"s-type\">HeaderView</span>.<span class=\"s-property\">titleLabel</span>.<span class=\"s-property\">text</span>) <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>?\n    <span class=\"s-keyword\">@Proxy</span>(\\<span class=\"s-type\">HeaderView</span>.<span class=\"s-property\">imageView</span>.<span class=\"s-property\">image</span>) <span class=\"s-keyword\">var</span> image: <span class=\"s-type\">UIImage</span>?\n\n    <span class=\"s-keyword\">private let</span> titleLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private let</span> imageView = <span class=\"s-type\">UIImageView</span>()\n    \n    ...\n}</code></pre><p>That’s already quite nice, but it is a bit of a shame that we have to repeatedly reference the <code>HeaderView</code> type when constructing our key paths. It would be so much nicer if we could make the compiler infer that type based on which enclosing type that our properties are being defined in.</p><p>To make that happen, we’re going to have to use a little bit of <em>“type system hacking”</em>. First, let’s rename our <code>Proxy</code> property wrapper to <code>AnyProxy</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> AnyProxy&lt;EnclosingType, Value&gt; {\n    ...\n}</code></pre><p>Then, let’s define a protocol that’ll use a type alias to specialize <code>AnyProxy</code> using <code>Self</code>. We’ll then apply that protocol to all <code>NSObject</code> types (which includes all UIKit and AppKit views) using an extension:</p><pre class=\"splash\"><code><span class=\"s-keyword\">protocol</span> ProxyContainer {\n    <span class=\"s-keyword\">typealias</span> Proxy&lt;T&gt; = <span class=\"s-type\">AnyProxy</span>&lt;<span class=\"s-type\">Self</span>, <span class=\"s-type\">T</span>&gt;\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">NSObject</span>: <span class=\"s-type\">ProxyContainer</span> {}</code></pre><p>With the above set of changes in place, we’ll now be able to omit the enclosing type when referencing our proxied key paths, since <code>Proxy</code> now refers to our new specialized version of the <code>AnyProxy</code> property wrapper:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> HeaderView: <span class=\"s-type\">UIView</span> {\n    <span class=\"s-keyword\">@Proxy</span>(\\.<span class=\"s-property\">titleLabel</span>.<span class=\"s-property\">text</span>) <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>?\n    <span class=\"s-keyword\">@Proxy</span>(\\.<span class=\"s-property\">imageView</span>.<span class=\"s-property\">image</span>) <span class=\"s-keyword\">var</span> image: <span class=\"s-type\">UIImage</span>?\n\n    <span class=\"s-keyword\">private let</span> titleLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private let</span> imageView = <span class=\"s-type\">UIImageView</span>()\n    \n    ...\n}</code></pre><p>We now have a very concise, elegant way of defining proxied properties in a way that doesn’t require any manual syncing, which isn’t only neat from a syntax perspective, but also removes the risk of us making a mistake when writing those manual getters and setters. Really nice!</p><p>Of course, one tradeoff with our final solution is that whenever we wish to refer to <code>Proxy</code>, we now have to make the enclosing type conform to our <code>ProxyContainer</code> protocol. However, since that protocol doesn’t actually have any requirements, and since we could always fall back to using <code>AnyProxy</code> directly, that’s not a big issue.</p><h2>Conclusion</h2><p>Although it might not yet be a fully baked language feature that we can rely on within production code (unless we’re willing to take the risk involved in using underscore-prefixed language features), the fact that Swift’s property wrappers do in fact support referencing their enclosing instance is incredibly powerful.</p><p>Hopefully this feature will eventually be promoted to a first-class capability that we can all use with confidence, just like how the <code>@_functionBuilder</code> attribute (used to define function/result builders) is about to evolve into the <code>@resultBuilder</code> attribute in Swift 5.4.</p><p>What do you think? What sort of property wrappers could the above set of patterns enable you to write? Let me know, along with your questions, comments or feedback, either via <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "How a Swift property wrapper can refer to its enclosing type, and examples of how that capability could be used.",
      "date_published": "2021-01-19T14:55:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/89",
      "url": "https://www.swiftbysundell.com/podcast/89",
      "title": "Podcast: “Framework and SDK development”, with special guest Ellen Shapiro",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell89.mp3\" type=\"audio/mpeg\"/></audio><p>Ellen Shapiro returns to the show to discuss framework and SDK development, and how that often requires a somewhat different process from app development. Also, API design, GraphQL, using the standard library’s protocol-oriented design, and more.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://clubhouse.io/sundell\">Clubhouse</a>:</strong> A lightweight, yet powerful project management tool that’s built specifically for software teams. Try it for free for two months at <a href=\"https://clubhouse.io/sundell\">clubhouse.io/sundell</a>.</li><li><strong><a href=\"https://geniusscansdk.com\">Genius Scan</a>:</strong> Add advanced document scanning features to your app using Genius Scan’s powerful SDK. Learn more at <a href=\"https://geniusscansdk.com\">geniusscansdk.com</a>, and mention Swift by Sundell when requesting a demo or quote for a 20% discount for a whole year.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/designatednerd\">Ellen on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://www.apollographql.com\">Apollo</a></li><li><a href=\"https://graphql.org\">GraphQL</a></li><li><a href=\"https://www.apollographql.com/docs/ios\">The documentation for Apollo’s iOS SDK</a></li><li><a href=\"https://github.com/apollographql/apollo-ios/blob/main/ROADMAP.md\">The roadmap for Apollo’s iOS SDK</a></li><li><a href=\"https://developers.cloudflare.com/analytics/graphql-api\">Cloudflare’s GraphQL analytics API</a></li><li><a href=\"https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/PublishingStep.swift\">Publish’s PublishingStep API</a></li><li><a href=\"https://www.apollographql.com/docs/ios/tutorial/tutorial-mutations\">Using Apollo’s interceptor API</a></li><li><a href=\"https://square.github.io/okhttp\">OkHttp</a></li><li><a href=\"https://www.swiftbysundell.com/basics/codable\">Codable</a></li><li><a href=\"https://developer.apple.com/documentation/swift/identifiable\">Identifiable</a></li><li><a href=\"https://developer.apple.com/documentation/swift/collection\">Swift’s Collection protocol</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Ellen Shapiro returns to the show to discuss framework and SDK development, and how that often requires a somewhat different process from app development. Also, API design, GraphQL, using the standard library’s protocol-oriented design, and more.",
      "date_published": "2021-01-18T19:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/avoiding-anyview-in-swiftui",
      "url": "https://www.swiftbysundell.com/articles/avoiding-anyview-in-swiftui",
      "title": "Avoiding SwiftUI’s AnyView",
      "content_html": "<p>SwiftUI ships with a special view called <code>AnyView</code>, which can be used as a <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift\">type erased</a> wrapper to enable multiple view types to be returned from a single function or computed property, or to let us reference a view without having to know its underlying type.</p><p>However, while there are cases in which we might need to use <code>AnyView</code>, it’s often best to avoid it as much as possible. That’s because SwiftUI uses a type-based algorithm to determine when a given view should be redrawn on screen, and since two <code>AnyView</code>-wrapped views will always look completely identical from the type system’s perspective (even if their underlying, wrapped types are different), performing this kind of type erasure significantly reduces SwiftUI’s ability to efficiently update our views.</p><p>So, in this article, let’s take a look at two core techniques that can help us avoid <code>AnyView</code> while still enabling us to work with multiple view types in very dynamic ways.</p><h2>Handling multiple return types</h2><p>When using SwiftUI to build views, we very often use the <code>some View</code> <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/#opaque-return-types\">opaque return type</a> to avoid having to explicitly define what exact type that we’re actually returning. That’s especially useful since (almost) every time that we apply a modifier to a given view, or change the contents of a container, we’re actually changing the type of view that we’ll return.</p><p>However, the compiler is only able to infer the underlying return type when all of the code branches within a given function or computed property return the exact same type. So something like the following won’t compile, since the <code>if</code> and <code>else</code> branches within our <code>textView</code> property return different types of views:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> FolderInfoView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> folder: <span class=\"s-type\">Folder</span>\n    <span class=\"s-keyword\">var</span> isEditable: <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"folder\"</span>)\n            textView\n        }\n    }\n\n    <span class=\"s-keyword\">private var</span> textView: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-comment\">// Error: Function declares an opaque return type, but\n        // the return statements in its body do not have matching\n        // underlying types.</span>\n        <span class=\"s-keyword\">if</span> isEditable {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Name\"</span>, text: <span class=\"s-property\">$folder</span>.<span class=\"s-property\">name</span>)\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Text</span>(folder.<span class=\"s-property\">name</span>)\n        }\n    }\n}</code></pre><p>Initially, it might seem like the above is one of those situations in which <code>AnyView</code> <em>must be used</em> in order to give all of our code branches the same return type. What’s very interesting, though, is that if we instead place the above conditional expression inline within our <code>body</code> property, the compiler error goes away:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> FolderInfoView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> folder: <span class=\"s-type\">Folder</span>\n    <span class=\"s-keyword\">var</span> isEditable: <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"folder\"</span>)\n\n            <span class=\"s-keyword\">if</span> isEditable {\n                <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Name\"</span>, text: <span class=\"s-property\">$folder</span>.<span class=\"s-property\">name</span>)\n            } <span class=\"s-keyword\">else</span> {\n                <span class=\"s-type\">Text</span>(folder.<span class=\"s-property\">name</span>)\n            }\n        }\n    }\n}</code></pre><p>That’s because SwiftUI uses a <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/#function-builders\">function/result builder</a> to combine all of the views that are defined within a given scope (such as the above <code>HStack</code>) into a single return type, and the good news is that we can use that same builder type within our own properties and functions as well.</p><p>Like we took a look at in <em><a href=\"https://www.swiftbysundell.com/tips/adding-swiftui-viewbuilder-to-functions\">“Adding SwiftUI’s ViewBuilder attribute to functions”</a></em>, all that we have to do to utilize that same powerful view building functionality is to use the <code>@ViewBuilder</code> attribute — which in turn lets us express multiple types of views within the same scope, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> FolderInfoView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> folder: <span class=\"s-type\">Folder</span>\n    <span class=\"s-keyword\">var</span> isEditable: <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"folder\"</span>)\n            textView\n        }\n    }\n\n    <span class=\"s-keyword\">@ViewBuilder\n    private var</span> textView: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">if</span> isEditable {\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Name\"</span>, text: <span class=\"s-property\">$folder</span>.<span class=\"s-property\">name</span>)\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-type\">Text</span>(folder.<span class=\"s-property\">name</span>)\n        }\n    }\n}</code></pre><p class=\"info\">Note how we’re no longer using any <code>return</code> statements within our new <code>textView</code> property implementation, since each expression will now be parsed by SwiftUI’s <code>ViewBuilder</code>, rather than being returned separately.</p><p>So the first way that <code>AnyView</code> can often be avoided is by using the <code>ViewBuilder</code> attribute whenever we want a given property or function to be able to return multiple view types.</p><h2>Generic view properties</h2><p>Another really common type of situation in which <code>AnyView</code> is often used is when we want to store a given view in a property without having to know its exact type. For example, let’s say that we’re working on the following <code>ItemRow</code>, which currently uses <code>AnyView</code> to enable us to inject any <code>accessoryView</code> that we want to display at the trailing edge:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ItemRow: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> accessoryView: <span class=\"s-type\">AnyView</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>) {\n                <span class=\"s-type\">Text</span>(title).<span class=\"s-call\">bold</span>()\n                <span class=\"s-type\">Text</span>(description)\n            }\n            <span class=\"s-type\">Spacer</span>()\n            accessoryView\n        }\n    }\n}</code></pre><p>Since we can’t use the <code>some View</code> opaque return type for stored properties (they’re not <em>returning anything</em>, after all), and since we’re no longer dealing with a predefined number of views that can be combined using <code>ViewBuilder</code>, we’ll have to explore another strategy if we’d like to remove our usage of <code>AnyView</code> in this case.</p><p>Just like how we previously took inspiration from SwiftUI itself when using <code>ViewBuilder</code>, let’s do the same thing here. The way that SwiftUI solves the problem of enabling any view to be injected is by making the host view generic over the type of view that it’ll contain. For example, the built-in <code>HStack</code> container is defined as a generic that has a <code>Content</code> type, which in turn is required to conform to the <code>View</code> protocol:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> HStack&lt;Content&gt;: <span class=\"s-type\">View</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Content</span>: <span class=\"s-type\">View</span> {\n    ...\n}</code></pre><p>Using the same kind of <a href=\"https://www.swiftbysundell.com/articles/using-generic-type-constraints-in-swift-4\">generic type constraint</a>, we can make our <code>ItemRow</code> adopt the exact same pattern — which will let us directly inject any <code>View</code>-conforming type as our <code>accessoryView</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ItemRow&lt;Accessory: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> accessoryView: <span class=\"s-type\">Accessory</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">HStack</span> {\n            <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>) {\n                <span class=\"s-type\">Text</span>(title).<span class=\"s-call\">bold</span>()\n                <span class=\"s-type\">Text</span>(description)\n            }\n            <span class=\"s-type\">Spacer</span>()\n            accessoryView\n        }\n    }\n}</code></pre><p>Not only does the above give us better performance during view updates (since all of the types involved are now well-defined and transparent to the type system), it also makes our call sites simpler as well, since each <code>accessoryView</code> no longer has to be manually wrapped within an <code>AnyView</code>:</p><pre class=\"splash\"><code><span class=\"s-comment\">// Before:</span>\n<span class=\"s-type\">ItemRow</span>(\n    title: title,\n    description: description,\n    accessoryView: <span class=\"s-type\">AnyView</span>(<span class=\"s-type\">Image</span>(\n        systemName: <span class=\"s-string\">\"checkmark.circle\"</span>\n    ))\n)\n\n<span class=\"s-comment\">// After:</span>\n<span class=\"s-type\">ItemRow</span>(\n    title: title,\n    description: description,\n    accessoryView: <span class=\"s-type\">Image</span>(\n        systemName: <span class=\"s-string\">\"checkmark.circle\"</span>\n    )\n)</code></pre><h2>Conclusion</h2><p>While SwiftUI makes many aspects of UI development simpler, there’s no denying that it’s an incredibly complicated framework that makes heavy use of some of Swift’s most powerful features. So while it might be easy to get started building views using it, we often have to use quite advanced techniques (like generic programming) in order to make the best use of what SwiftUI has to offer.</p><p>Of course, just because it might be a good idea to avoid <code>AnyView</code> as much as possible doesn’t mean that it should <em>never</em> be used. It’s a part of SwiftUI’s public API for a reason, and the above two techniques won’t work in every single situation — but when they do, they’ll often result in much more elegant and efficient code.</p><p>What do you think? Will the above techniques help you remove any usages of <code>AnyView</code>? Let me know, along with your questions or comments, either via <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading!</p>",
      "summary": "How SwiftUI’s AnyView type can often be avoided, and why it might be a good idea to do so.",
      "date_published": "2021-01-12T15:50:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/detailsPro-jan-2021",
      "url": "https://www.swiftbysundell.com/sponsor/detailsPro-jan-2021",
      "title": "Sponsored: Quickly build SwiftUI prototypes with DetailsPro",
      "content_html": "<p>My thanks to the team behind <a href=\"https://apps.apple.com/app/apple-store/id1524366536?pt=121633377&ct=sbs&mt=8\">DetailsPro</a> — a fantastic SwiftUI view editor for Mac and iOS — for sponsoring Swift by Sundell last week. DetailsPro lets both developers and designers quickly build prototypes completely visually, using real SwiftUI components, which also makes it an excellent way to familiarize yourself with SwiftUI’s overall APIs and features.</p><p><strong>→ <a href=\"https://apps.apple.com/app/apple-store/id1524366536?pt=121633377&ct=sbs&mt=8\">Get DetailsPro for free from the App Store</a></strong></p><p>Not only does DetailsPro run real SwiftUI code under the hood, which ensures that the design of your views will perfectly match how they’ll eventually get rendered within an app, it also lets you easily export that code as high-quality Swift snippets.</p><img src=\"https://www.swiftbysundell.com/images/sponsored-posts/detailsPro.png\" alt=\"DetailsPro screenshot\"/><p>That means that you can start designing a new app, widget, or feature in DetailsPro, and then move it over to Xcode whenever you’d like. Plus, DetailsPro also seamlessly syncs your projects across your devices, so that you can start working on your iPad, and then easily pick that same project up on the Mac, or even on your iPhone!</p><p>Even though this is a super powerful, pro-caliber tool, it’s completely free for up to five designs — so simply <a href=\"https://apps.apple.com/app/apple-store/id1524366536?pt=121633377&ct=sbs&mt=8\">download it from the App Store</a> and give it a try, and by doing so you’ll also directly support Swift by Sundell as well.</p>",
      "summary": "Thanks to DetailsPro for sponsoring Swift by Sundell.",
      "date_published": "2021-01-11T13:50:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/validating-email-addresses",
      "url": "https://www.swiftbysundell.com/articles/validating-email-addresses",
      "title": "Validating email addresses using RawRepresentable and NSDataDetector",
      "content_html": "<p>These days, it’s incredibly common for apps to have to work with email addresses one way or another, and when doing so, we typically want to perform some kind of client-side validation on any addresses that were entered by the user.</p><p>Conceptually, performing that kind of validation <em>should</em> be quite simple, given that email addresses need to conform to a certain format in order to be valid, but in practice, it can be quite difficult to figure out exactly how to implement that kind of logic in Swift.</p><p>One very common way to do so is to use a regular expression, which when combined with <code>NSPredicate</code> lets us validate a given email address <code>String</code> like this (the actual regular expression has been omitted for brevity):</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> SignUpViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private lazy var</span> emailAddressField = <span class=\"s-type\">UITextField</span>()\n\n    <span class=\"s-keyword\">@objc private func</span> handleSignUpButtonPress() {\n        <span class=\"s-keyword\">let</span> emailPredicate = <span class=\"s-type\">NSPredicate</span>( \n            format: <span class=\"s-string\">\"SELF MATCHES %@\"</span>, <span class=\"s-string\">\"&lt;regular expression&gt;\"</span>\n        )\n\n        <span class=\"s-keyword\">guard let</span> email = emailAddressField.<span class=\"s-property\">text</span>,\n              emailPredicate.<span class=\"s-call\">evaluate</span>(with: email) <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-call\">showErrorView</span>(for: .<span class=\"s-dotAccess\">invalidEmailAddress</span>)\n        }\n        \n        ...\n    }\n}</code></pre><p>However, while the above technique certainly works, it does have a few downsides. First of all, we have to either carefully craft the regular expression that we wish to use ourselves, or figure out which of the many variants that can be found online that’s actually the right one to use. But perhaps more importantly is that when storing and passing email addresses as raw <code>String</code> values, there’s no way of establishing a guarantee that a given value has actually been validated.</p><p>For example, by just looking at the following <code>User</code> type, we can’t tell whether the <code>emailAddress</code> that is being stored within it has actually been passed through any kind of validation, since that logic is currently completely detached from that value:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> User: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> emailAddress: <span class=\"s-type\">String</span>\n    ...\n}</code></pre><p>However, it turns out that Swift actually has a built-in pattern that could let us solve the above set of problems quite elegantly.</p><p>If we think about it, we very often deal with other kinds of validated raw values in the shape of <em>enums</em>. For example, the following <code>UserGroup</code> enum can be initialized with a raw <code>String</code> value, but will only actually return an instance if that raw value matched one of our enum’s cases:</p><pre class=\"splash\"><code><span class=\"s-keyword\">enum</span> UserGroup: <span class=\"s-type\">String</span> {\n    <span class=\"s-keyword\">case</span> admins\n    <span class=\"s-keyword\">case</span> moderators\n    <span class=\"s-keyword\">case</span> regular\n}</code></pre><p>At first, it might seem like the <code>init(rawValue:)</code> initializer that raw value-backed enums get is the result of some kind of hard-coded compiler logic that’s specific for enums. While that’s <em>partially true</em>, that initializer is actually part of a general-purpose protocol called <code>RawRepresentable</code>, which enums that have raw values automatically conform to.</p><p>That means that we can also define our own <code>RawRepresentable</code> types as well, which lets us encapsulate our email validation logic in a very neat way — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EmailAddress: <span class=\"s-type\">RawRepresentable</span>, <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">let</span> rawValue: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">init</span>?(rawValue: <span class=\"s-type\">String</span>) {\n        <span class=\"s-comment\">// Validate the passed value and either assign it to our\n        // rawValue property, or return nil.</span>\n        ...\n    }\n}</code></pre><p class=\"info\">Note that our new <code>EmailAddress</code> type also conforms to <code>Codable</code>, which we get support for without having to write any additional code. Values will be automatically encoded and decoded to and from our underlying <code>rawValue</code> property, just like how enums work in that context.</p><p>Now, while we <em>could</em> simply copy/paste our regular expression-based validation logic from before into our new <code>EmailAddress</code> type, let’s also use this opportunity to explore a different (and, if you ask me, better) way of performing our validation — by using Foundation’s <code>NSDataDetector</code> API.</p><p>Under the hood, <code>NSDataDetector</code> actually uses regular expressions as well, but hides those details behind a series of dedicated APIs that let us identify tokens like links, phone numbers, and email addresses. Here’s how we could use the <code>link</code> checking type to extract a <code>mailto</code> link for the email address that we’re validating, which we could then perform a few extra checks on like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EmailAddress: <span class=\"s-type\">RawRepresentable</span>, <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">let</span> rawValue: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">init</span>?(rawValue: <span class=\"s-type\">String</span>) {\n        <span class=\"s-keyword\">let</span> detector = <span class=\"s-keyword\">try</span>? <span class=\"s-type\">NSDataDetector</span>(\n            types: <span class=\"s-type\">NSTextCheckingResult</span>.<span class=\"s-type\">CheckingType</span>.<span class=\"s-property\">link</span>.<span class=\"s-property\">rawValue</span>\n        )\n\n        <span class=\"s-keyword\">let</span> range = <span class=\"s-type\">NSRange</span>(\n            rawValue.<span class=\"s-property\">startIndex</span>..&lt;rawValue.<span class=\"s-property\">endIndex</span>,\n            in: rawValue\n        )\n\n        <span class=\"s-keyword\">let</span> matches = detector?.<span class=\"s-call\">matches</span>(\n            in: rawValue,\n            options: [],\n            range: range\n        )\n    \n        <span class=\"s-comment\">// We only want our string to contain a single email\n        // address, so if multiple matches were found, then\n        // we fail our validation process and return nil:</span>\n        <span class=\"s-keyword\">guard let</span> match = matches?.<span class=\"s-property\">first</span>, matches?.<span class=\"s-property\">count</span> == <span class=\"s-number\">1</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return nil</span>\n        }\n\n        <span class=\"s-comment\">// Verify that the found link points to an email address,\n        // and that its range covers the whole input string:</span>\n        <span class=\"s-keyword\">guard</span> match.<span class=\"s-property\">url</span>?.<span class=\"s-property\">scheme</span> == <span class=\"s-string\">\"mailto\"</span>, match.<span class=\"s-property\">range</span> == range <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return nil</span>\n        }\n\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">rawValue</span> = rawValue\n    }\n}</code></pre><p>With the above in place, we can now simply use our new <code>EmailAddress</code> type wherever we’re storing an email address, and we’ll get a compile time guarantee that each of those addresses will always be validated when they’re converted from a raw <code>String</code> value:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> User: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> emailAddress: <span class=\"s-type\">EmailAddress</span>\n    ...\n}</code></pre><p>To then actually convert raw email address strings into instances of our new type, we can simply use the same <code>init(rawValue:)</code> initializer that’s used to convert raw values into enums, or in the case of our <code>SignUpViewController</code> from before, we could use <code>flatMap</code> on the optional <code>String</code> that <code>UITextField</code> gives us, and then pass our new type’s initializer as a <a href=\"https://www.swiftbysundell.com/clips/1\">first class function</a> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> SignUpViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private lazy var</span> emailAddressField = <span class=\"s-type\">UITextField</span>()\n\n    <span class=\"s-keyword\">@objc private func</span> handleSignUpButtonPress() {\n        <span class=\"s-comment\">// As an added bonus, we also trim all whitespaces from\n        // the string that the user entered before validating it:</span>\n        <span class=\"s-keyword\">let</span> rawEmail = emailAddressField.<span class=\"s-property\">text</span>?.<span class=\"s-call\">trimmingCharacters</span>(\n            in: .<span class=\"s-dotAccess\">whitespaces</span>\n        )\n\n        <span class=\"s-keyword\">guard let</span> email = rawEmail.<span class=\"s-call\">flatMap</span>(<span class=\"s-type\">EmailAddress</span>.<span class=\"s-keyword\">init</span>) <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-call\">showErrorView</span>(for: .<span class=\"s-dotAccess\">invalidEmailAddress</span>)\n        }\n        \n        ...\n    }\n}</code></pre><p>Of course, if we wanted to, we could’ve kept using the regular expression-based approach within our <code>EmailAddress</code> implementation as well, but I personally think that the combination of a dedicated <code>RawRepresentable</code> type and <code>NSDataDetector</code> results in a much simpler solution.</p><p>What do you think? Feel free to share this article if you enjoyed it, or contact me via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a> if you have any questions or comments. Thanks for reading!</p>",
      "summary": "How to validate email addresses in Swift using a dedicated RawRepresentable type and Foundation’s NSDataDetector API.",
      "date_published": "2021-01-08T15:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/http-post-and-file-upload-requests-using-urlsession",
      "url": "https://www.swiftbysundell.com/articles/http-post-and-file-upload-requests-using-urlsession",
      "title": "Performing POST and file upload requests using URLSession",
      "content_html": "<p>Over the years, Foundation’s built-in <code>URLSession</code> API has grown to become a versatile and very powerful networking tool, to the point where third party libraries are often no longer required to perform standard HTTP network calls in a simple and straightforward way.</p><p>While many of the convenience APIs that <code>URLSession</code> ships with are focused on <code>GET</code> requests used to fetch data, in this article, let’s take a look at how other HTTP methods can be used as well — specifically how different kinds of <code>POST</code> requests can be performed without any external dependencies.</p><h2>Data and upload tasks</h2><p>Perhaps the simplest way to use <code>URLSession</code> to perform a <code>POST</code> request is to use the <code>URLRequest</code>-based overloads of its various <code>dataTask</code> APIs (which support both delegate and closure-based callbacks, as well as <a href=\"https://www.swiftbysundell.com/tags/combine\">Combine</a>). Among many other things, <code>URLRequest</code> enables us to customize what <code>httpMethod</code> that a given network call should use, as well as other useful parameters, such as what <code>httpBody</code> data to send, and what <code>cachePolicy</code> to use. Here’s an example:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Networking {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n\n    <span class=\"s-keyword\">func</span> sendPostRequest(\n        to url: <span class=\"s-type\">URL</span>,\n        body: <span class=\"s-type\">Data</span>,\n        then handler: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Data</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n    ) {\n        <span class=\"s-comment\">// To ensure that our request is always sent, we tell\n        // the system to ignore all local cache data:</span>\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(\n            url: url,\n            cachePolicy: .<span class=\"s-dotAccess\">reloadIgnoringLocalCacheData</span>\n        )\n        \n        request.<span class=\"s-property\">httpMethod</span> = <span class=\"s-string\">\"POST\"</span>\n        request.<span class=\"s-property\">httpBody</span> = body\n\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(\n            with: request,\n            completionHandler: { data, response, error <span class=\"s-keyword\">in</span>\n                <span class=\"s-comment\">// Validate response and call handler</span>\n                ...\n            }\n        )\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p class=\"info\">Depending on the server that our <code>POST</code> request is being sent to, we might also want to configure our <code>URLRequest</code> instance further, for example by giving it a <code>Content-Type</code> header.</p><p>Alternatively, we could instead choose to use the <code>uploadTask</code> API to create our request task, which both lets us upload data while the app is in the background, and provides built-in support for attaching body data directly to the task itself:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Networking {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n\n    <span class=\"s-keyword\">func</span> sendPostRequest(\n        to url: <span class=\"s-type\">URL</span>,\n        body: <span class=\"s-type\">Data</span>,\n        then handler: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Data</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n    ) {\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(\n            url: url,\n            cachePolicy: .<span class=\"s-dotAccess\">reloadIgnoringLocalCacheData</span>\n        )\n        \n        request.<span class=\"s-property\">httpMethod</span> = <span class=\"s-string\">\"POST\"</span>\n\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">uploadTask</span>(\n            with: request,\n            from: body,\n            completionHandler: { data, response, error <span class=\"s-keyword\">in</span>\n                <span class=\"s-comment\">// Validate response and call handler</span>\n                ...\n            }\n        )\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><h2>Observing progress updates</h2><p>While either of the above two approaches will work perfectly fine when sending smaller amounts of data as part of a <code>POST</code> request, sometimes we might want to upload a file that could potentially be quite large (even something simple, like an image, could easily be several Megabytes in size). When doing that, we likely want to give the user some form of real-time progress updates, since otherwise our app’s UI might appear slow or even unresponsive.</p><p>Unfortunately, none of the closure-based or Combine-powered <code>URLSession</code> APIs offer direct support for observing a request’s ongoing progress, but thankfully, that’s something that we can implement quite easily using the good old fashioned <a href=\"https://www.swiftbysundell.com/articles/delegation-in-swift\">delegate pattern</a>.</p><p>To demonstrate, let’s create a <code>FileUploader</code> class (which needs to be a subclass of Objective-C’s <code>NSObject</code>). We’ll then use a <em>custom</em> <code>URLSession</code> instance, rather than the <code>shared</code> one, since that’ll let us become the delegate of that session. We’ll then define an API that’ll let us upload a file from a given local URL, and we’ll let the callers of that API pass in two closures — one for handling progress events, as well as a standard completion handler. Finally, we’ll store all progress event handlers in a dictionary based on each upload task’s ID, so that we’ll later be able to call those closures within our delegate protocol implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> FileUploader: <span class=\"s-type\">NSObject</span> {\n    <span class=\"s-comment\">// We'll define a few type aliases to make our code easier to read:</span>\n    <span class=\"s-keyword\">typealias</span> Percentage = <span class=\"s-type\">Double</span>\n    <span class=\"s-keyword\">typealias</span> ProgressHandler = (<span class=\"s-type\">Percentage</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">typealias</span> CompletionHandler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Void</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-comment\">// Creating our custom URLSession instance. We'll do it lazily\n    // to enable 'self' to be passed as the session's delegate:</span>\n    <span class=\"s-keyword\">private lazy var</span> urlSession = <span class=\"s-type\">URLSession</span>(\n        configuration: .<span class=\"s-dotAccess\">default</span>,\n        delegate: <span class=\"s-keyword\">self</span>,\n        delegateQueue: .<span class=\"s-dotAccess\">main</span>\n    )\n\n    <span class=\"s-keyword\">private var</span> progressHandlersByTaskID = [<span class=\"s-type\">Int</span> : <span class=\"s-type\">ProgressHandler</span>]()\n\n    <span class=\"s-keyword\">func</span> uploadFile(\n        at fileURL: <span class=\"s-type\">URL</span>,\n        to targetURL: <span class=\"s-type\">URL</span>,\n        progressHandler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">ProgressHandler</span>,\n        completionHandler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">CompletionHandler</span>\n    ) {\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(\n            url: targetURL,\n            cachePolicy: .<span class=\"s-dotAccess\">reloadIgnoringLocalCacheData</span>\n        )\n        \n        request.<span class=\"s-property\">httpMethod</span> = <span class=\"s-string\">\"POST\"</span>\n\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">uploadTask</span>(\n            with: request,\n            fromFile: fileURL,\n            completionHandler: { data, response, error <span class=\"s-keyword\">in</span>\n                <span class=\"s-comment\">// Validate response and call handler</span>\n                ...\n            }\n        )\n\n        progressHandlersByTaskID[task.<span class=\"s-property\">taskIdentifier</span>] = progressHandler\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>Next, let’s implement the <code>URLSessionTaskDelegate</code> protocol, which is a <a href=\"https://www.swiftbysundell.com/articles/specializing-protocols-in-swift\">specialized version</a> of the base <code>URLSessionDelegate</code> protocol that adds a few extra methods to enable us to observe task-specific events. In this case, we only want to be notified when the progress of a given <code>URLSessionTask</code> was updated, which can be done by implementing the following method:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">FileUploader</span>: <span class=\"s-type\">URLSessionTaskDelegate</span> {\n    <span class=\"s-keyword\">func</span> urlSession(\n        <span class=\"s-keyword\">_</span> session: <span class=\"s-type\">URLSession</span>,\n        task: <span class=\"s-type\">URLSessionTask</span>,\n        didSendBodyData bytesSent: <span class=\"s-type\">Int64</span>,\n        totalBytesSent: <span class=\"s-type\">Int64</span>,\n        totalBytesExpectedToSend: <span class=\"s-type\">Int64</span>\n    ) {\n        <span class=\"s-keyword\">let</span> progress = <span class=\"s-type\">Double</span>(totalBytesSent) / <span class=\"s-type\">Double</span>(totalBytesExpectedToSend)\n        <span class=\"s-keyword\">let</span> handler = progressHandlersByTaskID[task.<span class=\"s-property\">taskIdentifier</span>]\n        handler?(progress)\n    }\n}</code></pre><p>With the above in place, we’ll now be able use the percentage values passed into each <code>progressHandler</code> closure to drive any UI component that we want to use to visualize the progress of an upload — such as a <code>ProgressView</code>, <code>UIProgressView</code>, or <code>NSProgressIndicator</code>.</p><h2>A stream of progress over time</h2><p>Finally, let’s also take a look at how we could convert the above <code>FileUploader</code> to use Combine instead of multiple closures. After all, Combine’s <em>\"values over time”</em>-focused design is quite a perfect fit for modeling progress updates, since we want to send a number of percentage values over time, and to then end with a completion event, which is exactly what a Combine publisher does.</p><p>While we <em>could</em> choose to implement this functionality using a <a href=\"https://www.swiftbysundell.com/articles/building-custom-combine-publishers-in-swift\">custom publisher</a>, let’s use <code>CurrentValueSubject</code> in this case, which provides a built-in way to send values that then get cached and sent to every new subscriber. That way, we can associate each upload task with a given subject (just like how we previously stored each <code>progressHandler</code> closure) and then return that subject as a publisher using the <code>eraseToAnyPublisher</code> API — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> FileUploader: <span class=\"s-type\">NSObject</span> {\n    <span class=\"s-keyword\">typealias</span> Percentage = <span class=\"s-type\">Double</span>\n    <span class=\"s-keyword\">typealias</span> Publisher = <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Percentage</span>, <span class=\"s-type\">Error</span>&gt;\n    \n    <span class=\"s-keyword\">private typealias</span> Subject = <span class=\"s-type\">CurrentValueSubject</span>&lt;<span class=\"s-type\">Percentage</span>, <span class=\"s-type\">Error</span>&gt;\n\n    <span class=\"s-keyword\">private lazy var</span> urlSession = <span class=\"s-type\">URLSession</span>(\n        configuration: .<span class=\"s-dotAccess\">default</span>,\n        delegate: <span class=\"s-keyword\">self</span>,\n        delegateQueue: .<span class=\"s-dotAccess\">main</span>\n    )\n\n    <span class=\"s-keyword\">private var</span> subjectsByTaskID = [<span class=\"s-type\">Int</span> : <span class=\"s-type\">Subject</span>]()\n\n    <span class=\"s-keyword\">func</span> uploadFile(at fileURL: <span class=\"s-type\">URL</span>,\n                    to targetURL: <span class=\"s-type\">URL</span>) -&gt; <span class=\"s-type\">Publisher</span> {\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(\n            url: targetURL,\n            cachePolicy: .<span class=\"s-dotAccess\">reloadIgnoringLocalCacheData</span>\n        )\n        \n        request.<span class=\"s-property\">httpMethod</span> = <span class=\"s-string\">\"POST\"</span>\n\n        <span class=\"s-keyword\">let</span> subject = <span class=\"s-type\">Subject</span>(<span class=\"s-number\">0</span>)\n        <span class=\"s-keyword\">var</span> removeSubject: (() -&gt; <span class=\"s-type\">Void</span>)?\n\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">uploadTask</span>(\n            with: request,\n            fromFile: fileURL,\n            completionHandler: { data, response, error <span class=\"s-keyword\">in</span>\n                <span class=\"s-comment\">// Validate response and send completion</span>\n                ...\n                subject.<span class=\"s-call\">send</span>(completion: .<span class=\"s-dotAccess\">finished</span>)\n                removeSubject?()\n            }\n        )\n\n        subjectsByTaskID[task.<span class=\"s-property\">taskIdentifier</span>] = subject\n        removeSubject = { [<span class=\"s-keyword\">weak self</span>] <span class=\"s-keyword\">in\n            self</span>?.<span class=\"s-property\">subjectsByTaskID</span>.<span class=\"s-call\">removeValue</span>(forKey: task.<span class=\"s-property\">taskIdentifier</span>)\n        }\n        \n        task.<span class=\"s-call\">resume</span>()\n        \n        <span class=\"s-keyword\">return</span> subject.<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Now all that remains is to update our <code>URLSessionTaskDelegate</code> implementation to send each progress value to the subject associated with the task in question, rather than calling a closure:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">FileUploader</span>: <span class=\"s-type\">URLSessionTaskDelegate</span> {\n    <span class=\"s-keyword\">func</span> urlSession(\n        <span class=\"s-keyword\">_</span> session: <span class=\"s-type\">URLSession</span>,\n        task: <span class=\"s-type\">URLSessionTask</span>,\n        didSendBodyData bytesSent: <span class=\"s-type\">Int64</span>,\n        totalBytesSent: <span class=\"s-type\">Int64</span>,\n        totalBytesExpectedToSend: <span class=\"s-type\">Int64</span>\n    ) {\n        <span class=\"s-keyword\">let</span> progress = <span class=\"s-type\">Double</span>(totalBytesSent) / <span class=\"s-type\">Double</span>(totalBytesExpectedToSend)\n        <span class=\"s-keyword\">let</span> subject = subjectsByTaskID[task.<span class=\"s-property\">taskIdentifier</span>]\n        subject?.<span class=\"s-call\">send</span>(progress)\n    }\n}</code></pre><p>Just like that, we can now easily perform both simpler <code>POST</code> requests and file uploads, with progress events, using either Combine or a closure-based API. Really nice!</p><h2>Conclusion</h2><p>While the above series of implementations are not a complete networking library by any stretch of the imagination, they’ve hopefully demonstrated how the built-in functionality that <code>URLSession</code> provides is often all that we need to perform many different kinds of requests, including those that involve posting data or uploading files.</p><p>I hope that you found this article useful. If you have any questions or comments, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>, and don’t forget to check out this week’s sponsor if you’d like to support my work. Thanks for reading!</p>",
      "summary": "How URLSession can be used to perform POST requests and file uploads without any third party libraries.",
      "date_published": "2021-01-06T18:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/custom-query-functions-using-key-paths",
      "url": "https://www.swiftbysundell.com/articles/custom-query-functions-using-key-paths",
      "title": "Creating custom query functions using key paths",
      "content_html": "<p>Being a fairly strict, statically compiled language, it might not initially seem like Swift offers much in terms of syntax customization, but that’s actually quite far from the case. Through features like <a href=\"https://www.swiftbysundell.com/articles/custom-operators-in-swift\">custom and overloaded operators</a>, <a href=\"https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift\">key paths</a>, <a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">function/result builders</a>, and more, there are a lot of opportunities for us to tweak Swift’s syntax for particular use cases.</p><p>Of course, it could also definitely be argued that any kind of syntax customization should be approached with great caution, as non-standard syntax could also easily become a source of confusion if we’re not careful. But, in certain situations, that tradeoff might be worth it, and can sort of let us craft “<a href=\"https://www.swiftbysundell.com/articles/building-dsls-in-swift\">micro-DSLs</a>” that can actually help us make our code <em>more clear</em>, rather than the opposite.</p><h2>Negated boolean key paths</h2><p>To take a look at one such case, let’s say that we’re working on an app for managing, filtering and sorting articles, which features the following <code>Article</code> data model:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Article {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> category: <span class=\"s-type\">Category</span>\n    <span class=\"s-keyword\">var</span> isRead: <span class=\"s-type\">Bool</span>\n    ...\n}</code></pre><p>Now let’s say that a very common task within our code base is to filter various collections that each contain instances of the above model. One way to do that would be to use the fact that any Swift key path literal can be <a href=\"https://www.swiftbysundell.com/tips/passing-key-paths-as-functions\">automatically converted into a function</a>, which lets us use the following compact syntax when filtering on any boolean property, such as <code>isRead</code> in this case:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> articles: [<span class=\"s-type\">Article</span>] = ...\n<span class=\"s-keyword\">let</span> readArticles = articles.<span class=\"s-call\">filter</span>(\\.<span class=\"s-property\">isRead</span>)</code></pre><p>That’s really nice, however, the above syntax can only be used when we want to compare against <code>true</code> — meaning that if we wanted to create a similarly filtered array containing all <em>unread</em> articles, then we’d have to use a closure (or <a href=\"https://www.swiftbysundell.com/articles/first-class-functions-in-swift\">pass a function</a>) instead:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> unreadArticles = articles.<span class=\"s-call\">filter</span> { !$0.<span class=\"s-property\">isRead</span> }</code></pre><p>That’s certainly not a big problem, but if the above kind of operation is something that we’re performing in many different places across our code base, then we might start to ask ourselves: <em>“Wouldn’t it be great if we could also use that same nice key path syntax for negated booleans as well?”</em></p><p>This is where the concept of syntax customization comes in. By implementing the following <em>prefix function</em>, we can actually create a small little tweak that’ll let us use key paths regardless if we’re comparing against <code>true</code> or <code>false</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">prefix func</span> !&lt;<span class=\"s-type\">T</span>&gt;(keyPath: <span class=\"s-type\">KeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Bool</span>&gt;) -&gt; (<span class=\"s-type\">T</span>) -&gt; <span class=\"s-type\">Bool</span> {\n    <span class=\"s-keyword\">return</span> { !$0[keyPath: keyPath] }\n}</code></pre><p>The above is essentially an overload of the built-in <code>!</code> prefix operator, which makes it possible to apply that operator to any <code>Bool</code> key path in order to turn it into a function that negates (or <em>flips</em>) its value — which in turn now lets us compute our <code>unreadArticles</code> array like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> unreadArticles = articles.<span class=\"s-call\">filter</span>(!\\.<span class=\"s-property\">isRead</span>)</code></pre><p>That’s quite cool, and doesn’t really make our code confusing, given that we’re using the <code>!</code> operator in a way that’s consistent with how it’s used by default — to negate a boolean expression.</p><h2>Key path-based comparisons</h2><p>Now, to take things even further, let’s also make it possible to use key paths to form filter queries that compare a given property against any kind of <code>Equatable</code> value. That’ll become useful if we, for example, wanted to filter our <code>articles</code> array based on each article’s <code>category</code>. The type of that property, <code>Category</code>, is currently defined as an enum that looks like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Article</span> {\n    <span class=\"s-keyword\">enum</span> Category {\n        <span class=\"s-keyword\">case</span> fullLength\n        <span class=\"s-keyword\">case</span> quickReads\n        <span class=\"s-keyword\">case</span> basics\n        ...\n    }\n}</code></pre><p>Just like how we previously overloaded the <code>!</code> operator with a key path-specific variant, we can do the same thing with the <code>==</code> operator as well, and just like before, we’ll return a <code>Bool</code>-returning closure that can then be directly passed to APIs like <code>filter</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> ==&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">V</span>: <span class=\"s-type\">Equatable</span>&gt;(lhs: <span class=\"s-type\">KeyPath</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">V</span>&gt;, rhs: <span class=\"s-type\">V</span>) -&gt; (<span class=\"s-type\">T</span>) -&gt; <span class=\"s-type\">Bool</span> {\n    <span class=\"s-keyword\">return</span> { $0[keyPath: lhs] == rhs }\n}</code></pre><p>With the above in place, we can now easily filter any collection using a key path-based comparison, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> fullLengthArticles = articles.<span class=\"s-call\">filter</span>(\\.<span class=\"s-property\">category</span> == .<span class=\"s-dotAccess\">fullLength</span>)</code></pre><h2>Conclusion</h2><p>Depending on who you ask, the fact that Swift lets us easily create the above kind of functionality through a couple of lightweight overloads is either really awesome or incredibly concerning. I tend to fall somewhere in the middle, and think that it is indeed really great that we can make minor domain-specific tweaks to Swift’s syntax, but at the same time, I think those tweaks should always be made with the goal of making our code simpler, not more complex.</p><p>Like with all things I write about here on Swift by Sundell, I’ve personally used the above technique in a few projects in which I had to do a lot of collection filtering, and it’s been quite wonderful, but I wouldn’t deploy it unless I had a strong need for that kind of functionality.</p><p>For a much more thorough, and also more advanced, variant of the above technique, check out <em><a href=\"https://www.swiftbysundell.com/articles/predicates-in-swift\">“Predicates in Swift”</a></em>, and feel free to send me your questions and comments via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p>",
      "summary": "How key paths can be made much more powerful when used to query and filter collections.",
      "date_published": "2021-01-04T17:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/bitrise-holiday-2020",
      "url": "https://www.swiftbysundell.com/sponsor/bitrise-holiday-2020",
      "title": "Sponsored: Kicking off 2021 with solid continuous integration using Bitrise",
      "content_html": "<p>The start of a new year is often an excellent time to revisit old assumptions, to clean up some long-standing technical debt, or to improve the overall suite of workflows and automation that’s used within a given project.</p><p>One thing that intersects more or less all of those areas is <em>continuous integration</em>, which — as a quick recap — is the act of continuously merging new changes into a project’s main branch (rather than using long-lived feature branches), and to always run a certain set of automated tests on those changes in order to ensure that the project continues to build and run as expected.</p><p>For long-time Swift by Sundell readers, it should come as no surprise that my favorite tool for continuous integration is <strong><a href=\"https://bitrise.io/swift\">Bitrise</a></strong>, which have also helped me keep Swift by Sundell up and running all throughout the past two weeks of holidays. So to round off their latest sponsorship, I thought I’d share a few tips on how I like to configure my various projects on Bitrise. Perhaps some of these tips will help you start 2021 by adding some really solid continuous integration to your project.</p><h2>The basics go a long way</h2><p>One of my favorite things about Bitrise is just how easy it is to configure. For many of my projects, their automatic setup process (which detects what kind of project you’re working on and configures a CI pipeline accordingly) turned out to be everything that I actually needed. Because although there’s a nearly endless amount of verification that we <em>could</em> perform as part of our CI process, sometimes all that we really need to do is to compile the project and run all of its tests.</p><p>So if you haven’t yet used Bitrise, my suggestion would be to simply <a href=\"https://bitrise.io/swift\">try it</a> by setting it up with that automatic configurator, to see how it could help you improve your project’s development workflow.</p><h2>Splitting up a larger project into multiple workflows</h2><p>As a project grows, it might be a good idea to split its CI process up into multiple, separate workflows. Not only can that often improve the overall speed of getting a given Pull Request or commit green-lit by the CI system, it can also make debugging failures easier, as each workflow will end up having a much more narrow scope.</p><p>For example, let’s say that we’re working on an app that ships on both iOS and macOS. While we could build and test both of those two variants within the same Bitrise workflow, it’ll most likely be faster to use two separate ones. The good news is that Bitrise supports using the same project for multiple workflows, all that we have to do is to configure each one as a new app (but using the same repository). For example, Publish (which is the static site generator used to build all of Swift by Sundell) has two separate Bitrise workflows, one for macOS and one for Linux, that can both run in parallel.</p><p>There are also other ways that CI workflows could be split up as well. You could, for example, run all of a project’s UI tests within a separate workflow (since those tend to take the longest to run), or run the tests for any internal frameworks separately, or use separate workflows to test your app using multiple Xcode/SDK versions.</p><p>Of course, starting with just a single workflow is probably the best approach, as parallelization always tends to come with a certain amount of complexity. In this case, we might also need to be careful to keep each of our workflow configurations in sync, which could be done using a <a href=\"https://blog.bitrise.io/manage-and-store-bitriseyml-in-git\">Git-hosted workflow YML file</a>.</p><h2>Handling testing timeouts and flakiness</h2><p>One of the most commonly faced challenges when adopting a more CI-centric workflow is <em>flakiness</em>, which is when a given set of tests and verifications seem to either succeed or fail at random.</p><p>Even though Bitrise ships with a fair amount of built-in functionality that helps reduce the potential for flakiness (such as automatic retries for UI tests), at the end of the day, the overall, long-term stability of our tests will always come down to how they were actually written.</p><p>When it comes to unit and UI tests in particular, one of my top tips on how to avoid flakiness is to always use <em>generous timeouts</em> when calling APIs like <a href=\"https://www.swiftbysundell.com/articles/unit-testing-asynchronous-swift-code/#expectations\"><code>waitForExpectations</code></a> and <a href=\"https://developer.apple.com/documentation/xctest/xcuielement/2879412-waitforexistence\"><code>waitForExistence</code></a>, and to avoid using blocking waiting techniques, such as <code>sleep</code>.</p><p>If we use proper waiting APIs when writing asynchronous tests, the test runner will only pause for the whole timeout interval when a given condition or expectation wasn’t fulfilled — so using a larger timeout won’t slow down the overall execution of our tests, but will give our operations some extra time to finish when running in more resource-constrained environments, which CI servers typically are.</p><p class=\"info\">To learn more about testing timeouts and stability, check out my guest article <a href=\"https://blog.bitrise.io/making-xcode-ui-tests-faster-and-more-stable\">“Making Xcode UI tests faster and more stable”</a> on the Bitrise blog and <a href=\"https://www.swiftbysundell.com/articles/unit-testing-asynchronous-swift-code\">“Unit testing asynchronous Swift code”</a> right here on Swift by Sundell.</p><h2>Conclusion</h2><p>Regardless if you’re completely new to the concept of continuous integration, or if you already have an existing setup, now might be a great time to prepare each of your projects for the upcoming year by ensuring that you have some really solid verifications in place — and if you’re looking for a platform to implement your CI workflows on, then I really recommend <a href=\"https://bitrise.io/swift\">checking out Bitrise</a>. It’s free to get started, and it’s the CI tool that I personally use for all of my new projects.</p>",
      "summary": "A few tips on configuring continuous integration for various projects using Bitrise.",
      "date_published": "2021-01-04T13:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/using-multiple-computed-properties-to-form-a-swiftui-view-body",
      "url": "https://www.swiftbysundell.com/articles/using-multiple-computed-properties-to-form-a-swiftui-view-body",
      "title": "Using multiple computed properties to form a SwiftUI view’s body",
      "content_html": "<p>One of SwiftUI’s most powerful traits is just how composable its views are by default. Because of that, <a href=\"https://www.swiftbysundell.com/articles/avoiding-massive-swiftui-views\">breaking up a massive view</a> can often simply be a matter of moving pieces of its <code>body</code> code into new <code>View</code> types, and then wiring up any bindings or other kinds of actions as needed.</p><p>However, there are also multiple other techniques that can be good to keep in mind when we’d like to break up a larger view in order to improve its maintainability and readability. To take a look at one such technique, let’s start with the following <code>ProfileView</code>, which currently uses a single <code>body</code> property to form its internal view hierarchy:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ProfileView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> user: <span class=\"s-type\">User</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            <span class=\"s-type\">LinearGradient</span>(\n                gradient: user.<span class=\"s-property\">profileGradient</span>,\n                startPoint: .<span class=\"s-dotAccess\">top</span>,\n                endPoint: .<span class=\"s-dotAccess\">bottom</span>\n            )\n            .<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">all</span>)\n\n            <span class=\"s-type\">ScrollView</span> {\n                <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n                    <span class=\"s-type\">Text</span>(user.<span class=\"s-property\">name</span>)\n                        .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    <span class=\"s-type\">Text</span>(user.<span class=\"s-property\">biography</span>)\n                        .<span class=\"s-call\">multilineTextAlignment</span>(.<span class=\"s-dotAccess\">leading</span>)\n                }\n                .<span class=\"s-call\">padding</span>()\n                .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            }\n        }\n    }\n}</code></pre><p>While the above is not really a <em>massive</em> view in terms of line count, it could definitely be broken up in order to make it easier to iterate on and expand its functionality over time. One way to do that would be to use the aforementioned approach of splitting its <code>body</code> property up into separate <code>View</code> types — which in this case could be implemented as private nested types in order to give our code a neat degree of <a href=\"https://www.swiftbysundell.com/articles/namespacing-swift-code-with-nested-types\">namespacing</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">ProfileView</span> {\n    <span class=\"s-keyword\">struct</span> BackgroundView: <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">var</span> gradient: <span class=\"s-type\">Gradient</span>\n\n        <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n            <span class=\"s-type\">LinearGradient</span>(\n                gradient: gradient,\n                startPoint: .<span class=\"s-dotAccess\">top</span>,\n                endPoint: .<span class=\"s-dotAccess\">bottom</span>\n            )\n            .<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">all</span>)\n        }\n    }\n\n    <span class=\"s-keyword\">struct</span> InfoView: <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">var</span> user: <span class=\"s-type\">User</span>\n\n        <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n            <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n                <span class=\"s-type\">Text</span>(user.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                <span class=\"s-type\">Text</span>(user.<span class=\"s-property\">biography</span>)\n                    .<span class=\"s-call\">multilineTextAlignment</span>(.<span class=\"s-dotAccess\">leading</span>)\n            }\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n        }\n    }\n}</code></pre><p>With the above in place, we’ll now be able to drastically simplify our main <code>ProfileView</code>, since we can now implement its <code>body</code> just by instantiating our <code>BackgroundView</code> and <code>InfoView</code> within their respective <code>ZStack</code> and <code>ScrollView</code> wrappers:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ProfileView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> user: <span class=\"s-type\">User</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            <span class=\"s-type\">BackgroundView</span>(gradient: user.<span class=\"s-property\">profileGradient</span>)\n            <span class=\"s-type\">ScrollView</span> {\n                <span class=\"s-type\">InfoView</span>(user: user)\n            }\n        }\n    }\n}</code></pre><p>However, while the above approach is definitely a great option in many cases, it sort of feels a bit “heavy” in this kind of situation — given that we both need to define multiple types just to split our code up, and that we need to pass parts of our model data down into those nested views, which can quickly end up feeling like unnecessary busywork.</p><p>So let’s explore another approach, which involves creating additional <code>body</code>-like computed properties for the different parts of our view’s internal hierarchy. Since we have a quite natural separation between our view’s <em>foreground and background</em> in this case, let’s name our properties just like that, and if we use the same <code>some View</code> <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api/#opaque-return-types\">opaque return type</a> as SwiftUI’s built-in <code>body</code> property does, then we’ll end up with the following implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">ProfileView</span> {\n    <span class=\"s-keyword\">var</span> background: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">LinearGradient</span>(\n            gradient: user.<span class=\"s-property\">profileGradient</span>,\n            startPoint: .<span class=\"s-dotAccess\">top</span>,\n            endPoint: .<span class=\"s-dotAccess\">bottom</span>\n        )\n        .<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">all</span>)\n    }\n\n    <span class=\"s-keyword\">var</span> foreground: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span> {\n            <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n                <span class=\"s-type\">Text</span>(user.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                <span class=\"s-type\">Text</span>(user.<span class=\"s-property\">biography</span>)\n                    .<span class=\"s-call\">multilineTextAlignment</span>(.<span class=\"s-dotAccess\">leading</span>)\n            }\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n        }\n    }\n}</code></pre><p>With that change in place, all that we now have to do to implement our main view is to combine our <code>background</code> and <code>foreground</code> using a <code>ZStack</code> — which gives us a <code>body</code> implementation that essentially acts as a “handoff point” between our private implementation and SwiftUI as a framework:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ProfileView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> user: <span class=\"s-type\">User</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            background\n            foreground\n        }\n    }\n}</code></pre><p>The beauty of the above approach is that it doesn’t require us to pass any additional data around, since our entire implementation can now actually remain within a single type — while still achieving a very nice separation between our view’s various parts.</p><p>Of course, it’s still a good idea to split certain views up into completely separate types (especially if we want to make some of those parts easier to reuse), but the above technique can be great to keep in mind when we want to break up a larger view while still letting its implementation continue to act as a single unit.</p>",
      "summary": "How a SwiftUI view’s body can be split up into multiple computed properties, which is a great alternative to using separate types in certain situations.",
      "date_published": "2020-12-29T16:20:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/88",
      "url": "https://www.swiftbysundell.com/podcast/88",
      "title": "Podcast: “The 2020 Holiday Special”",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell88.mp3\" type=\"audio/mpeg\"/></audio><p>On this special episode of the show, John wraps up the 2020 season by revisiting some of the key themes and topics that were discussed on the show during the year.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a>.</li><li><strong><a href=\"https://nordvpn.com/sundell\">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on, and unlock your video streaming services. Get a massive 68% discount on their two-year plan, and extra free months, at <a href=\"https://nordvpn.com/sundell\">nordvpn.com/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://www.swiftbysundell.com/podcast/69\">“Swift Playgrounds” with Holly Borla and Grace Kendall</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/84\">“Key paths, functions and closures” with Vincent Pradeilles</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/76\">“A huge year for SwiftUI” with Josh Shaffer and Eliza Block</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/78\">“What’s new in Swift 5.3” with JP Simard</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/79\">“All about UICollectionView” with Ben Scheirman</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/72\">“Many layers of SwiftUI” with Tobias Due Munk</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/83\">“Adventure into widgets” with Simon Støvring</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/71\">“Polymorphic interfaces” with Dave Abrahams</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/65\">“Tools are just apps” with Gui Rambo</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/68\">“MVPs and prototypes” with Leah Culver</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/77\">“Adopting new system features” with Jordan Morgan</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "On this special episode of the show, John wraps up the 2020 season by revisiting some of the key themes and topics that were discussed on the show during the year.",
      "date_published": "2020-12-21T19:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/special/welcome-to-3-0",
      "url": "https://www.swiftbysundell.com/special/welcome-to-3-0",
      "title": "Welcome to Swift by Sundell 3.0",
      "content_html": "<p>Today I’m incredibly excited to launch the next major version of this site, which features a <a href=\"https://swiftbysundell.com\">brand new start page</a>, a new article publishing format, simplified navigation, and many other smaller tweaks and improvements.</p><p>On December 13th, I published my <a href=\"https://www.swiftbysundell.com/articles/200-weeks-of-swift\">200th and final weekly article</a>. While I really enjoyed working on that article series for almost four years straight, going forward, I’m going to use a much more flexible publishing format. Rather than sticking to a strict weekly cadence, you’ll now frequently see new articles posted that’ll both include my signature deep dives into different Swift topics, but also shorter posts, links, news stories, and more. I’m also planning to start remastering older articles with new code samples and updates for later Swift versions and new system APIs.</p><p>To match this new publishing frequency, I’ve completely redesigned <a href=\"https://swiftbysundell.com\">this site’s start page</a>, which now features a feed-like design that lets you easily browse the latest content, and I’ve updated the <a href=\"https://www.swiftbysundell.com/articles\">article section page</a> to include all of my articles — regardless of series, format, or length.</p><p>I think that this new format will be a huge upgrade for Swift by Sundell, and will let me publish new kinds of articles that didn’t really fit into the previous weekly series. Hopefully, that’ll continue to make this site an even richer resource for the Swift community, and for iOS and Mac developers of all skill levels.</p><p>So now is a great time to <a href=\"https://www.swiftbysundell.com/subscribe\">subscribe to this site through RSS</a> and to <a href=\"https://twitter.com/swiftbysundell\">follow @swiftbysundell on Twitter</a>, to get notified when new articles are posted. I’ll take some time off during the holidays, but I’ll be back in January 2021 with lots of new articles, podcasts, and videos, and just like always, everything on this site will remain 100% free for everyone.</p><p>Thanks for reading, and hope you’ll enjoy this new version of Swift by Sundell!</p><h2>Here’s everything that’s new in version 3.0:</h2><ul><li>A new, <a href=\"https://swiftbysundell.com\">completely redesigned start page</a> that features a feed-like layout, which lets you instantly start reading the latest articles as you open up the site.</li><li>Simplified navigation based on content type, and the new Discover feature is now easily accessible through the main top navigation menu.</li><li>New articles will now be continuously posted, rather than only being published on Sundays, and older articles will be frequently remastered with new code examples and updates for newer Swift versions and system APIs.</li><li>The <a href=\"https://www.swiftbysundell.com/articles\">article section page</a> has been significantly improved, and now lets you filter all articles based on type or length.</li><li>The overall design of the site has been tweaked in many places. For example, all lists and cards now feature tweaked margins and padding to make them easier to browse and read, the ads have been completely redesigned, and more.</li></ul>",
      "summary": "What’s new in the next major version of Swift by Sundell, and what my plans for 2021 are.",
      "date_published": "2020-12-16T14:55:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/instabug-december-2020",
      "url": "https://www.swiftbysundell.com/sponsor/instabug-december-2020",
      "title": "Sponsor: Instabug",
      "content_html": "<p>Thanks a lot to <a href=\"https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q420-dec-6&utm_content=spon\">Instabug</a> for sponsoring Swift by Sundell last week, which really helped me cross the finishing line of 200 weeks of consecutively published articles.</p><p>Instabug is not only my favorite crash reporter for iOS apps (I’ve used it in several projects, and it has always been fantastic!), it also includes a wide range of other features that can help you keep track of your app’s overall quality.</p><p>For example, two of their recently added features are <em>Application Performance Monitoring</em> and the <em>Apdex score</em>. The former automatically provides you with concrete performance metrics around things like app launch times, UI responsiveness, and networking speed, while the latter gives you a single, unified score that you can use to measure and improve your app’s performance over time.</p><p>Using both of those two features, and everything else that Instabug has to offer, makes it so much easier to identify regressions, to fix bugs and errors, and to constantly iterate on an app’s quality and performance.</p><p>Check out Instabug today by going to <a href=\"https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q420-dec-6&utm_content=spon\">try.instabug.com/swiftbysundell</a>. When using that URL, you also directly help support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to Instabug for sponsoring Swift by Sundell.",
      "date_published": "2020-12-14T13:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/200-weeks-of-swift",
      "url": "https://www.swiftbysundell.com/articles/200-weeks-of-swift",
      "title": "200 weeks of Swift",
      "content_html": "<p>If I had to name just one thing that I believe to be an overarching theme among the 200 weekly articles that I’ve now written about Swift development, I’d say that it’s the notion that making solid technical decisions is all about researching and then carefully comparing the tradeoffs of each potential solution.</p><p>When writing these articles, I’ve always aimed to be <em>informative</em>, rather than <em>convincing</em>. To share my learnings from adopting a given pattern, technology or framework, without necessarily telling you — the reader — that you should adopt them the exact same way that I did. Because at the end of the day, what solutions that will be the best fit for each given project will always depend on a mix between requirements, tradeoffs, and the personal opinions of the people involved in building it.</p><p>So, for my 200th and final* weekly article, I thought I’d sum up what I consider to be three of my major overall learnings after close to four years of continuous writing about Swift, its features, and many of the patterns that it’s commonly used with.</p><p class=\"info\">*Although this is indeed the final article in the weekly series that I’ve now been doing for 200 weeks, I’ll of course keep publishing many other kinds of articles on this website going forward. Check out <a href=\"https://www.swiftbysundell.com/special/welcome-to-3-0\">this article</a> for more info about my new publishing format.</p><h2>The value of value types</h2><p>When I first started programming in Swift, I strongly associated value types with data models. That is, I’d make my models, configuration types, options and other kinds of data representations all structs and enums, while keeping the rest of my code strictly object-oriented through classes and protocols.</p><p>However, these days, I tend to decide between <a href=\"https://www.swiftbysundell.com/basics/value-and-reference-types\">value and reference types</a> based purely on whether I <em>really need</em> a given type to hold any kind of <em>shared mutable state</em>. If I don’t (which tends to be the case), then I go for a value type, which not only lets me take advantage of all of the powerful language features that Swift’s value types offer — but doing so also encourages me to keep my various types as immutable as possible, even as I keep iterating on their logic.</p><p>For example, with my old way of thinking, if I were to write something like a simple <code>Dataloader</code> that acts as a wrapper around Foundation’s <code>URLSession</code> API — then I’d make that a class, mostly because it “felt right” for instances of such a type to be actual objects that are passed by reference, rather than values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> DataLoader {\n    <span class=\"s-keyword\">typealias</span> Handler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Data</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n\n    <span class=\"s-keyword\">init</span>(urlSession: <span class=\"s-type\">URLSession</span> = .<span class=\"s-dotAccess\">shared</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">urlSession</span> = urlSession\n    }\n\n    <span class=\"s-keyword\">func</span> loadData(from url: <span class=\"s-type\">URL</span>,\n                  then handler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: url) {\n            data, response, error <span class=\"s-keyword\">in</span>\n            ...\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>However, there’s really nothing about the above type that warrants reference semantics. It doesn’t hold any form of state that needs to be shared across multiple call sites, and for this kind of low-level code, I’d actually prefer things to stay that way.</p><p>So, by turning my <code>DataLoader</code> into a struct instead, I’ll both get a strong protection against accidental mutations (as a struct can only mutate itself within methods that are explicitly marked as <code>mutating</code>), and I’ll also be able to remove my manually implemented initializer, since the compiler will now generate a <a href=\"https://www.swiftbysundell.com/tips/when-can-memberwise-initializers-be-used\">memberwise</a> one (like it does for all structs):</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DataLoader {\n    <span class=\"s-keyword\">typealias</span> Handler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Data</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n\n    <span class=\"s-keyword\">func</span> loadData(from url: <span class=\"s-type\">URL</span>,\n                  then handler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: url) {\n            data, response, error <span class=\"s-keyword\">in</span>\n            ...\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>One tradeoff with the above solution, however, is that the underlying <code>URLSession</code> instance that my <code>DataLoader</code> is using is now exposed as part of its API. While that could be problematic in certain cases, I’d gladly accept that tradeoff in this case — especially since this particular <code>DataLoader</code> type is simply a wrapper around <code>URLSession</code> to begin with.</p><p>Since <code>DataLoader</code> is now a value type, that also means that it can be mutated using <em><a href=\"https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift\">value semantics</a></em>, which in turn will make those mutations local by default. To illustrate, let’s say that we wanted to add support for attaching a series of HTTP headers to each request that a given <code>DataLoader</code> will make. Because we’re now dealing with a value type, adding those headers either requires us to create a brand new instance, or to copy an existing one — which is great — since that prevents us from accidentally sharing those header values across the entire application:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DataLoader {\n    <span class=\"s-keyword\">typealias</span> Handler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Data</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">var</span> headers = [<span class=\"s-type\">String</span> : <span class=\"s-type\">String</span>]()\n\n    <span class=\"s-keyword\">func</span> loadData(from url: <span class=\"s-type\">URL</span>,\n                  then handler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(url: url)\n        request.<span class=\"s-property\">allHTTPHeaderFields</span> = headers\n\n        <span class=\"s-keyword\">let</span> task = urlSession.<span class=\"s-call\">dataTask</span>(with: request) {\n            data, response, error <span class=\"s-keyword\">in</span>\n            ...\n        }\n\n        task.<span class=\"s-call\">resume</span>()\n    }\n}</code></pre><p>So while I still use classes in many types of situations, especially when I really need to share a piece of state among multiple types, structs have gradually become my default tool for implementing new types — especially when working with very value-centric frameworks, such as SwiftUI.</p><h2>Using types as documentation</h2><p>One of my favorite aspects of Swift is its very strong, static type system. Increasingly, it feels like as long as my code compiles, it’ll actually do what I intended, which is quite amazing. But strong typing is not only great for compile time verification, it can also be a fantastic tool for <em>communication</em>.</p><p>Take Foundation’s <code>URL</code> type as an example. At the end of the day, URLs are just strings, but there’s also a certain set of (quite complex) rules that they have to follow. So while every URL is a string, not every string is a URL. To me, that’s exactly the kind of data that warrants its own, dedicated type — even when we’re dealing with custom, app-specific data that <em>could</em> technically be represented using raw values, such as strings or integers.</p><p>For example, the following <code>UserSession</code> type contains two properties that are currently stored as raw <code>String</code> values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserSession {\n    <span class=\"s-keyword\">var</span> id: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> accessToken: <span class=\"s-type\">String</span>\n    ...\n}</code></pre><p>While both of the above two properties might be quite self-explanatory when viewed in the context of their enclosing <code>UserSession</code> type, chances are quite high that we’d also like to pass those values around individually — at which point we’d now be dealing with completely context-less strings.</p><p>Compare that to the following <code>UserSession</code> implementation, which now uses strong types that clearly explain what each piece of data does, and — as an added bonus — will also make any code using those values much more type safe:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserSession {\n    <span class=\"s-keyword\">var</span> id: <span class=\"s-type\">User</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">var</span> accessToken: <span class=\"s-type\">AccessToken</span>\n    ...\n}</code></pre><p>At first, it might seem like implementing such wrapper types will be a lot of work — but both thanks to Swift’s aforementioned value type features, and to the many built-in protocols that the Swift standard library ships with — it could simply be done like this:</p><pre class=\"splash\"><code><span class=\"s-comment\">// Marking a type as Identifiable gives us a nested ID type\n// based on its 'id' property (UUID in this case):</span>\n<span class=\"s-keyword\">struct</span> User: <span class=\"s-type\">Codable</span>, <span class=\"s-type\">Identifiable</span> {\n    <span class=\"s-keyword\">let</span> id: <span class=\"s-type\">UUID</span>\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    ...\n}\n\n<span class=\"s-comment\">// When using RawRepresentable, each value will be automatically\n// encoded and decoded using its raw value (String in this case):</span>\n<span class=\"s-keyword\">struct</span> AccessToken: <span class=\"s-type\">Codable</span>, <span class=\"s-type\">RawRepresentable</span> {\n    <span class=\"s-keyword\">var</span> rawValue: <span class=\"s-type\">String</span>\n}</code></pre><p>With the above in place, we’ll now be able to freely pass each of our <code>UserSession</code> values around individually without losing their contextual meaning. For example, here’s how we might extend our <code>DataLoader</code> from before with an API for authorizing its requests using a given access token — and since that value now has a dedicated type, our resulting code becomes quite <em><a href=\"https://www.swiftbysundell.com/articles/writing-self-documenting-swift-code\">self-documenting</a></em>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">DataLoader</span> {\n    <span class=\"s-keyword\">mutating func</span> authorize(with token: <span class=\"s-type\">AccessToken</span>) {\n        headers[<span class=\"s-string\">\"Authorization\"</span>] = <span class=\"s-string\">\"Bearer</span> \\(token.<span class=\"s-property\">rawValue</span>)<span class=\"s-string\">\"</span>\n    }\n}</code></pre><p>These types of changes might seem quite minor in the grand scheme of things, but in my experience, they can really have a quite big impact on the overall semantics and readability of a given system. Because after all, code is only written once, but read multiple times, regardless if we work on our own or with other people, so optimizing for readability and ease of understanding is almost always worth the effort.</p><h2>Protocols are not always the answer</h2><p>In the early days of Swift, the term “protocol-oriented programming” became incredibly popular, and many Swift developers (myself included) started to view protocols as the default way of defining all kinds of abstractions. However, as is the problem with most patterns that are called something like “X-oriented” or “X-driven”, it’s easy to get the impression that the goal is to follow the pattern itself as much as possible, which can most often be quite counter-productive.</p><p>So while I still consider protocols to be an incredibly powerful tool, the way that I personally use them has certainly changed over the past 200 weeks. Now, I look at protocols as just another tool in my toolbox, rather than as a design goal. For example, protocols are still a really great option in situations such as:</p><ul><li>When we want to create an abstraction that involves a number of different requirements, such as when hiding certain concrete types in order to <a href=\"https://www.swiftbysundell.com/articles/separation-of-concerns-using-protocols-in-swift\">separate concerns</a>.</li><li>When sharing functionality between multiple types, just like how the standard library provides many different APIs through extensions on protocols like <code>Collection</code>, <code>Equatable</code>, and the <code>Identifiable</code> and <code>RawRepresentable</code> protocols that we used earlier.</li></ul><p>On the other hand, if I’m only looking to model a single requirement, then I’d often rather use a single function instead. When doing that, I don’t need to maintain two separate declarations, while still achieving a high degree of separation of concerns and testability.</p><p>For example, let’s now say that we’re looking to build a <code>UserLoader</code> type that’ll use our <code>DataLoader</code> from before as its underlying networking engine. Rather than creating a protocol that has a 1:1 relationship to that concrete <code>DataLoader</code> type, let’s instead model the functionality that we’re looking to use — the <code>loadData(from:then:)</code> method in this case — as a function that looks like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">typealias</span> DataLoading = (<span class=\"s-type\">URL</span>, <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">DataLoader</span>.<span class=\"s-type\">Handler</span>) -&gt; <span class=\"s-type\">Void</span></code></pre><p>Then, rather than injecting a <code>DataLoader</code> instance directly into our new <code>UserLoader</code>, we’ll instead be able to inject any function that matches the above signature, and our user loader can then simply call that function when loading its data:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserLoader {\n    <span class=\"s-keyword\">typealias</span> Handler = (<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">User</span>, <span class=\"s-type\">Error</span>&gt;) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">var</span> dataLoading: <span class=\"s-type\">DataLoading</span>\n    <span class=\"s-keyword\">var</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n\n    <span class=\"s-keyword\">func</span> loadUser(withID id: <span class=\"s-type\">User</span>.<span class=\"s-type\">ID</span>,\n                  then handler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-keyword\">let</span> url = <span class=\"s-call\">resolveURL</span>(forID: id)\n\n        <span class=\"s-call\">dataLoading</span>(url) { result <span class=\"s-keyword\">in\n            do</span> {\n                <span class=\"s-keyword\">let</span> data = <span class=\"s-keyword\">try</span> result.<span class=\"s-call\">get</span>()\n                <span class=\"s-keyword\">let</span> user = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">decode</span>(<span class=\"s-type\">User</span>.<span class=\"s-keyword\">self</span>, from: data)\n                <span class=\"s-call\">handler</span>(.<span class=\"s-call\">success</span>(user))\n            } <span class=\"s-keyword\">catch</span> {\n                <span class=\"s-call\">handler</span>(.<span class=\"s-call\">failure</span>(error))\n            }\n        }\n    }\n}</code></pre><p>Thanks to the fact that Swift supports <a href=\"https://www.swiftbysundell.com/articles/first-class-functions-in-swift\">first class functions</a>, we can then pass a reference to the <code>DataLoader</code> method that we’re looking to use simply by doing this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> dataLoader = <span class=\"s-type\">DataLoader</span>()\n<span class=\"s-keyword\">let</span> userLoader = <span class=\"s-type\">UserLoader</span>(dataLoading: dataLoader.<span class=\"s-property\">loadData</span>)</code></pre><p>So what’s the benefit of doing the above, and — sticking to that overall theme again — what are the tradeoffs? Perhaps my favorite thing about the above pattern is that it makes testing so much easier.</p><p>Even though protocols can heavily improve the testability of a given type, they always require us to implement <a href=\"https://www.swiftbysundell.com/articles/mocking-in-swift\">dedicated mock types</a> for each piece of functionality that we’re looking to simulate within our tests. When using the functional approach, however, mocking a dependency becomes as simple as using a closure — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> UserLoaderTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testSuccessfullyLoadingUser() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> user = <span class=\"s-type\">User</span>(id: <span class=\"s-type\">UUID</span>(), name: <span class=\"s-string\">\"John Appleseed\"</span>)\n        <span class=\"s-keyword\">let</span> data = <span class=\"s-keyword\">try</span> <span class=\"s-type\">JSONEncoder</span>().<span class=\"s-call\">encode</span>(user)\n\n        <span class=\"s-keyword\">let</span> loader = <span class=\"s-type\">UserLoader</span> { <span class=\"s-keyword\">_</span>, handler <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">handler</span>(.<span class=\"s-call\">success</span>(data))\n        }\n\n        <span class=\"s-keyword\">var</span> result: <span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">User</span>, <span class=\"s-type\">Error</span>&gt;?\n        loader.<span class=\"s-call\">loadUser</span>(withID: user.<span class=\"s-property\">id</span>) { result = $0 }\n        <span class=\"s-call\">XCTAssertEqual</span>(<span class=\"s-keyword\">try</span> result?.<span class=\"s-call\">get</span>(), user)\n    }\n}</code></pre><p class=\"info\">To learn more about the above approach, check out <a href=\"https://www.swiftbysundell.com/articles/mock-free-unit-tests-in-swift\">“Mock-free unit tests in Swift”</a>.</p><p>One of the major tradeoffs, though, is that the above technique doesn’t scale very well for types that have a larger number of dependencies, as we’d have to inject each of those dependencies as separate functions — which can quickly get quite messy. Also, when we need to call multiple methods on a single type, using a protocol (or injecting an instance of that type directly) is most likely going to be easier than passing multiple separate functions.</p><p>Even so, it’s a great technique to keep in mind, along with a few <a href=\"https://www.swiftbysundell.com/articles/alternatives-to-protocols-in-swift\">other protocol alternatives</a>, rather than immediately reaching for a protocol in all kinds of situations.</p><h2>Conclusion</h2><p>When I started writing these weekly articles, Swift by Sundell didn’t yet exist, Swift 3 was the new cool version of the language, and I had no idea whether anyone would actually want to read what I was about to write.</p><p>Now, 200 weeks later, not only have I learned so much about Swift, what it means to be a writer, and all of the things that are involved in running a website like this — I’ve also had the true pleasure of discussing these topics with so many of you — both <a href=\"https://twitter.com/johnsundell\">on Twitter</a>, <a href=\"https://www.swiftbysundell.com/contact\">through email</a>, and at various conferences and meetups around the world.</p><p>So whether this was the first weekly article that you’ve ever read, or your 200th one, thank you. All of your combined support, feedback and encouragement is truly what has kept my going during these 200 weeks of continuous writing. Because as long as the Swift community remains interested in what I have to write, I’ll do my very best to keep writing.</p><p>Thanks for reading! 🚀</p>",
      "summary": "Wrapping up the weekly article series with three of my major overall learnings after close to four years of continuous writing about Swift.",
      "date_published": "2020-12-13T19:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/matteo-manferdini-december-2020",
      "url": "https://www.swiftbysundell.com/sponsor/matteo-manferdini-december-2020",
      "title": "Sponsor: Architecting SwiftUI apps with MVC and MVVM",
      "content_html": "<p>Thanks a lot to Matteo Manferdini for sponsoring Swift by Sundell these past two weeks to promote his (completely free!) SwiftUI guide <em><a href=\"https://matteomanferdini.com/architecting-swiftui-apps-with-mvc-and-mvvm/swiftbysundell\">“Architecting SwiftUI apps with MVC and MVVM”</a></em>.</p><p>Matteo’s guide contains lots of practical examples and advice on how to apply various architectural patterns within SwiftUI code, and how to adopt traditionally object-oriented concepts (like controllers) to the declarative world of SwiftUI. It also contains interesting discussions around design patterns in general, and each technique is neatly explained using code samples, screenshots and flow charts.</p><p>Get the guide <a href=\"https://matteomanferdini.com/architecting-swiftui-apps-with-mvc-and-mvvm/swiftbysundell\">for free right here</a>, and just by downloading Matteo’s free guide you’ll also directly help support Swift by Sundell as well. Pretty great, right?</p>",
      "summary": "Thanks a lot to Architecting SwiftUI apps with MVC and MVVM for sponsoring Swift by Sundell.",
      "date_published": "2020-12-07T09:50:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/the-lifecycle-and-semantics-of-a-swiftui-view",
      "url": "https://www.swiftbysundell.com/articles/the-lifecycle-and-semantics-of-a-swiftui-view",
      "title": "The lifecycle and semantics of a SwiftUI view",
      "content_html": "<p>One of the key differences between SwiftUI and its predecessors, UIKit and AppKit, is that views are primarily declared as <em>value types</em>, rather than as concrete references to what’s being drawn on screen.</p><p>Not only does that shift in design play a major part in making SwiftUI’s API feel so lightweight, it can also often become a source of confusion, especially for developers who (like me) have been used to the very object-oriented conventions that Apple’s UI frameworks have used up until this point.</p><p>So this week, let’s take a more thorough look at what it means for SwiftUI to be a declarative, value-driven UI framework, and how we might need to break certain assumptions and previous best practices that were based on UIKit and AppKit when starting to adopt SwiftUI within our projects.</p><h2>The role of the body property</h2><p>The <code>View</code> protocol’s <code>body</code> property is perhaps the most common source of misunderstandings about SwiftUI as a whole, especially when it comes to that property’s relationship to its view’s update and rendering cycle.</p><p>In the imperative world of UIKit and AppKit, we have methods like <code>viewDidLoad</code> and <code>layoutSubviews</code>, which essentially act as <em>hooks</em> that let us respond to a given system event by executing a piece of logic. While it’s easy to look at the SwiftUI <code>body</code> property as another such event (that lets us re-render our view), that’s really not the case.</p><p>Instead, the <code>body</code> property lets us <em>describe</em> how we want our view to be rendered given its current state, and the system will then use that description to determine if, when, and how our view should actually be rendered.</p><p>For example, when building a UIKit-based view controller, it’s really common to trigger model updates within the <code>viewWillAppear</code> method, to ensure that the view controller is always rendering the latest available data:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ArticleViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n    \n    ...\n\n    <span class=\"s-keyword\">override func</span> viewWillAppear(<span class=\"s-keyword\">_</span> animated: <span class=\"s-type\">Bool</span>) {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewWillAppear</span>(animated)\n        viewModel.<span class=\"s-call\">update</span>()\n    }\n}</code></pre><p>Then, when moving to SwiftUI, an initial idea on how to replicate the above pattern might be to do the following, and perform our view model update when computing our view’s <code>body</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        viewModel.<span class=\"s-call\">update</span>()\n\n        <span class=\"s-keyword\">return</span> <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">Text</span>(viewModel.<span class=\"s-property\">article</span>.<span class=\"s-property\">text</span>)\n            ...\n        }\n    }\n}</code></pre><p>However, the problem with the above approach is that our view’s <code>body</code> will be re-evaluated whenever our view model was changed, and also every time that any of our parent views were updated — meaning that the above implementation will very likely lead to <em>a lot</em> of unnecessary model updates (or even update cycles).</p><p class=\"info\">To learn more about what causes a SwiftUI view to be updated, check out this <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">guide to the SwiftUI state management system</a>.</p><p>So it turns out that a view’s <code>body</code> is not a great place for triggering side effects. Instead, SwiftUI provides a few different <em>modifiers</em> that act very similarly to those hooks that we had access to in UIKit and AppKit. In this case, we can use the <code>onAppear</code> modifier to get the same behavior as when using the <code>viewWillAppear</code> method within a view controller:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">Text</span>(viewModel.<span class=\"s-property\">article</span>.<span class=\"s-property\">text</span>)\n            ...\n        }\n        .<span class=\"s-call\">onAppear</span>(perform: viewModel.<span class=\"s-property\">update</span>)\n    }\n}</code></pre><p>In general, whenever we <em>need</em> to use the <code>return</code> keyword within a SwiftUI <code>body</code>, we’re likely doing something wrong, as the role of that property is to describe our view hierarchy using <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api\">SwiftUI’s DSL</a> — not to perform operations, and not to trigger side effects.</p><h2>The initializer problem</h2><p>Along the same lines, we also should be careful not to make any assumptions about the lifecycles of our views themselves. In fact, it could be argued that SwiftUI views don’t even <em>have</em> proper lifecycles, given that they’re <a href=\"https://www.swiftbysundell.com/basics/value-and-reference-types\">values, not references</a>.</p><p>For example, let’s now say that we wanted to modify the above <code>ArticleView</code> to make it update its view model whenever the app was resumed after being moved to the background, rather than every time that the view appears. One way to make that happen would be to once again follow a very object-oriented approach, and observe the app’s default <code>NotificationCenter</code> from within our view’s initializer — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    <span class=\"s-keyword\">init</span>(viewModel: <span class=\"s-type\">ArticleViewModel</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">viewModel</span> = viewModel\n\n        cancellable = <span class=\"s-type\">NotificationCenter</span>.<span class=\"s-property\">default</span>.<span class=\"s-call\">publisher</span>(\n            for: <span class=\"s-type\">UIApplication</span>.<span class=\"s-property\">willEnterForegroundNotification</span>\n        )\n        .<span class=\"s-call\">sink</span> { <span class=\"s-keyword\">_ in</span>\n            viewModel.<span class=\"s-call\">update</span>()\n        }\n    }\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">Text</span>(viewModel.<span class=\"s-property\">article</span>.<span class=\"s-property\">text</span>)\n            ...\n        }\n    }\n}</code></pre><p>However, while the above implementation <em>will</em> work perfectly fine in complete isolation, as soon as we start embedding our <code>ArticleView</code> within other views, it’ll start to become quite problematic.</p><p>To illustrate, here we’re creating multiple <code>ArticleView</code> values within an <code>ArticleListView</code>, which uses the built-in <code>List</code> and <code>NavigationLink</code> components to enable the user to navigate to each article that’s shown within a scrollable list:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> store: <span class=\"s-type\">ArticleStore</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span>(store.<span class=\"s-property\">articles</span>) { article <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">NavigationLink</span>(article.<span class=\"s-property\">title</span>,\n                destination: <span class=\"s-type\">ArticleView</span>(\n                    viewModel: <span class=\"s-type\">ArticleViewModel</span>(\n                        article: article,\n                        store: store\n                    )\n                )\n            )\n        }\n    }\n}</code></pre><p>Since <code>NavigationLink</code> requires us to specify each <code>destination</code> up-front (which initially might seem rather strange, but does make a lot of sense once we start thinking of our SwiftUI views as simple values), and since we’re currently setting up our <code>NotificationCenter</code> observations when initializing our <code>ArticleView</code> values, all of those observations will be immediately activated — even if those views haven’t actually been rendered yet.</p><p>So let’s instead implement that functionality in a much more granular way, so that only the <em>currently displayed</em> <code>ArticleView</code> will be updated when the app moves to the foreground, rather than updating every single <code>ArticleViewModel</code> at once, which would be rather inefficient.</p><p>To do that, we’ll again use a dedicated modifier, <code>onReceive</code>, instead of manually configuring our <code>NotificationCenter</code> observation as part of our view’s initializer. As an added bonus, when doing that, we no longer need to maintain a <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine cancellable</a> ourselves — since the system will now manage that subscription on our behalf:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">Text</span>(viewModel.<span class=\"s-property\">article</span>.<span class=\"s-property\">text</span>)\n            ...\n        }\n        .<span class=\"s-call\">onReceive</span>(<span class=\"s-type\">NotificationCenter</span>.<span class=\"s-property\">default</span>.<span class=\"s-call\">publisher</span>(\n            for: <span class=\"s-type\">UIApplication</span>.<span class=\"s-property\">willEnterForegroundNotification</span>\n        )) { <span class=\"s-keyword\">_ in</span>\n            viewModel.<span class=\"s-call\">update</span>()\n        }\n    }\n}</code></pre><p class=\"info\">For more on various ways to observe Combine publishers in SwiftUI views, check out <a href=\"https://www.swiftbysundell.com/tips/observing-combine-publishers-in-swiftui-views\">this article</a>.</p><p>So just because a SwiftUI view is <em>created</em> doesn’t mean that it will be rendered or otherwise used, which is why most SwiftUI APIs require us to create all of our views up-front, rather than once each view is about to be displayed. Again, we’re only creating <em>descriptions</em> of our views, rather than actually rendering them ourselves — so just like how we should ideally keep our <code>body</code> properties free of side effects, the same thing is also true for view initializers as well (and, arguably, <a href=\"https://www.swiftbysundell.com/articles/initializers-in-swift/#avoiding-complexity-and-side-effects\">initializers in general</a>).</p><h2>Ensuring that UIKit and AppKit views can be properly reused</h2><p>Correctly following SwiftUI’s intended design is perhaps especially important when <a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\">bringing UIKit or AppKit views into SwiftUI</a> using protocols like <code>UIViewRepresentable</code> — since when doing so, we a<em>re in fact</em> responsible for creating and updating the underlying instances that our views are rendered using.</p><p>All variants of SwiftUI’s various bridging protocols include two methods — one for creating (or, in factory method parlance, <em>making</em>) the underlying instance, and one for updating it. However, initially it might seem like the <code>update</code> method is only needed for dynamic, interactive components, and that the <code>make</code> method could simply configure an instance that’s being created elsewhere.</p><p>For example, here we’re doing just that in order to render an <code>NSAttributedString</code> using an instance of UIKit’s <code>UILabel</code>, which we’re managing using a private property:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AttributedText: <span class=\"s-type\">UIViewRepresentable</span> {\n    <span class=\"s-keyword\">var</span> string: <span class=\"s-type\">NSAttributedString</span>\n\n    <span class=\"s-keyword\">private let</span> label = <span class=\"s-type\">UILabel</span>()\n\n    <span class=\"s-keyword\">func</span> makeUIView(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">UILabel</span> {\n        label.<span class=\"s-property\">attributedText</span> = string\n        <span class=\"s-keyword\">return</span> label\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIView(<span class=\"s-keyword\">_</span> view: <span class=\"s-type\">UILabel</span>, context: <span class=\"s-type\">Context</span>) {\n        <span class=\"s-comment\">// No-op</span>\n    }\n}</code></pre><p>However, there are two quite major problems with the above implementation:</p><ul><li>First, the fact that we’re creating our underlying <code>UILabel</code> by assigning it to a property means that we’ll end up recreating that instance every time that our struct is recreated (which, as we’ve already explored, can happen for a number of reasons, including when one of our parent views were updated).</li><li>Second, by not updating our view within the <code>updateUIView</code> method, our label will continue to render the same <code>attributedText</code> that it was assigned within <code>makeUIView</code>, even if our <code>string</code> property has been modified.</li></ul><p>To fix those two issues, let’s instead create our <code>UILabel</code> <em>lazily</em> within the <code>makeUIView</code> method, and rather than retaining it ourselves, we’ll let the system manage it for us. We’ll then always re-assign our <code>string</code> to our label’s <code>attributedText</code> property every time that <code>updateUIView</code> is called — which gives us the following implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AttributedText: <span class=\"s-type\">UIViewRepresentable</span> {\n    <span class=\"s-keyword\">var</span> string: <span class=\"s-type\">NSAttributedString</span>\n\n    <span class=\"s-keyword\">func</span> makeUIView(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">UILabel</span> {\n        <span class=\"s-type\">UILabel</span>()\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIView(<span class=\"s-keyword\">_</span> view: <span class=\"s-type\">UILabel</span>, context: <span class=\"s-type\">Context</span>) {\n        view.<span class=\"s-property\">attributedText</span> = string\n    }\n}</code></pre><p>With the above in place, our <code>UILabel</code> will now be correctly reused, and its <code>attributedText</code> will always be kept up to date with our wrapper’s <code>string</code> property. Really nice.</p><p>The beauty of the above changes is that they actually made our code much simpler, since we’re once again leveraging the system’s own conventions and state management mechanisms, rather than inventing our own. In fact, that’s perhaps the single most important thing when working with SwiftUI, to try to always lean into the way that it was designed, and to make proper use of its built-in mechanisms — which might require us to “unlearn” certain patterns that we’ve been used to when working with frameworks like UIKit and AppKit.</p><h2>Conclusion</h2><p>What makes being a developer both fun, and occasionally quite exhausting, is the fact that we’re never done learning. Every year, month or sometimes even week, there’s some form of new framework, tool or API that we need to learn, and while that knowledge tends to be quite incremental when working with a single platform (such as iOS), SwiftUI is <a href=\"https://www.swiftbysundell.com/articles/shifting-paradigms-in-swift\">far from incremental</a> when compared to its predecessors.</p><p>So making the very best use of SwiftUI — either within an existing project, or when building a brand new one — often requires us to use new patterns and techniques that let us fully utilize the semantics and lifecycles of the views that we’ll create. I hope that this article has given you a bit of additional insight into how to do just that, and feel free to let me know if you have any questions, comments or feedback. You can easily reach me via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "A look at what it means for SwiftUI to be a value-driven UI framework, and how we might need to break certain assumptions when adopting SwiftUI within our projects.",
      "date_published": "2020-12-06T17:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/observing-combine-publishers-in-swiftui-views",
      "url": "https://www.swiftbysundell.com/tips/observing-combine-publishers-in-swiftui-views",
      "title": "Observing Combine publishers in SwiftUI views",
      "content_html": "<p>SwiftUI offers multiple ways to connect a given view to the underlying state that it depends on, for example using property wrappers like <code>@State</code> and <code>@ObservedObject</code>. While using those property wrappers is certainly the preferred approach in the vast majority of cases, another option that can be good to keep in mind is that we can also observe Combine publishers <em>directly</em> within our SwiftUI views as well.</p><p>As an example, let’s say that we’re working on a view that plays a repeated animation for as long as the app remains in the foreground, and that we’d like to pause that animation when that’s no longer the case.</p><p>To do that, we could use <code>NotificationCenter</code>, which (since iOS 13 + macOS Catalina) ships with a Combine-powered API that lets us easily create a <code>Publisher</code> for any <code>Notification</code> that we’d like to observe. Then, we could use the <code>onReceive</code> modifier to connect that publisher to our SwiftUI view’s <code>body</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AnimationView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@State private var</span> isAnimating = <span class=\"s-keyword\">true\n\n    var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n        }\n        .<span class=\"s-call\">onReceive</span>(<span class=\"s-type\">NotificationCenter</span>.<span class=\"s-property\">default</span>.<span class=\"s-call\">publisher</span>(\n            for: <span class=\"s-type\">UIApplication</span>.<span class=\"s-property\">didEnterBackgroundNotification</span>\n        )) { <span class=\"s-keyword\">_ in</span>\n            <span class=\"s-comment\">// The app moved to the background</span>\n            isAnimating = <span class=\"s-keyword\">false</span>\n        }\n    }\n}</code></pre><p>Note how we don’t need to make our view store an <code>AnyCancellable</code>, or otherwise manage the connection to our publisher in any way — SwiftUI takes care of all of that for us!</p><p>However, the code required to observe a <code>NotificationCenter</code>-provided publisher is quite verbose, so if the above is a pattern that we’re looking to follow in multiple places throughout our code base, then we could also implement a few convenience APIs that’ll let us do so more easily:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">func</span> onNotification(\n        <span class=\"s-keyword\">_</span> notificationName: <span class=\"s-type\">Notification</span>.<span class=\"s-type\">Name</span>,\n        perform action: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Void</span>\n    ) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-call\">onReceive</span>(<span class=\"s-type\">NotificationCenter</span>.<span class=\"s-property\">default</span>.<span class=\"s-call\">publisher</span>(\n            for: notificationName\n        )) { <span class=\"s-keyword\">_ in</span>\n            <span class=\"s-call\">action</span>()\n        }\n    }\n\n    <span class=\"s-keyword\">func</span> onAppEnteredBackground(\n        perform action: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Void</span>\n    ) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-call\">onNotification</span>(\n            <span class=\"s-type\">UIApplication</span>.<span class=\"s-property\">didEnterBackgroundNotification</span>,\n            perform: action\n        )\n    }\n}</code></pre><p>With the above in place, we’ll now be able to observe when our app moved to the background simply by doing this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AnimationView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@State private var</span> isAnimating = <span class=\"s-keyword\">true\n\n    var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n        }\n        .<span class=\"s-call\">onAppEnteredBackground</span> {\n            isAnimating = <span class=\"s-keyword\">false</span>\n        }\n    }\n}</code></pre><p>Finally, using the <code>onReceive</code> modifier can also be a great way to observe our own, custom publishers as well — which in turn can act as a more lightweight alternative to something like an <code>ObservedObject</code> when setting up a reference to a mutable piece of state.</p><p>For example, here an <code>ItemList</code> is using a publisher to observe an external array of <code>Item</code> values, which it then stores in a local <code>@State</code> property to connect it to its <code>body</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ItemList: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> publisher: <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">Never</span>&gt;\n    <span class=\"s-keyword\">@State private var</span> items = [<span class=\"s-type\">Item</span>]()\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span>(items) { item <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">ItemRow</span>(item: item)\n        }\n        .<span class=\"s-call\">onReceive</span>(publisher) {\n            items = $0\n        }\n    }\n}</code></pre><p>Of course, that doesn’t mean that we should replace all uses of <code>ObservedObject</code> with the above pattern, but it’s a neat technique for when we just want to observe a single event, rather than a complex object.</p>",
      "date_published": "2020-12-04T12:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/87",
      "url": "https://www.swiftbysundell.com/podcast/87",
      "title": "Podcast: “The SwiftUI layout system”, with special guest Chris Eidhof",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell87.mp3\" type=\"audio/mpeg\"/></audio><p>Chris Eidhof returns to the show to go on a deep dive into the SwiftUI layout system. What are the different phases involved in determining a given view’s layout, how do concepts like layout priorities and flexibility work, and what makes SwiftUI different from UIKit and AppKit in terms of layout?</p><h2>Sponsor</h2><p><strong><a href=\"https://nordvpn.com/sundell\">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on, and unlock your video streaming services. Get a massive 68% discount on their two-year plan, and extra free months, at <a href=\"https://nordvpn.com/sundell\">nordvpn.com/sundell</a>.</p><p><em>Does your company want to sponsor Swift by Sundell and reach tens of thousands of Swift developers like you? Check out <a href=\"https://swiftbysundell.com/sponsor/\">this sponsorship page</a> for more information.</em></p><h2>Links</h2><ul><li><a href=\"https://twitter.com/chriseidhof\">Chris on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://www.objc.io\">objc.io</a></li><li><a href=\"http://talk.objc.io\">Swift Talk</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/45\">The previous episode with Chris (and Matt Gallagher)</a></li><li><a href=\"https://www.objc.io/books/thinking-in-swiftui\">Thinking in SwiftUI</a></li><li><a href=\"https://elm-lang.org\">Elm</a></li><li><a href=\"https://www.youtube.com/watch?v=dcqWlEaw58M\">Talk about Incremental</a></li><li><a href=\"https://swiftui-lab.com\">The SwiftUI Lab</a></li><li><a href=\"https://developer.apple.com/videos/play/wwdc2019/237\">Session 237 from WWDC 2019</a></li><li><a href=\"https://www.objc.io/blog/2020/11/09/hstacks-child-ordering\">objc.io article about how HStack layouts are computed</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/geometryreader\">GeometryReader</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-layout-system-guide-part-1\">A guide to the SwiftUI layout system</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uicollectionviewflowlayout\">UICollectionViewFlowLayout</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Chris Eidhof returns to the show to go on a deep dive into the SwiftUI layout system. What are the different phases involved in determining a given view’s layout, how do concepts like layout priorities and flexibility work, and what makes SwiftUI different from UIKit and AppKit in terms of layout?",
      "date_published": "2020-12-03T14:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/sorting-swift-collections",
      "url": "https://www.swiftbysundell.com/articles/sorting-swift-collections",
      "title": "Sorting Swift collections",
      "content_html": "<p>When working with arrays and other collections, it’s incredibly common to want to sort the values that they contain, especially when dealing with local user data. In certain situations, we might give our users explicit control over how various lists are sorted, while other situations might require us to automatically sort a given data set in order to make it more predictable and easier to handle.</p><p>Regardless, both Foundation and the Swift standard library ship with a number of different APIs that can be used to implement that kind of sorting logic. This week, let’s take a look at some of those APIs, and how we could also augment them in order to make more advanced sorting tasks easier to perform.</p><h2>Let’s start with the basics</h2><p>Any Swift <code>Sequence</code> (which includes common data structures, like arrays, dictionaries, and sets) can be sorted using the <code>sorted</code> API, which takes a closure that’s used to determine the sort order by comparing two elements at a time.</p><p>For example, here we’re sorting an array of <code>TodoItem</code> values based on the <code>date</code> of each instance, and by using the less-than operator (<code>&lt;</code>) to perform our comparison, we’ll end up with an array that’s sorted in ascending order:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> TodoItem {\n    <span class=\"s-keyword\">var</span> date: <span class=\"s-type\">Date</span>\n    ...\n}\n\n<span class=\"s-keyword\">func</span> sortItemsByDate(<span class=\"s-keyword\">_</span> items: [<span class=\"s-type\">TodoItem</span>]) -&gt; [<span class=\"s-type\">TodoItem</span>] {\n    items.<span class=\"s-call\">sorted</span> { itemA, itemB <span class=\"s-keyword\">in</span>\n        itemA.<span class=\"s-property\">date</span> &lt; itemB.<span class=\"s-property\">date</span>\n    }\n}</code></pre><p class=\"info\">The built-in <code>sorted</code> method can be called on any <code>Sequence</code> (so not just arrays). However, it always returns an <code>Array</code> as its output, regardless of what type of collection that it was called on.</p><p>While using <code>sorted</code> like we do above gives us complete control over our sorting operation, what’s really nice is that any collection that contains <code>Comparable</code> values can be sorted <em>without</em> requiring us to pass any closure at all — meaning that something like an array of <code>Int</code> values can be sorted simply by doing this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> numbers: [<span class=\"s-type\">Int</span>] = ...\n<span class=\"s-keyword\">let</span> sortedNumbers = numbers.<span class=\"s-call\">sorted</span>()</code></pre><p>By default, the above version of <code>sorted</code> will sort each element in <em>ascending</em> order, but if we’d rather use <em>descending</em> order, then we can combine the closure-based version with the fact that Swift supports <a href=\"https://www.swiftbysundell.com/tips/passing-operators-as-functions\">passing operators as functions</a> — which lets us do this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> numbers: [<span class=\"s-type\">Int</span>] = ...\n<span class=\"s-keyword\">let</span> sortedNumbers = numbers.<span class=\"s-call\">sorted</span>(by: &gt;)</code></pre><p>So the built-in <code>sorted</code> API (and its in-place variant, called <code>sort</code>) are incredibly easy to use when working with <code>Comparable</code> values, and since Swift has such a protocol-oriented design, making our own types conform to <code>Comparable</code> is often the simplest way to enable collections containing such values to be sorted.</p><p>For example, here we’re making a <code>Tag</code> type conform to <code>Comparable</code> using its underlying <code>rawValue</code>, which in turn lets us simply call <code>sorted()</code> on any collection containing <code>Tag</code> values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Tag: <span class=\"s-type\">RawRepresentable</span> {\n    <span class=\"s-keyword\">var</span> rawValue: <span class=\"s-type\">String</span>\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Tag</span>: <span class=\"s-type\">Comparable</span> {\n    <span class=\"s-keyword\">static func</span> &lt;(lhs: <span class=\"s-type\">Tag</span>, rhs: <span class=\"s-type\">Tag</span>) -&gt; <span class=\"s-type\">Bool</span> {\n        lhs.<span class=\"s-property\">rawValue</span> &lt; rhs.<span class=\"s-property\">rawValue</span>\n    }\n}\n\n<span class=\"s-keyword\">let</span> tags = <span class=\"s-call\">loadAllTags</span>()\n<span class=\"s-keyword\">let</span> sortedTags = tags.<span class=\"s-call\">sorted</span>()</code></pre><p>However, although it might be tempting to use the above approach for all types that are involved in any kind of sorting, doing so could give certain types quite odd semantics.</p><p>Take the <code>TodoItem</code> type that we used earlier as an example. Although we <em>could</em> make it conform to <code>Comparable</code> using its <code>date</code> property, that wouldn’t really make any sense outside of the realm of sorting, and what if we wanted to sort some of our <code>TodoItem</code> collections based on a property other than <code>date</code>?</p><h2>Custom sorting using key paths</h2><p>Of course, one way to deal with non-<code>Comparable</code> values would be to simply continue to use the <code>sorted</code> API that requires us to pass a manual closure, but if we’re performing that kind of operation in multiple places across our code base, then always having to write such closures can quickly become both repetitive and quite error prone.</p><p>So let’s also explore how we could extend the built-in suite of sorting APIs with a few conveniences that would enable us to easily sort <em>any</em> collection based on one of its <code>Element</code> type’s properties. One way to do that would be to do what we did in <em><a href=\"https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift\">“The power of key paths in Swift”</a></em>, and extend <code>Sequence</code> with an API that lets us use a <code>KeyPath</code> to sort a given collection — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> {\n    <span class=\"s-keyword\">func</span> sorted&lt;T: <span class=\"s-type\">Comparable</span>&gt;(by keyPath: <span class=\"s-type\">KeyPath</span>&lt;<span class=\"s-type\">Element</span>, <span class=\"s-type\">T</span>&gt;) -&gt; [<span class=\"s-type\">Element</span>] {\n        <span class=\"s-call\">sorted</span> { a, b <span class=\"s-keyword\">in</span>\n            a[keyPath: keyPath] &lt; b[keyPath: keyPath]\n        }\n    }\n}</code></pre><p>With the above in place, we’ll now be able to use Swift’s key path literal syntax to sort our collections based on any <code>Comparable</code> property that our elements contain:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> sortedTags = tags.<span class=\"s-call\">sorted</span>(by: \\.<span class=\"s-property\">rawValue</span>)\n<span class=\"s-keyword\">let</span> sortedTodoItems = todoItems.<span class=\"s-call\">sorted</span>(by: \\.<span class=\"s-property\">date</span>)</code></pre><p>That’s definitely an improvement over our previous, closure-based approach. However, we’re currently assuming that all of our collections should be ordered in ascending order, which might not be the case.</p><p>So, to support other sort orders (including completely custom ones), let’s also add a closure parameter to our new API as well. Thanks to the power of <a href=\"https://www.swiftbysundell.com/articles/default-arguments-in-swift\">default arguments</a>, we can make that change in a way that doesn’t make our previous API any harder to use, since we can use the <code>&lt;</code> operator as our default closure — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> {\n    <span class=\"s-keyword\">func</span> sorted&lt;T: <span class=\"s-type\">Comparable</span>&gt;(\n        by keyPath: <span class=\"s-type\">KeyPath</span>&lt;<span class=\"s-type\">Element</span>, <span class=\"s-type\">T</span>&gt;,\n        using comparator: (<span class=\"s-type\">T</span>, <span class=\"s-type\">T</span>) -&gt; <span class=\"s-type\">Bool</span> = (&lt;)\n    ) -&gt; [<span class=\"s-type\">Element</span>] {\n        <span class=\"s-call\">sorted</span> { a, b <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">comparator</span>(a[keyPath: keyPath], b[keyPath: keyPath])\n        }\n    }\n}</code></pre><p>With the above in place, we’ll now be able to easily sort any collection (such as our <code>todoItems</code> array from before) in descending order by passing the greater-than operator as our <code>comparator</code> — just like we did when using the built-in <code>sorted</code> API:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> mostRecentTodoItems = todoItems.<span class=\"s-call\">sorted</span>(by: \\.<span class=\"s-property\">date</span>, using: &gt;)</code></pre><p>Really nice! Next, let’s take a look at how we could keep extending the above API to also support <em>multiple</em> key paths, instead of just one.</p><h2>Sorting on multiple properties</h2><p>Let’s now say that we wanted to sort an array of articles, first based on the categories that they belong to, and then alphabetically based on their titles. One way to make that happen would be to once again go back to the closure-based version of <code>sorted</code>, and implement something like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> sortArticlesByCategory(<span class=\"s-keyword\">_</span> articles: [<span class=\"s-type\">Article</span>]) -&gt; [<span class=\"s-type\">Article</span>] {\n    articles.<span class=\"s-call\">sorted</span> { articleA, articleB <span class=\"s-keyword\">in\n        guard</span> articleA.<span class=\"s-property\">category</span> == articleB.<span class=\"s-property\">category</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> articleA.<span class=\"s-property\">category</span> &lt; articleB.<span class=\"s-property\">category</span>\n        }\n\n        <span class=\"s-keyword\">return</span> articleA.<span class=\"s-property\">title</span> &lt; articleB.<span class=\"s-property\">title</span>\n    }\n}</code></pre><p>Just like the other examples that we’ve taken a look at so far, if the above method is the only place in which we need to sort a collection based on multiple properties, then there’s no need to change things whatsoever. However, if that’s a pattern that we’re repeating in multiple places, then it might warrant another abstraction.</p><p>This time, let’s take some inspiration from Swift’s predecessor, Objective-C, which ships with a type called <code>NSSortDescriptor</code> that can be used to describe exactly how we want a given collection to be sorted. Although that type <em>can</em> also be used in Swift, it can only be used with Objective-C collections, such as <code>NSArray</code> — which in turn would require us to sacrifice the strong type safety that Swift’s own collections give us.</p><p>Thankfully, creating a “Swift-native” version of it doesn’t have to be that complicated. Let’s start with a struct called <code>SortDescriptor</code>, which is really just a wrapper around a closure that compares two values and returns a <code>ComparisonResult</code> (which is another Objective-C type that we <em>will</em> use directly):</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SortDescriptor&lt;Value&gt; {\n    <span class=\"s-keyword\">var</span> comparator: (<span class=\"s-type\">Value</span>, <span class=\"s-type\">Value</span>) -&gt; <span class=\"s-type\">ComparisonResult</span>\n}</code></pre><p>Then, since we’re still primarily looking to sort our various collections based on key paths, let’s extend our new <code>SortDescriptor</code> type with a static method that’ll let us easily create an instance using a given <code>KeyPath</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">SortDescriptor</span> {\n    <span class=\"s-keyword\">static func</span> keyPath&lt;T: <span class=\"s-type\">Comparable</span>&gt;(<span class=\"s-keyword\">_</span> keyPath: <span class=\"s-type\">KeyPath</span>&lt;<span class=\"s-type\">Value</span>, <span class=\"s-type\">T</span>&gt;) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Self</span> { rootA, rootB <span class=\"s-keyword\">in\n            let</span> valueA = rootA[keyPath: keyPath]\n            <span class=\"s-keyword\">let</span> valueB = rootB[keyPath: keyPath]\n\n            <span class=\"s-keyword\">guard</span> valueA != valueB <span class=\"s-keyword\">else</span> {\n                <span class=\"s-keyword\">return</span> .<span class=\"s-dotAccess\">orderedSame</span>\n            }\n\n            <span class=\"s-keyword\">return</span> valueA &lt; valueB ? .<span class=\"s-dotAccess\">orderedAscending</span> : .<span class=\"s-dotAccess\">orderedDescending</span>\n        }\n    }\n}</code></pre><p>Since we’re now using <code>ComparisonResult</code>, rather than plain <code>Bool</code> values, we’re going to need a new way to describe our desired sort order. One way to do that would be to introduce a simple enum that describes each order that we’re looking to support, for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">enum</span> SortOrder {\n    <span class=\"s-keyword\">case</span> ascending\n    <span class=\"s-keyword\">case</span> descending\n}</code></pre><p>With the above pieces in place, let’s now go ahead and implement our actual sorting algorithm — which will use an array of <code>SortDescriptor</code> values, along with a given <code>SortOrder</code>, to form a closure that we can then pass to the standard library’s <code>sorted</code> method:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> {\n    <span class=\"s-keyword\">func</span> sorted(using descriptors: [<span class=\"s-type\">SortDescriptor</span>&lt;<span class=\"s-type\">Element</span>&gt;],\n                order: <span class=\"s-type\">SortOrder</span>) -&gt; [<span class=\"s-type\">Element</span>] {\n        <span class=\"s-call\">sorted</span> { valueA, valueB <span class=\"s-keyword\">in\n            for</span> descriptor <span class=\"s-keyword\">in</span> descriptors {\n                <span class=\"s-keyword\">let</span> result = descriptor.<span class=\"s-call\">comparator</span>(valueA, valueB)\n\n                <span class=\"s-keyword\">switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">orderedSame</span>:\n                    <span class=\"s-comment\">// Keep iterating if the two elements are equal,\n                    // since that'll let the next descriptor determine\n                    // the sort order:</span>\n                    <span class=\"s-keyword\">break\n                case</span> .<span class=\"s-dotAccess\">orderedAscending</span>:\n                    <span class=\"s-keyword\">return</span> order == .<span class=\"s-dotAccess\">ascending</span>\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">orderedDescending</span>:\n                    <span class=\"s-keyword\">return</span> order == .<span class=\"s-dotAccess\">descending</span>\n                }\n            }\n\n            <span class=\"s-comment\">// If no descriptor was able to determine the sort\n            // order, we'll default to false (similar to when\n            // using the '&lt;' operator with the built-in API):</span>\n            <span class=\"s-keyword\">return false</span>\n        }\n    }\n}</code></pre><p>While the above new method will already give us a very nice and easy way to sort a collection based on multiple <code>Element</code> properties, if we’re primarily going to use <code>ascending</code> as our <code>SortOrder</code>, then we could also add the following convenience API — which will let us pass a list of <code>SortDescriptor</code> values using <a href=\"https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift/#variadic-parameters-and-further-composition\">variadic parameter syntax</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> {\n    <span class=\"s-keyword\">func</span> sorted(using descriptors: <span class=\"s-type\">SortDescriptor</span>&lt;<span class=\"s-type\">Element</span>&gt;...) -&gt; [<span class=\"s-type\">Element</span>] {\n        <span class=\"s-call\">sorted</span>(using: descriptors, order: .<span class=\"s-dotAccess\">ascending</span>)\n    }\n}</code></pre><p class=\"info\">Yes, the above is a convenience API on top of another convenience API. Full-stack convenience, if you will.</p><p>With that, our new multi-property sorting API is now complete, so let’s take it for a spin. Here’s how we could now easily sort our <code>Article</code> array from before, by simply passing a list of the key paths that we want to sort it by:</p><pre class=\"splash\"><code><span class=\"s-keyword\">func</span> sortArticlesByCategory(<span class=\"s-keyword\">_</span> articles: [<span class=\"s-type\">Article</span>]) -&gt; [<span class=\"s-type\">Article</span>] {\n    articles.<span class=\"s-call\">sorted</span>(using: .<span class=\"s-call\">keyPath</span>(\\.<span class=\"s-property\">category</span>), .<span class=\"s-call\">keyPath</span>(\\.<span class=\"s-property\">title</span>))\n}</code></pre><p>Also, since we didn’t hard-code our <code>SortDescriptor</code> type to always use key paths — we can now use it as a powerful, general-purpose sorting API, even when we’d like to use a list of highly custom sorting algorithms.</p><h2>In-place sorting and performance</h2><p>So far, the examples that we’ve taken a look at have all used the system-provided <code>sorted</code> API under the hood, but depending on each use case and the kind of performance characteristics that we’re going for, using the in-place variant of that API might actually be a better option.</p><p>To illustrate, let’s now say that we’re working on a game that includes the following <code>ScoreList</code> type, which ensures that an underlying array of <code>Int</code>-based scores remains sorted, even as new scores are added to it:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ScoreList {\n    <span class=\"s-keyword\">private(set) var</span> scores: [<span class=\"s-type\">Int</span>]\n\n    <span class=\"s-keyword\">init</span>(scores: [<span class=\"s-type\">Int</span>]) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">scores</span> = scores.<span class=\"s-call\">sorted</span>()\n    }\n\n    <span class=\"s-keyword\">mutating func</span> addScore(<span class=\"s-keyword\">_</span> score: <span class=\"s-type\">Int</span>) {\n        scores.<span class=\"s-call\">append</span>(score)\n        scores = scores.<span class=\"s-call\">sorted</span>()\n    }\n}</code></pre><p>Now, let’s compare the above to the following implementation, which uses the <code>sort</code> method to sort our <code>scores</code> array in place, rather than creating a copy of it:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ScoreList {\n    ...\n\n    <span class=\"s-keyword\">mutating func</span> addScore(<span class=\"s-keyword\">_</span> score: <span class=\"s-type\">Int</span>) {\n        scores.<span class=\"s-call\">append</span>(score)\n        scores.<span class=\"s-call\">sort</span>()\n    }\n}</code></pre><p>When running in <code>DEBUG</code> mode, the above two implementations have almost identical performance characteristics — which is to be expected since both <code>sort</code> and <code>sorted</code> have a <a href=\"https://www.swiftbysundell.com/basics/time-complexity\">time complexity</a> of <code>O(n log n)</code>. However, if we instead run our app in <code>RELEASE</code> mode (which should <strong>always</strong> be used when comparing performance), then something interesting happens.</p><p>Not only are both of our implementations about 100 times faster in <code>RELEASE</code> mode (yes, no kidding!), but our in-place, <code>sort</code>-based version is now almost twice as fast compared to the <code>sorted</code>-based approach. That’s because, during release builds, the compiler performs <em>many kinds</em> of optimizations when it comes to collections and value types, which in this case works remarkably well — especially when our collection is mutated in place.</p><h2>Conclusion</h2><p>Swift’s built-in sorting functionality is a great example of how the standard library exposes several advanced, high-performance algorithms as a really simple suite of APIs, especially when working with <code>Comparable</code> values.</p><p>Although those built-in APIs are likely going to be more than enough for many apps, sometimes we might want to augment them by adding a few conveniences — for example in order to support simple, property-based sorting. I hope that you found the examples of doing that interesting, and if you have any questions, comments or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "A look at the various sorting APIs that the Swift standard library offers, and how we could augment those APIs in order to make more advanced sorting tasks easier to perform.",
      "date_published": "2020-11-29T17:55:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/statically-computed-default-property-values",
      "url": "https://www.swiftbysundell.com/tips/statically-computed-default-property-values",
      "title": "Statically computed default property values",
      "content_html": "<p>Establishing a strong set of defaults for a given API can often make it much easier to use, since doing so lets each call site remain as simple as possible, while still enabling customization when needed.</p><p>For example, let’s say that we’re working on a UIKit-based view that uses a <code>DateFormatter</code> to display a given date, and that we’d like it to use the current <code>Date</code> and a specific set of formatting styles by default (while still enabling custom values to be assigned as well). Using default property values, we can make that happen like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> DateView: <span class=\"s-type\">UIView</span> {\n    <span class=\"s-keyword\">var</span> date = <span class=\"s-type\">Date</span>()\n    <span class=\"s-keyword\">var</span> formatter: <span class=\"s-type\">DateFormatter</span> = {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">DateFormatter</span>()\n        formatter.<span class=\"s-property\">dateStyle</span> = .<span class=\"s-dotAccess\">medium</span>\n        formatter.<span class=\"s-property\">timeStyle</span> = .<span class=\"s-dotAccess\">none</span>\n        <span class=\"s-keyword\">return</span> formatter\n    }()\n    \n    ...\n}</code></pre><p>However, given that it takes a few lines of code to create our default <code>DateFormatter</code> instance, we might not want to do that right within our list of property declarations — as that could end up making our code quite hard to read (especially if we start adding more properties that follow the same pattern).</p><p>One way to solve that issue would be to make our <code>formatter</code> property <em>lazy</em>, and to then define a private factory method that creates its default value. That would let our property declarations remain “clutter-free” — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> DateView: <span class=\"s-type\">UIView</span> {\n    <span class=\"s-keyword\">var</span> date = <span class=\"s-type\">Date</span>()\n    <span class=\"s-keyword\">lazy var</span> formatter = <span class=\"s-call\">makeFormatter</span>()\n    \n    ...\n}\n\n<span class=\"s-keyword\">private extension</span> <span class=\"s-type\">DateView</span> {\n    <span class=\"s-keyword\">func</span> makeFormatter() -&gt; <span class=\"s-type\">DateFormatter</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">DateFormatter</span>()\n        formatter.<span class=\"s-property\">dateStyle</span> = .<span class=\"s-dotAccess\">medium</span>\n        formatter.<span class=\"s-property\">timeStyle</span> = .<span class=\"s-dotAccess\">none</span>\n        <span class=\"s-keyword\">return</span> formatter\n    }\n}</code></pre><p>However, while the above technique works really well for classes, what if we were using a struct instead? For example, if the above <code>DateView</code> was a SwiftUI view, rather than a <code>UIView</code> subclass, then using a lazy property wouldn’t work, since accessing such a property performs a mutation — meaning that we wouldn’t be able to use our <code>formatter</code> within our view’s <code>body</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DateView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> date = <span class=\"s-type\">Date</span>()\n    <span class=\"s-keyword\">lazy var</span> formatter = <span class=\"s-call\">makeFormatter</span>()\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-comment\">// Error: Cannot use mutating getter on immutable\n            // value: 'self' is immutable</span>\n            <span class=\"s-type\">Text</span>(formatter.<span class=\"s-call\">string</span>(from: date))\n            ...\n        }\n    }\n}\n\n<span class=\"s-keyword\">private extension</span> <span class=\"s-type\">DateView</span> {\n    <span class=\"s-keyword\">func</span> makeFormatter() -&gt; <span class=\"s-type\">DateFormatter</span> {\n        ...\n    }\n}</code></pre><p class=\"info\">The reason we get the above compiler error when our view is implemented as a struct is because structs have value semantics. To learn more about that, check out the Basics article <a href=\"https://www.swiftbysundell.com/basics/value-and-reference-types\">“Value and Reference Types”</a>.</p><p>At this point, it might seem like we either need to go back to the inline closure-based computation that we originally used (since that doesn’t require our property to be lazy), or to use something like a singleton. But it turns out that there is <em>another way</em>, and that’s to use a private static method to compute our property’s default value — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DateView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> date = <span class=\"s-type\">Date</span>()\n    <span class=\"s-keyword\">var</span> formatter = <span class=\"s-call\">makeFormatter</span>()\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        ...\n    }\n}\n\n<span class=\"s-keyword\">private extension</span> <span class=\"s-type\">DateView</span> {\n    <span class=\"s-keyword\">static</span> <span class=\"s-keyword\">func</span> makeFormatter() -&gt; <span class=\"s-type\">DateFormatter</span> {\n        ...\n    }\n}</code></pre><p>The fact that we can use any static API (even private ones) to compute a property’s default value also gives us the opportunity to use a single, statically shared <code>DateFormatter</code> for <em>all</em> of our <code>DateView</code> instances — which in this case could improve the performance of our UI, since we’d no longer recreate a new date formatter every time that our view was updated:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> DateView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> date = <span class=\"s-type\">Date</span>()\n    <span class=\"s-keyword\">var</span> formatter = defaultFormatter\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        ...\n    }\n}\n\n<span class=\"s-keyword\">private extension</span> <span class=\"s-type\">DateView</span> {\n    <span class=\"s-keyword\">static</span> <span class=\"s-keyword\">let</span> defaultFormatter: <span class=\"s-type\">DateFormatter</span> = {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">DateFormatter</span>()\n        formatter.<span class=\"s-property\">dateStyle</span> = .<span class=\"s-dotAccess\">medium</span>\n        formatter.<span class=\"s-property\">timeStyle</span> = .<span class=\"s-dotAccess\">none</span>\n        <span class=\"s-keyword\">return</span> formatter\n    }()\n}</code></pre><p>So an important difference between a lazy property and a non-lazy one is that when computing a lazy property’s default value, we’re within <em>that instance’s own context</em>, while when computing the default value for a non-lazy property we’re in a <em>static context</em>.</p><p>Of course, whether we should share a single static instance or create multiple ones will vary depending on each situation. My general recommendation is to only share instances that are either immutable, or shared privately within a single type, as to not introduce global mutable state.</p>",
      "date_published": "2020-11-25T12:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/instabug-november-2020",
      "url": "https://www.swiftbysundell.com/sponsor/instabug-november-2020",
      "title": "Sponsor: Instabug",
      "content_html": "<p>My thanks to <a href=\"https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q420-nov-9&utm_content=spon\">Instabug</a> for sponsoring Swift by Sundell for the past two weeks. Their continued support plays a big part in keeping the website, and the podcast, up and running.</p><p>Instabug is not only my favorite crash reporter for iOS apps (I’ve used it in several projects, and it has always been fantastic!), it also includes a wide range of other features that can help you keep track of your app’s overall quality.</p><p>For example, two of their recently added features are <em>Application Performance Monitoring</em> and the <em>Apdex score</em>. The former automatically provides you with concrete performance metrics around things like app launch times, UI responsiveness, and networking speed, while the latter gives you a single, unified score that you can use to measure and improve your app’s performance over time.</p><p>Using both of those two features, and everything else that Instabug has to offer, makes it so much easier to identify regressions, to fix bugs and errors, and to constantly iterate on an app’s quality and performance.</p><p>Check out Instabug today by going to <a href=\"https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q420-nov-9&utm_content=spon\">try.instabug.com/swiftbysundell</a>. When using that URL, you also directly help support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to Instabug for sponsoring Swift by Sundell.",
      "date_published": "2020-11-23T10:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/extending-combine-with-convenience-apis",
      "url": "https://www.swiftbysundell.com/articles/extending-combine-with-convenience-apis",
      "title": "Extending Combine with convenience APIs",
      "content_html": "<p>Apple’s Combine framework enables us to model our asynchronous code as reactive pipelines that each consist of a series of separate operations. Those pipelines can then be observed, transformed, and <em>combined</em> in various ways — and since Combine makes heavy use of Swift’s advanced generics capabilities, that can all be done with a high degree of type safety and compile time validation.</p><p>That strong type information can also be incredibly useful when extending Combine with convenience APIs, as it lets us create custom transforms and utilities that are tailored-made for specific kinds of output. This week, let’s take a look at a few ways to do just that, and how doing so can help us eliminate common sources of boilerplate when implementing things like networking and data validation.</p><h2>Inserting default arguments</h2><p>Although Combine ships with a quite comprehensive suite of built-in transforms (typically referred to as <em>“operators”</em>), sometimes we might want to create custom variants of those APIs that are tailored to the way they’re being used within a given app. Doing so typically involves extending Combine’s <code>Publisher</code> protocol, and by using that protocol’s <code>Output</code> and <code>Failure</code> types, we can then choose exactly what kinds of publishers that we want to add our new APIs to.</p><p>For example, the standard <code>decode</code> operator can be used to transform a publisher that emits <code>Data</code> values into one that publishes instances of a <code>Decodable</code> Swift type. However, that operator requires us to always manually pass which type that we’re looking to decode, as well as the decoder that we wish to use — which makes perfect sense given that the built-in operators aim to be as general-purpose as possible — but within our own code base, we could instead create a custom version of that operator that automatically inserts default values for those two arguments, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Output</span> == <span class=\"s-type\">Data</span> {\n    <span class=\"s-keyword\">func</span> decode&lt;T: <span class=\"s-type\">Decodable</span>&gt;(\n        as type: <span class=\"s-type\">T</span>.<span class=\"s-type\">Type</span> = <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>,\n        using decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>()\n    ) -&gt; <span class=\"s-type\">Publishers</span>.<span class=\"s-type\">Decode</span>&lt;<span class=\"s-type\">Self</span>, <span class=\"s-type\">T</span>, <span class=\"s-type\">JSONDecoder</span>&gt; {\n        <span class=\"s-call\">decode</span>(type: type, decoder: decoder)\n    }\n}</code></pre><p class=\"info\">Note how we’re returning an instance of <code>Publishers.Decode</code> from the above convenience API, rather than using the type-erased <code>AnyPublisher</code> type, which isn’t needed in this case since we have a known, concrete type that can be returned as-is.</p><p>Another option would be to replace the above call to <code>.init()</code> with any statically shared <code>JSONDecoder</code> instance that we’re using across our app. For example, if the web APIs that we’re downloading JSON from all use <code>snake_case</code>-based keys, then we might instead want to use the following <code>snakeCaseConverting</code> instance as our default <code>decoder</code> argument:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">JSONDecoder</span> {\n    <span class=\"s-keyword\">static let</span> snakeCaseConverting: <span class=\"s-type\">JSONDecoder</span> = {\n        <span class=\"s-keyword\">let</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n        decoder.<span class=\"s-property\">keyDecodingStrategy</span> = .<span class=\"s-dotAccess\">convertFromSnakeCase</span>\n        <span class=\"s-keyword\">return</span> decoder\n    }()\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Output</span> == <span class=\"s-type\">Data</span> {\n    <span class=\"s-keyword\">func</span> decode&lt;T: <span class=\"s-type\">Decodable</span>&gt;(\n        as type: <span class=\"s-type\">T</span>.<span class=\"s-type\">Type</span> = <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>,\n        using decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-property\">snakeCaseConverting</span>\n    ) -&gt; <span class=\"s-type\">Publishers</span>.<span class=\"s-type\">Decode</span>&lt;<span class=\"s-type\">Self</span>, <span class=\"s-type\">T</span>, <span class=\"s-type\">JSONDecoder</span>&gt; {\n        <span class=\"s-call\">decode</span>(type: type, decoder: decoder)\n    }\n}</code></pre><p>With either of the above two extensions in place, we can now simply use <code>.decode()</code> to decode JSON data whenever the compiler is able to infer our desired output type, for example in situations like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ConfigModelController: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> config: <span class=\"s-type\">Config</span>\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n    \n    ...\n\n    <span class=\"s-keyword\">func</span> update() {\n        <span class=\"s-comment\">// Here the compiler is able to infer which type that we’re\n        // looking to decode our JSON into, based on the property\n        // that we’re assigning our pipeline’s output to:</span>\n        urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">config</span>)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>()\n            .<span class=\"s-call\">replaceError</span>(with: .<span class=\"s-dotAccess\">default</span>)\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$config</span>)\n    }\n}</code></pre><p>Our custom <code>decode</code> operator is also really useful when we <em>do</em> have to manually specify our desired output type, as we can now simply do so like this:</p><pre class=\"splash\"><code>cancellable = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">allItems</span>)\n    .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n    .<span class=\"s-call\">decode</span>(as: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>)\n    .<span class=\"s-call\">sink</span> { completion <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle completion</span>\n        ...\n    } receiveValue: { response <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle response</span>\n        ...\n    }</code></pre><p>To take things even further, we could also create abstractions that’d let us avoid having to manually map each <code>URLSession</code> publisher to <code>Data</code>, and to always unpack the contents of the resulting <code>NetworkResponse</code> type — just like we did in <a href=\"https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift\">“Creating generic networking APIs in Swift”</a>.</p><h2>Data validation</h2><p>Next, let’s take a look at how we can also extend Combine with dedicated APIs for performing data validation. As an example, let’s say that we wanted to verify that each <code>NetworkResponse</code> instance loaded within the previous example contains at least one <code>Item</code>. To make that happen, we could add the following API, which uses the <code>tryMap</code> operator to enable us to use <a href=\"https://www.swiftbysundell.com/articles/using-errors-as-control-flow-in-swift\">errors as control flow</a> when validating a given publisher’s <code>Output</code> values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> validate(\n        using validator: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Output</span>) <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">Void</span>\n    ) -&gt; <span class=\"s-type\">Publishers</span>.<span class=\"s-type\">TryMap</span>&lt;<span class=\"s-type\">Self</span>, <span class=\"s-type\">Output</span>&gt; {\n        <span class=\"s-call\">tryMap</span> { output <span class=\"s-keyword\">in\n            try</span> <span class=\"s-call\">validator</span>(output)\n            <span class=\"s-keyword\">return</span> output\n        }\n    }\n}</code></pre><p>We could then simply insert a call to the above <code>validate</code> operator within our previous Combine pipeline, and throw an error in case our <code>items</code> array turned out to be empty — like this:</p><pre class=\"splash\"><code>cancellable = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">allItems</span>)\n    .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n    .<span class=\"s-call\">decode</span>(as: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>)\n    .<span class=\"s-call\">validate</span> { response <span class=\"s-keyword\">in\n        guard</span> !response.<span class=\"s-property\">items</span>.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">throw</span> <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-type\">Error</span>.<span class=\"s-property\">missingItems</span>\n        }\n    }\n    .<span class=\"s-call\">sink</span> { completion <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle completion</span>\n        ...\n    } receiveValue: { response <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle response</span>\n        ...\n    }</code></pre><p>Another very common way to validate data in Swift is by unwrapping optionals, and although Combine’s built-in <code>compactMap</code> operator does exactly that, using that operator makes a given pipeline <em>ignore</em> all <code>nil</code> values, rather than throwing an error if a required value turned out to be missing. So if we instead <em>want</em> errors to be thrown in those situations, then we could once again make that happen by building a custom operator using <code>tryMap</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> unwrap&lt;T&gt;(\n        orThrow error: <span class=\"s-keyword\">@escaping @autoclosure</span> () -&gt; <span class=\"s-type\">Failure</span>\n    ) -&gt; <span class=\"s-type\">Publishers</span>.<span class=\"s-type\">TryMap</span>&lt;<span class=\"s-type\">Self</span>, <span class=\"s-type\">T</span>&gt; <span class=\"s-keyword\">where</span> <span class=\"s-type\">Output</span> == <span class=\"s-type\">Optional</span>&lt;<span class=\"s-type\">T</span>&gt; {\n        <span class=\"s-call\">tryMap</span> { output <span class=\"s-keyword\">in\n            switch</span> output {\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">some</span>(<span class=\"s-keyword\">let</span> value):\n                <span class=\"s-keyword\">return</span> value\n            <span class=\"s-keyword\">case nil</span>:\n                <span class=\"s-keyword\">throw</span> <span class=\"s-call\">error</span>()\n            }\n        }\n    }\n}</code></pre><p class=\"info\">Above we’re using the <code>@autoclosure</code> attribute to automatically convert each <code>error</code> argument into a closure, which in turn prevents those expressions from being evaluated unless they’re actually needed. This pattern is also used within the standard library to implement things like asserts. To learn more, check out <a href=\"https://www.swiftbysundell.com/articles/under-the-hood-of-assertions-in-swift\">“Under the hood of assertions in Swift”</a>.</p><p>To take a look at what our new <code>unwrap</code> operator looks like in action, let’s say that we’re loading another collection of <code>Item</code> values from a <code>recentItems</code> endpoint, only this time we’re only interested in the first element — which we can now easily unwrap like this:</p><pre class=\"splash\"><code>cancellable = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">recentItems</span>)\n    .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n    .<span class=\"s-call\">decode</span>(as: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>)\n    .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">items</span>.<span class=\"s-property\">first</span>)\n    .<span class=\"s-call\">unwrap</span>(orThrow: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-type\">Error</span>.<span class=\"s-property\">missingItems</span>)\n    .<span class=\"s-call\">sink</span> { completion <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle completion</span>\n        ...\n    } receiveValue: { response <span class=\"s-keyword\">in</span>\n        <span class=\"s-comment\">// Handle response</span>\n        ...\n    }</code></pre><p>Really nice! One thing that’s important to point out, though, is that a Combine pipeline is always completed when an error is encountered (unless that error is caught using operators like <code>catch</code> or <code>replaceError</code>), meaning that we should only use the above two data validation operators when that’s the kind of behavior that we’re looking for.</p><h2>Result conversions</h2><p>One of the most common ways to handle the output of a given Combine pipeline is by using the <code>sink</code> operator along with two closures — one for handling each output value, and one for handling completion events.</p><p>However, handling successful output values and completions (such as errors) separately can sometimes be a bit inconvenient, and in those kinds of situations, emitting a single <a href=\"https://www.swiftbysundell.com/basics/result\"><code>Result</code></a> value could be a great alternative — so let’s also introduce a custom operator for performing that kind of conversion:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> convertToResult() -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Output</span>, <span class=\"s-type\">Failure</span>&gt;, <span class=\"s-type\">Never</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-call\">map</span>(<span class=\"s-type\">Result</span>.<span class=\"s-property\">success</span>)\n            .<span class=\"s-call\">catch</span> { <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failure</span>($0)) }\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Our new <code>convertToResult</code> operator could become especially useful when using Combine to build <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift\">view models</a> for SwiftUI views. For example, here we’ve now moved our previous item loading pipeline into an <code>ItemListViewModel</code>, which uses our new operator to be able to easily <code>switch</code> on the <code>Result</code> of each loading operation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ItemListViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> items = [<span class=\"s-type\">Item</span>]()\n    <span class=\"s-keyword\">@Published private(set) var</span> error: <span class=\"s-type\">Error</span>?\n\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    ...\n\n    <span class=\"s-keyword\">func</span> load() {\n        cancellable = urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">allItems</span>)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(as: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>)\n            .<span class=\"s-call\">validate</span> { response <span class=\"s-keyword\">in\n                guard</span> !response.<span class=\"s-property\">items</span>.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n                    <span class=\"s-keyword\">throw</span> <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-type\">Error</span>.<span class=\"s-property\">missingItems</span>\n                }\n            }\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">items</span>)\n            .<span class=\"s-call\">convertToResult</span>()\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n                switch</span> result {\n                <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> items):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">items</span> = items\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">error</span> = <span class=\"s-keyword\">nil\n                case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">items</span> = []\n                    <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">error</span> = error\n                }\n            }\n    }\n}</code></pre><p>To take things further, if we update the above view model to instead use the <code>LoadableObject</code> protocol and <code>LoadingState</code> enum from <em><a href=\"https://www.swiftbysundell.com/articles/handling-loading-states-in-swiftui\">“Handling loading states within SwiftUI views”</a></em>, then we could make the above implementation much simpler. Let’s start by also adding a conversion operator that emits <code>LoadingState</code> values, rather than using the built-in <code>Result</code> type:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> convertToLoadingState() -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">LoadingState</span>&lt;<span class=\"s-type\">Output</span>&gt;, <span class=\"s-type\">Never</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-call\">map</span>(<span class=\"s-type\">LoadingState</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failed</span>($0)) }\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>With the above extension in place, we could then simply load and assign our view model’s state like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ItemListViewModel: <span class=\"s-type\">LoadableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> state = <span class=\"s-type\">LoadingState</span>&lt;[<span class=\"s-type\">Item</span>]&gt;.idle\n    \n    ...\n    \n    <span class=\"s-keyword\">func</span> load() {\n    \t<span class=\"s-keyword\">guard</span> !state.<span class=\"s-property\">isLoading</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span>\n    \t}\n    \n    \tstate = .<span class=\"s-dotAccess\">loading</span>\n    \n        urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">allItems</span>)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(as: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>)\n            .<span class=\"s-call\">validate</span> { response <span class=\"s-keyword\">in\n                guard</span> !response.<span class=\"s-property\">items</span>.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n                    <span class=\"s-keyword\">throw</span> <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-type\">Error</span>.<span class=\"s-property\">missingItems</span>\n                }\n            }\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">items</span>)\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">convertToLoadingState</span>()\n            .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$state</span>)\n    }\n}</code></pre><p>Although it might be easy to dismiss the above changes as being just “syntactic sugar”, reducing the amount of code needed to perform our most common types of operations can often result in a substantial boost in productivity, and can also help us avoid repeating bugs and mistakes by utilizing shared, fully tested implementations.</p><h2>Type-erased constant publishers</h2><p>Like we took a look at in <em>“<a href=\"https://www.swiftbysundell.com/tips/constant-combine-publishers\">Publishing constant values using Combine</a>”</em>, sometimes we might want to create publishers that emit just a single value or error, which can be done using either <code>Just</code> or <code>Fail</code>. However, when using those publishers, we also typically have to normalize them using operators like <code>setFailureType</code> and <code>eraseToAnyPublisher</code> — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> SearchResultsLoader {\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n    <span class=\"s-keyword\">private let</span> cache: <span class=\"s-type\">Cache</span>&lt;<span class=\"s-type\">String</span>, [<span class=\"s-type\">Item</span>]&gt;\n    \n    ...\n\n    <span class=\"s-keyword\">func</span> searchForItems(\n        matching query: <span class=\"s-type\">String</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">SearchError</span>&gt; {\n        <span class=\"s-keyword\">guard</span> !query.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Fail</span>(error: <span class=\"s-type\">SearchError</span>.<span class=\"s-property\">emptyQuery</span>)\n                .<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        <span class=\"s-keyword\">if let</span> cachedItems = cache.<span class=\"s-call\">value</span>(forKey: query) {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Just</span>(cachedItems)\n                .<span class=\"s-call\">setFailureType</span>(to: <span class=\"s-type\">SearchError</span>.<span class=\"s-keyword\">self</span>)\n                .<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        <span class=\"s-keyword\">return</span> urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-call\">search</span>(for: query))\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(as: <span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>)\n            .<span class=\"s-call\">mapError</span>(<span class=\"s-type\">SearchError</span>.<span class=\"s-property\">requestFailed</span>)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">items</span>)\n            .<span class=\"s-call\">handleEvents</span>(receiveOutput: { [cache] items <span class=\"s-keyword\">in</span>\n                cache.<span class=\"s-call\">insert</span>(items, forKey: query)\n            })\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Again, our current implementation doesn’t have any <em>huge</em> problems, but if we’re using the above kind of pattern in multiple places throughout our app, then implementing a set of convenience APIs for it could definitely be worthwhile.</p><p>This time, let’s extend the <code>AnyPublisher</code> type with two <em>static</em> methods — one for creating type-erased <code>Just</code> publishers, and one for creating <code>Fail</code> publishers:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">AnyPublisher</span> {\n    <span class=\"s-keyword\">static func</span> just(<span class=\"s-keyword\">_</span> output: <span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Just</span>(output)\n            .<span class=\"s-call\">setFailureType</span>(to: <span class=\"s-type\">Failure</span>.<span class=\"s-keyword\">self</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n    \n    <span class=\"s-keyword\">static func</span> fail(with error: <span class=\"s-type\">Failure</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Fail</span>(error: error).<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>With the above two methods in place, we’ll now be able to use Swift’s “dot syntax” to create constant publishers with just a single line of code — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> SearchResultsLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> searchForItems(\n        matching query: <span class=\"s-type\">String</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Item</span>], <span class=\"s-type\">SearchError</span>&gt; {\n        <span class=\"s-keyword\">guard</span> !query.<span class=\"s-property\">isEmpty</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> .<span class=\"s-call\">fail</span>(with: <span class=\"s-type\">SearchError</span>.<span class=\"s-property\">emptyQuery</span>)\n        }\n\n        <span class=\"s-keyword\">if let</span> cachedItems = cache.<span class=\"s-call\">value</span>(forKey: query) {\n            <span class=\"s-keyword\">return</span> .<span class=\"s-call\">just</span>(cachedItems)\n        }\n\n        ...\n    }\n}</code></pre><p>Not only is the above code much more compact than our previous implementation, our return statements can now actually be read as proper English sentences — “Fail with search error: empty query” and “Return just cached items” — which is most often a good sign when it comes to readability.</p><h2>Conclusion</h2><p>Even though generic APIs can often be quite complicated, the fact that they contain such rich type information gives us a lot of opportunities to extend them with very specific convenience APIs — that can then utilize that type information to actually <em>reduce</em> the amount of complexity and verbosity needed to perform common tasks.</p><p>Of course, we should always aim to strike a nice balance between the amount of convenience APIs that we have to maintain, and the value that we’re getting from them. My personal approach is to follow <a href=\"https://www.swiftbysundell.com/articles/structuring-swift-code/#the-rule-of-threes\">“The rule of threes”</a>, and only create an abstraction when I’ve encountered three call sites that require the same kind of boilerplate.</p><p>What do you think? Would any of the above extensions be useful within your code base? Let me know — along with any questions, comments or feedback that you might have — either via <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "How custom Combine operators and convenience APIs can be implemented using extensions, and how doing so can let us eliminate common sources of boilerplate when implementing things like networking and data validation.",
      "date_published": "2020-11-22T16:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/86",
      "url": "https://www.swiftbysundell.com/podcast/86",
      "title": "Podcast: “Map is a design pattern”, with special guest Daniel Steinberg",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell86.mp3\" type=\"audio/mpeg\"/></audio><p>Daniel Steinberg joins John to discuss how various functional programming patterns can be adopted in Swift, and how many of those patterns can be found in both the standard library and in frameworks like Combine and SwiftUI.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a>.</li><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to learn more about Instabug’s new App Performance Monitoring feature, and to start your free trial.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/dimsumthinking\">Daniel on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://editorscut.com\">Daniel’s books on Swift, SwiftUI and functional programming</a></li><li><a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">Function builders</a></li><li><a href=\"https://www.swiftbysundell.com/tips/a-first-look-at-swiftui-stateobject\">@StateObject</a></li><li><a href=\"https://reactjs.org\">React</a></li><li><a href=\"https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40004514-CH1-SW1\">The Core Animation programming guide</a></li><li><a href=\"https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap\">Map, flatMap and compactMap</a></li><li><a href=\"https://vimeo.com/269275064\">One of Daniel’s talks about map and functional programming</a></li><li><a href=\"https://en.wikipedia.org/wiki/Design_Patterns\">The Gang of Four book on design patterns</a></li><li><a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a></li><li><a href=\"https://www.swiftbysundell.com/basics/result\">The Result type</a></li><li><a href=\"https://github.com/apple/swift/blob/main/stdlib/public/core/Sequence.swift\">The implementation of the map function</a></li><li><a href=\"https://www.swiftbysundell.com/articles/first-class-functions-in-swift\">First class functions</a></li><li><a href=\"https://www.swiftbysundell.com/tips/passing-key-paths-as-functions\">Passing key paths as functions</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/85\">The previous episode with James Thomson</a></li><li><a href=\"https://www.swiftbysundell.com/articles/delegation-in-swift/\">The delegate pattern</a></li><li><a href=\"https://github.com/JohnSundell/Ink\">Ink</a></li><li><a href=\"https://github.com/JohnSundell/Publish\">Publish</a></li><li><a href=\"https://www.swiftbysundell.com/articles/managing-dependencies-using-the-swift-package-manager\">Managing dependencies using the Swift Package Manager</a></li><li><a href=\"https://dimsumthinking.com\">dimsumthinking.com</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Daniel Steinberg joins John to discuss how various functional programming patterns can be adopted in Swift, and how many of those patterns can be found in both the standard library and in frameworks like Combine and SwiftUI.",
      "date_published": "2020-11-19T20:20:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-2",
      "url": "https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-2",
      "title": "SwiftUI and UIKit interoperability - Part 2",
      "content_html": "<p>Last week, we took a closer look at how UIKit views can be imported into the declarative world of SwiftUI, which both gives us an opportunity to reuse existing <code>UIView</code>-based components, and also acts as an important “escape hatch” for when SwiftUI does not yet support a given use case.</p><p>But SwiftUI’s interoperability with UIKit goes the complete opposite direction as well, since we’re also able to embed SwiftUI views within UIKit-based view controllers — and that’s exactly what we’ll take a look at this week.</p><p class=\"info\">If you haven’t read <a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\">part one of this article</a>, then I recommend doing that before proceeding with this one.</p><h2>Hosting a SwiftUI view within a view controller</h2><p>Continuing with the event app-based examples from <a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\">part one</a>, let’s say that the screen that our app is using to display a single event is currently implemented as a <code>UIViewController</code>, which uses a <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift\">view model</a> to keep track of its current state, and it then asks that view model to update itself within <code>viewWillAppear</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> viewModel: <span class=\"s-type\">EventViewModel</span>\n    <span class=\"s-keyword\">private lazy var</span> descriptionLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private lazy var</span> tagListView = <span class=\"s-type\">EventTagListView</span>()\n\n    <span class=\"s-keyword\">init</span>(viewModel: <span class=\"s-type\">EventViewModel</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">viewModel</span> = viewModel\n        <span class=\"s-keyword\">super</span>.<span class=\"s-keyword\">init</span>(nibName: <span class=\"s-keyword\">nil</span>, bundle: <span class=\"s-keyword\">nil</span>)\n        viewModel.<span class=\"s-property\">delegate</span> = <span class=\"s-keyword\">self</span>\n    }\n\n    ...\n\n    <span class=\"s-keyword\">override func</span> viewDidLoad() {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewDidLoad</span>()\n        \n        view.<span class=\"s-call\">addSubview</span>(descriptionLabel)\n        view.<span class=\"s-call\">addSubview</span>(tagListView)\n        \n        <span class=\"s-comment\">// Add layout constraints and perform other kinds of setup</span>\n        ...\n    }\n\n    <span class=\"s-keyword\">override func</span> viewWillAppear(<span class=\"s-keyword\">_</span> animated: <span class=\"s-type\">Bool</span>) {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewWillAppear</span>(animated)\n        viewModel.<span class=\"s-call\">update</span>()\n    }\n    \n    ...\n}</code></pre><p>As part of the above implementation, we’re assigning our view controller as its view model’s <a href=\"https://www.swiftbysundell.com/articles/delegation-in-swift/\"><code>delegate</code></a>, which in turn requires us to conform to an <code>EventViewModelDelegate</code> protocol that’s used to handle events like when the view model was updated, or when an error was encountered:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">EventViewController</span>: <span class=\"s-type\">EventViewModelDelegate</span> {\n    <span class=\"s-keyword\">func</span> eventViewModelDidUpdate(<span class=\"s-keyword\">_</span> viewModel: <span class=\"s-type\">EventViewModel</span>) {\n        <span class=\"s-comment\">// Updating our views according to our view model's\n        // current state:</span>\n        descriptionLabel.<span class=\"s-property\">text</span> = viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">description</span>\n        tagListView.<span class=\"s-property\">tags</span> = viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">tags</span>\n    }\n\n    <span class=\"s-keyword\">func</span> eventViewModelDidEncounterError(<span class=\"s-keyword\">_</span> viewModel: <span class=\"s-type\">EventViewModel</span>,\n                                         error: <span class=\"s-type\">Error</span>) {\n        <span class=\"s-comment\">// Show a description of the error and a retry button</span>\n        ...\n    }\n}</code></pre><p>The patterns used above all work really great within the world of UIKit, but what if we now wanted to add a SwiftUI view to the mix?</p><p>For example, let’s say that we’ve been wanting to add a header view to our <code>EventViewController</code>, and since that’s going to be a new stand-alone view, then that’s an excellent opportunity for us to use SwiftUI. Here’s what an initial implementation of such a header view could look like:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventHeaderView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> event: <span class=\"s-type\">Event</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            <span class=\"s-type\">EventGradient</span>().<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">top</span>)\n            <span class=\"s-type\">VStack</span> {\n                <span class=\"s-type\">Image</span>(systemName: event.<span class=\"s-property\">icon</span>.<span class=\"s-property\">imageName</span>)\n                <span class=\"s-type\">Text</span>(event.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                    .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n            }\n        }\n    }\n}</code></pre><p>But now the question is — how will we integrate the above <code>EventHeaderView</code> into our existing view controller? At the most basic level, all that we actually have to do is to wrap our new SwiftUI view within a <code>UIHostingController</code>, which will automatically bridge the gap between SwiftUI and UIKit in terms of rendering:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> viewModel: <span class=\"s-type\">EventViewModel</span>\n    <span class=\"s-keyword\">private lazy var</span> header = <span class=\"s-call\">makeHeader</span>()\n    <span class=\"s-keyword\">private lazy var</span> descriptionLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private lazy var</span> tagListView = <span class=\"s-type\">EventTagListView</span>()\n    \n    ...\n    \n    <span class=\"s-keyword\">private func</span> makeHeader() -&gt; <span class=\"s-type\">UIHostingController</span>&lt;<span class=\"s-type\">EventHeaderView</span>&gt; {\n        <span class=\"s-keyword\">let</span> headerView = <span class=\"s-type\">EventHeaderView</span>(event: viewModel.<span class=\"s-property\">event</span>)\n        <span class=\"s-keyword\">let</span> headerVC = <span class=\"s-type\">UIHostingController</span>(rootView: headerView)\n        headerVC.<span class=\"s-property\">view</span>.<span class=\"s-property\">translatesAutoresizingMaskIntoConstraints</span> = <span class=\"s-keyword\">false\n        return</span> headerVC\n    }\n}</code></pre><p>To then actually display our header view, we’ll first need to add its wrapping <code>UIHostingController</code> to our <code>EventViewController</code> as a child, and we’ll then apply a series of <a href=\"https://www.swiftbysundell.com/basics/layout-anchors\">layout constraints</a> to that wrapping view controller’s <code>view</code> in order to give it our desired layout:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewController: <span class=\"s-type\">UIViewController</span> {\n    ...\n\n    <span class=\"s-keyword\">override func</span> viewDidLoad() {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewDidLoad</span>()\n\n        <span class=\"s-comment\">// Add our header view controller as a child:</span>\n        <span class=\"s-call\">addChild</span>(header)\n        view.<span class=\"s-call\">addSubview</span>(header.<span class=\"s-property\">view</span>)\n        header.<span class=\"s-call\">didMove</span>(toParent: <span class=\"s-keyword\">self</span>)\n        \n        <span class=\"s-comment\">// Apply a series of Auto Layout constraints to its view:</span>\n        <span class=\"s-type\">NSLayoutConstraint</span>.<span class=\"s-call\">activate</span>([\n            header.<span class=\"s-property\">view</span>.<span class=\"s-property\">topAnchor</span>.<span class=\"s-call\">constraint</span>(equalTo: view.<span class=\"s-property\">topAnchor</span>),\n            header.<span class=\"s-property\">view</span>.<span class=\"s-property\">leadingAnchor</span>.<span class=\"s-call\">constraint</span>(equalTo: view.<span class=\"s-property\">leadingAnchor</span>),\n            header.<span class=\"s-property\">view</span>.<span class=\"s-property\">widthAnchor</span>.<span class=\"s-call\">constraint</span>(equalTo: view.<span class=\"s-property\">widthAnchor</span>),\n            header.<span class=\"s-property\">view</span>.<span class=\"s-property\">heightAnchor</span>.<span class=\"s-call\">constraint</span>(\n                equalTo: view.<span class=\"s-property\">heightAnchor</span>,\n                multiplier: <span class=\"s-number\">0.25</span>\n            )\n        ])\n\n        ...\n    }\n\n    ...\n}</code></pre><p class=\"info\">To avoid having to repeat the three method calls required to add a view controller as a child, we can extend <code>UIViewController</code> with a convenience API, just like we did in <a href=\"https://www.swiftbysundell.com/articles/using-child-view-controllers-as-plugins-in-swift\">“Using child view controllers as plugins in Swift”</a>, which would let us simply call <code>add(header)</code> when adding our header’s <code>UIHostingController</code>.</p><p>That’s a great start, and the above implementation will work just fine as long as our SwiftUI view isn’t expected to be updated during our view controller’s lifecycle. In this case, however, we do want our <code>EventHeaderView</code> to be updated whenever our view model’s <code>event</code> was changed, which can be accomplished in a few different ways.</p><p>Perhaps the simplest way would be to just assign a new header view to our <code>UIHostingController</code> whenever our <code>eventViewModelDidUpdate</code> delegate method was called — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">EventViewController</span>: <span class=\"s-type\">EventViewModelDelegate</span> {\n    <span class=\"s-keyword\">func</span> eventViewModelDidUpdate(<span class=\"s-keyword\">_</span> viewModel: <span class=\"s-type\">EventViewModel</span>) {\n        <span class=\"s-keyword\">let</span> event = viewModel.<span class=\"s-property\">event</span>\n\n        header.<span class=\"s-property\">rootView</span> = <span class=\"s-type\">EventHeaderView</span>(event: event)\n\n        descriptionLabel.<span class=\"s-property\">text</span> = event.<span class=\"s-property\">description</span>\n        tagListView.<span class=\"s-property\">tags</span> = event.<span class=\"s-property\">tags</span>\n    }\n    \n    ...\n}</code></pre><p>At first glance, the above might look awfully inefficient, since we’re essentially recreating our view on every state change. But then we have to remember that SwiftUI views are not concrete representations of the actual pixels that are being rendered on-screen, but are rather lightweight <em>descriptions</em> of our desired UI, and that SwiftUI will automatically reuse its underlying views and layers as much as possible.</p><p>So, at least for simpler use cases, the above might work perfectly fine, as long as the SwiftUI view that we’re wrapping doesn’t contain any state of its own, since that state would be lost when we manually swap out instances like we do above.</p><h2>Updating an embedded SwiftUI view</h2><p>Another option would be to let our <code>EventHeaderView</code> observe our view model’s state on its own, which would further make it more of a stand-alone component, and would also enable it to <em>modify</em> that state as well.</p><p>To make that happen, let’s start by turning our <code>EventViewModel</code> into an <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-objects\"><code>ObservableObject</code></a>, which was also how we enabled state to be shared between embedded UIKit-based views and their SwiftUI wrappers in <a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1\">part one</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published</span> <span class=\"s-keyword\">private(set) var</span> event: <span class=\"s-type\">Event</span>\n    <span class=\"s-keyword\">weak var</span> delegate: <span class=\"s-type\">EventViewModelDelegate</span>?\n    ...\n}</code></pre><p>With the above change in place, our <code>EventHeaderView</code> can now observe our view model directly using <code>@ObservedObject</code>, and it will be automatically updated every time that the view model’s <code>event</code> property was changed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventHeaderView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">EventViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            <span class=\"s-type\">EventGradient</span>().<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">top</span>)\n            <span class=\"s-type\">VStack</span> {\n                <span class=\"s-type\">Image</span>(systemName: viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">icon</span>.<span class=\"s-property\">imageName</span>)\n                <span class=\"s-type\">Text</span>(viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                    .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n            }\n        }\n    }\n}</code></pre><p>Finally, we’ll inject our view controller’s <code>viewModel</code> into our SwiftUI view when creating it, which lets us do that just once, rather than every time that our state was changed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewController {\n    ...\n\n    <span class=\"s-keyword\">private func</span> makeHeader() -&gt; <span class=\"s-type\">UIHostingController</span>&lt;<span class=\"s-type\">EventHeaderView</span>&gt; {\n        <span class=\"s-keyword\">let</span> headerView = <span class=\"s-type\">EventHeaderView</span>(viewModel: viewModel)\n        <span class=\"s-keyword\">let</span> headerVC = <span class=\"s-type\">UIHostingController</span>(rootView: headerView)\n        headerVC.<span class=\"s-property\">view</span>.<span class=\"s-property\">translatesAutoresizingMaskIntoConstraints</span> = <span class=\"s-keyword\">false\n        return</span> headerVC\n    }\n}</code></pre><p>The beauty of the above approach is that our UIKit-based code can keep using the delegate pattern, or any other pattern that perfectly matches the overall design of UIKit itself, while our SwiftUI-based code is free to make full use of <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a> and SwiftUI’s declarative <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">state management system</a>.</p><h2>Two-way data bindings</h2><p>So far, our data has only been flowing in a single direction — from our <code>EventViewModel</code> to our view controller and its hosted <code>EventHeaderView</code>. But let’s also take a look at how we can set up <em>two-way bindings</em> between an embedded SwiftUI view and its hosting view controller.</p><p>For example, let’s say that we wanted to enable our users to change the name of a given event directly using our <code>EventHeaderView</code>. One way to make that happen would be by giving our view model a dedicated method for performing that mutation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> event: <span class=\"s-type\">Event</span>\n    <span class=\"s-keyword\">weak var</span> delegate: <span class=\"s-type\">EventViewModelDelegate</span>?\n\n    ...\n\n    <span class=\"s-keyword\">func</span> updateName(to newName: <span class=\"s-type\">String</span>) {\n        event.<span class=\"s-property\">name</span> = newName\n        delegate?.<span class=\"s-call\">eventViewModelDidUpdate</span>(<span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p>We could then replace our header view’s previously static title with a completely dynamic <code>TextField</code>. However, since that control uses a <code>Binding</code> reference to propagate state changes, we’d also need a way to forward those changes to our view model’s <code>updateName</code> method — which could be done using a manually constructed <code>Binding</code>, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventHeaderView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">EventViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            <span class=\"s-type\">EventGradient</span>().<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">top</span>)\n            <span class=\"s-type\">VStack</span> {\n                <span class=\"s-type\">Image</span>(systemName: viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">icon</span>.<span class=\"s-property\">imageName</span>)\n                <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Event name\"</span>, text: nameBinding)\n                    .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                    .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    .<span class=\"s-call\">multilineTextAlignment</span>(.<span class=\"s-dotAccess\">center</span>)\n            }\n        }\n    }\n\n    <span class=\"s-keyword\">private var</span> nameBinding: <span class=\"s-type\">Binding</span>&lt;<span class=\"s-type\">String</span>&gt; {\n        <span class=\"s-type\">Binding</span>(\n            get: { viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">name</span> },\n            set: { viewModel.<span class=\"s-call\">updateName</span>(to: $0) }\n        )\n    }\n}</code></pre><p>The benefit of the above approach is that our SwiftUI-based state conversions can take place entirely within our SwiftUI views themselves, which in turn lets us keep our UIKit-based code free of any such complexity.</p><p>However, always having to manually create <code>Binding</code> instances can get a bit tedious, so let’s also explore a second approach, which involves making our view model’s <code>event</code> property writable, instead of being read-only. When doing that, we also need to make sure that we’re always propagating any external changes to that property, which could be done using a <code>didSet</code> <a href=\"https://www.swiftbysundell.com/articles/property-observers-in-swift\">property observer</a> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published var</span> event: <span class=\"s-type\">Event</span> {\n        <span class=\"s-keyword\">didSet</span> { delegate?.<span class=\"s-call\">eventViewModelDidUpdate</span>(<span class=\"s-keyword\">self</span>) }\n    }\n    <span class=\"s-keyword\">weak var</span> delegate: <span class=\"s-type\">EventViewModelDelegate</span>?\n    ...\n}</code></pre><p>With the above change in place, we can now bind our header view’s <code>TextField</code> <em>directly</em> to our view model’s <code>event</code> property, which lets us get rid of the manually constructed <code>Binding</code> that we were using before:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventHeaderView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">EventViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ZStack</span> {\n            <span class=\"s-type\">EventGradient</span>().<span class=\"s-call\">edgesIgnoringSafeArea</span>(.<span class=\"s-dotAccess\">top</span>)\n            <span class=\"s-type\">VStack</span> {\n                <span class=\"s-type\">Image</span>(systemName: viewModel.<span class=\"s-property\">event</span>.<span class=\"s-property\">icon</span>.<span class=\"s-property\">imageName</span>)\n                <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Event name\"</span>, text: <span class=\"s-property\">$viewModel</span>.<span class=\"s-property\">event</span>.<span class=\"s-property\">name</span>)\n                    .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n                    .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    .<span class=\"s-call\">multilineTextAlignment</span>(.<span class=\"s-dotAccess\">center</span>)\n            }\n        }\n    }\n}</code></pre><p>Which of the above two approaches that we’ll end up going for is likely going to depend on the situation at hand, as well as our own personal preferences. The main question is whether we want to make changes to our existing UIKit-based code in order to accommodate our new SwiftUI-based components, or whether we’d prefer to encapsulate that complexity within our SwiftUI views themselves.</p><h2>Embracing reactive rendering</h2><p>Finally, let’s also take a look at how the changes that we’ve made so far can give us an interesting opportunity to tweak the way we handle state within our UIKit-based code as well.</p><p>Since our <code>EventViewModel</code> now publishes all changes to its <code>event</code> property, we could also make our <code>EventViewController</code> observe that property directly, rather than using the delegate pattern. All that we have to do to make that happen is to use <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a> to <code>sink</code> that property into an observing closure — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> viewModel: <span class=\"s-type\">EventViewModel</span>\n    <span class=\"s-keyword\">private lazy var</span> header = <span class=\"s-call\">makeHeader</span>()\n    <span class=\"s-keyword\">private lazy var</span> descriptionLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">private lazy var</span> tagListView = <span class=\"s-type\">EventTagListView</span>()\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    ...\n\n    <span class=\"s-keyword\">override func</span> viewDidLoad() {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewDidLoad</span>()\n\n        cancellable = viewModel.<span class=\"s-property\">$event</span>.<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] event <span class=\"s-keyword\">in\n            self</span>?.<span class=\"s-call\">updateViews</span>(with: event)\n        }\n        \n        ...\n    }\n    \n    ...\n    \n    <span class=\"s-keyword\">private func</span> updateViews(with event: <span class=\"s-type\">Event</span>) {\n        descriptionLabel.<span class=\"s-property\">text</span> = event.<span class=\"s-property\">description</span>\n        tagListView.<span class=\"s-property\">tags</span> = event.<span class=\"s-property\">tags</span>\n    }\n} </code></pre><p>One benefit of the above approach, besides the consistency aspects, is that it enables us to setup much more granular observations within our views and view controllers — since we can now choose which properties that we wish to observe, rather than relying on a single delegate method for all types of changes.</p><p>Of course, that doesn’t mean that we should immediately replace all uses of the delegate pattern with Combine and <code>@Published</code>-marked properties, but the above technique is definitely worth keeping in mind when gradually migrating an existing code base to Apple’s latest tools and frameworks.</p><h2>Conclusion</h2><p>Even though SwiftUI and UIKit are indeed very different — both in terms of their overall API design, and how state changes are propagated when using them — there are still multiple ways that we can connect and integrate them.</p><p>I hope that this two-part article has given you a few tips and ideas on how to do just that, and that some of these techniques will enable you to keep making great use of any existing UIKit-based code that you have, even as you keep adventuring into the exciting world of SwiftUI.</p><p>Like always, you’re more than welcome to reach out if you have questions, comments or feedback. You can contact me <a href=\"https://twitter.com/johnsundell\">through Twitter</a>, or <a href=\"https://www.swiftbysundell.com/contact\">send me an email</a>, whichever you prefer.</p><p>Thanks for reading! 🚀</p>",
      "summary": "In this second article about integrating SwiftUI and UIKit, we’ll take a look at how SwiftUI views can be embedded within UIKit-based view controllers, and various ways of sharing state between them.",
      "date_published": "2020-11-15T18:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/creating-custom-swiftui-container-views",
      "url": "https://www.swiftbysundell.com/tips/creating-custom-swiftui-container-views",
      "title": "Creating custom SwiftUI container views",
      "content_html": "<p>Although SwiftUI ships with a quite large number of built-in container views, such as <code>VStack</code>, <code>HStack</code> and <code>List</code>, sometimes we might also want to define our <em>own</em> custom containers as well.</p><p>For example, let’s say that we’re working on an app that features a <em>carousel-like</em> component, which lets our users scroll through a horizontal list of items. That component is currently implemented like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Carousel&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> content: () -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span>(.<span class=\"s-dotAccess\">horizontal</span>) {\n            <span class=\"s-type\">HStack</span>(content: content).<span class=\"s-call\">padding</span>()\n        }\n    }\n}</code></pre><p>That’s a good start, but our current implementation does have a quite major limitation compared to SwiftUI’s built-in containers — we’re currently only able to pass a single <code>Content</code> view to it.</p><p>That might work fine as long as we’re using something like <code>ForEach</code> (as that’d give us a single return value within our carousel’s <code>content</code> closure), but if we tried to do the following, then we’d get a compiler error:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> OnboardingCarousel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Carousel</span> {\n            <span class=\"s-type\">WelcomeCard</span>()\n            <span class=\"s-type\">GettingStartedCard</span>()\n            <span class=\"s-type\">ExploreCard</span>()\n        }\n    }\n}</code></pre><p>That’s a bit of a shame, since the above approach would be a very natural way of declaring a <code>Carousel</code> instance, as it exactly mimics the way that built-in containers like <code>HStack</code> and <code>VStack</code> are used.</p><p>Although we <em>could</em> address the above problem by wrapping all of our subviews within a <code>Group</code> (which would again give us a single return value within our closure), having to do that at every call site would be quite inconvenient. Thankfully, though, there’s a better way — and that’s to annotate our <code>content</code> closure with SwiftUI’s <code>ViewBuilder</code> attribute, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Carousel&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> content: () -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">init</span>(<span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Content</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">content</span> = content\n    }\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span>(.<span class=\"s-dotAccess\">horizontal</span>) {\n            <span class=\"s-type\">HStack</span>(content: content).<span class=\"s-call\">padding</span>()\n        }\n    }\n}</code></pre><p>Adding the <code>ViewBuilder</code> attribute to a closure makes it possible to use the full power of <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api\">SwiftUI’s DSL</a> within it, meaning that we’ll now be able to define our <code>OnboardingCarousel</code> exactly the way that we originally intended — really nice!</p><p>However, if our code base includes multiple kinds of container views, then always having to repeat the above initializer declaration can become a bit repetitive, especially since the required syntax is quite complex.</p><p>So let’s see if we can improve things with a little bit of protocol-oriented programming. If we assume that each of our container views is going to use the same pattern as the above <code>Carousel</code> view (in that it has a generic <code>Content</code> type, and accepts a <code>content</code> closure), then we could model those capabilities using the following protocol:</p><pre class=\"splash\"><code><span class=\"s-keyword\">protocol</span> ContainerView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">associatedtype</span> Content\n    <span class=\"s-keyword\">init</span>(content: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Content</span>)\n}</code></pre><p class=\"info\">We make our new protocol extend SwiftUI’s <code>View</code> protocol to inherit all of its requirements. To learn more about that technique, check out <a href=\"https://www.swiftbysundell.com/articles/specializing-protocols-in-swift\">“Specializing protocols in Swift”</a>.</p><p>Next, let’s extend our new <code>ContainerView</code> protocol with a convenience initializer that adds the <code>ViewBuilder</code> attribute that we previously had to add manually — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ContainerView</span> {\n    <span class=\"s-keyword\">init</span>(<span class=\"s-keyword\">@ViewBuilder _</span> content: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Content</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(content: content)\n    }\n}</code></pre><p class=\"info\">Note how we add an underscore in front of our convenience initializer’s parameter label. That’s to avoid ending up in an infinite loop in case a conforming type doesn’t actually declare our required initializer, since now those two initializers will have different signatures.</p><p>If we now make all of our custom container views conform to <code>ContainerView</code>, rather than using <code>View</code> directly, then we’ll simply be able to declare our <code>content</code> closure like we originally did, while still gaining full <code>ViewBuilder</code> capabilities as well:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Carousel&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">ContainerView</span> {\n    <span class=\"s-keyword\">var</span> content: () -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span>(.<span class=\"s-dotAccess\">horizontal</span>) {\n            <span class=\"s-type\">HStack</span>(content: content).<span class=\"s-call\">padding</span>()\n        }\n    }\n}</code></pre><p>Our <code>OnboardingCarousel</code> now works exactly like it did before, only now we’ve made it much easier to define both <code>Carousel</code> and any other container views that we might want to build either now or in the future.</p><p>Worth noting, though, is that this particular implementation only supports container views that don’t accept any additional parameters, although we could always add support for that if that’s something that we’ll end up needing.</p>",
      "date_published": "2020-11-12T16:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1",
      "url": "https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-1",
      "title": "SwiftUI and UIKit interoperability - Part 1",
      "content_html": "<p>One of SwiftUI’s major strengths is just how well it integrates with both UIKit and AppKit. Not only does that act as a useful “escape hatch” for whenever a given use case is not yet natively supported by SwiftUI itself, it also enables us to incrementally migrate an existing UIKit or AppKit-based project to Apple’s new UI framework, all while reusing many of our core UI components.</p><p>While several aspects of this topic have already been covered on <a href=\"https://www.swiftbysundell.com/discover/swiftui/#interoperability-with-uikit-and-appkit\">this site before</a>, this week and the week after, let’s dive much deeper into how SwiftUI and UIKit can be combined in various ways — starting with how we can bring increasingly complex UIKit-based views and view controllers into the declarative world of SwiftUI.</p><p class=\"info\">Although all of the examples within this article will be UIKit-based, the same tools and techniques can also be used with AppKit as well. All SwiftUI-provided protocols and methods that we’ll use are identical between iOS and macOS in this case, with the only difference being that the macOS ones use <code>NS</code> instead of <code>UI</code> within their names.</p><h2>Reusing existing components</h2><p>Although it might be tempting to start out fresh when migrating a given project to SwiftUI, and rewrite the entire app from the ground up, that’s often not a wise decision, as doing so means throwing away working, battle-tested production code just because it happens to be implemented using a somewhat older UI framework.</p><p>Instead, let’s explore how we can <em>reuse</em> existing UI components, all while making them fit in perfectly alongside our new, SwiftUI-based views. As an example, let’s say that we’re working on an iOS app for managing various events, which includes the following <code>EventDetailsView</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventDetailsView: <span class=\"s-type\">UIView</span> {\n    <span class=\"s-keyword\">let</span> imageView = <span class=\"s-type\">UIImageView</span>()\n    <span class=\"s-keyword\">let</span> nameLabel = <span class=\"s-type\">UILabel</span>()\n    <span class=\"s-keyword\">let</span> descriptionLabel = <span class=\"s-type\">UILabel</span>()\n    ...\n}</code></pre><p>The above view follows the common UIKit pattern of letting views remain simple UI containers, while making their enclosing view controllers responsible for populating them with data. However, since there are no view controllers in SwiftUI, we’ll have to take a slightly different approach within that context — by using the <code>UIViewRepresentable</code> protocol.</p><p>That protocol (and its <code>NSViewRepresentable</code> equivalent on the Mac) lets us implement bridging types that each wrap a <code>UIView</code> instance in order to make it SwiftUI-compatible. For non-interactive views, such as our <code>EventDetailsView</code>, creating such a wrapper involves implementing two methods — one for creating our view, and one for updating it:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventDetailsComponent: <span class=\"s-type\">UIViewRepresentable</span> {\n    <span class=\"s-keyword\">var</span> event: <span class=\"s-type\">Event</span>\n\n    <span class=\"s-keyword\">func</span> makeUIView(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">EventDetailsView</span> {\n        <span class=\"s-type\">EventDetailsView</span>()\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIView(<span class=\"s-keyword\">_</span> view: <span class=\"s-type\">EventDetailsView</span>, context: <span class=\"s-type\">Context</span>) {\n        view.<span class=\"s-property\">imageView</span>.<span class=\"s-property\">image</span> = <span class=\"s-type\">UIImage</span>(named: event.<span class=\"s-property\">icon</span>.<span class=\"s-property\">imageName</span>)\n        view.<span class=\"s-property\">nameLabel</span>.<span class=\"s-property\">text</span> = event.<span class=\"s-property\">name</span>\n        view.<span class=\"s-property\">descriptionLabel</span>.<span class=\"s-property\">text</span> = event.<span class=\"s-property\">description</span>\n    }\n}</code></pre><p class=\"info\">Note how we named the above wrapper <code>EventDetailsComponent</code>, since <code>EventDetailsView</code> is already taken, and since the purpose of our wrapper is to turn our existing UIKit-based view into a custom SwiftUI component.</p><p>Since all SwiftUI <code>View</code> types are simply <em>descriptions</em> of views, rather than concrete representations of them, we should ideally not make any assumptions about what kind of lifecycle that each of our wrappers will have. Instead, we should always <em>lazily create</em> each underlying <code>UIView</code> in our wrapper’s <code>makeUIView</code> method, and then update it according to the current state in <code>updateUIView</code>.</p><p>That’s particularly important since SwiftUI will reuse our underlying <code>UIView</code> instances as much as possible, even when their wrapping <code>UIViewRepresentable</code> values are recreated — meaning that any properties that we assign in <code>makeUIView</code> won’t be continuously updated as our state changes.</p><p>However, sometimes we might want to persist some form of state within our wrappers themselves, which SwiftUI also provides a dedicated API for. To explore that, let’s now say that we also wanted to bring in a custom <code>UIButton</code> subclass into SwiftUI as well:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventSchedulingButton: <span class=\"s-type\">UIButton</span> {\n    ...\n}</code></pre><p>Since the above control is a <code>UIButton</code> subclass, we’re using UIKit’s built-in target/action pattern to handle its events, which in turn means that we’re going to need some form of object to act as our button’s target.</p><p>While an initial idea might be to simply make our button’s <code>UIViewRepresentable</code> wrapper a class and then have it take on that target role, that’s not going to work very well given that our wrappers can be destroyed and recreated at any point (even if they’re classes). Instead, let’s give our new <code>EventSchedulingButton</code> wrapper a <code>Coordinator</code> by implementing the optional <code>makeCoordinator</code> method — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventSchedulingComponent: <span class=\"s-type\">UIViewRepresentable</span> {\n    <span class=\"s-comment\">// Although our component will keep using target/action\n    // internally, we'll make our SwiftUI-facing API closure-\n    // based, since that's a much better fit within that context:</span>\n    <span class=\"s-keyword\">var</span> handler: () -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">func</span> makeCoordinator() -&gt; <span class=\"s-type\">Coordinator</span> {\n        <span class=\"s-type\">Coordinator</span>()\n    }\n\n    <span class=\"s-keyword\">func</span> makeUIView(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">UIView</span> {\n        <span class=\"s-keyword\">let</span> button = <span class=\"s-type\">EventSchedulingButton</span>()\n\n        button.<span class=\"s-call\">addTarget</span>(context.<span class=\"s-property\">coordinator</span>,\n            action: <span class=\"s-keyword\">#selector</span>(<span class=\"s-type\">Coordinator</span>.<span class=\"s-property\">callHandler</span>),\n            for: .<span class=\"s-dotAccess\">touchUpInside</span>\n        )\n\n        <span class=\"s-keyword\">return</span> button\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIView(<span class=\"s-keyword\">_</span> uiView: <span class=\"s-type\">UIViewType</span>, context: <span class=\"s-type\">Context</span>) {\n        context.<span class=\"s-property\">coordinator</span>.<span class=\"s-property\">handler</span> = handler\n    }\n}</code></pre><p>A SwiftUI <code>Coordinator</code> always has a one-to-one relationship to a given <code>UIView</code> instance, meaning that we can use it to persist state even if our <code>UIViewRepresentable</code> struct ends up getting recreated.</p><p>The good news is that SwiftUI will automatically manage all of the complexity involved in doing that on our behalf — the only thing that we need to do (apart from implementing the above <code>makeCoordinator</code> method) is to define our <code>Coordinator</code> type itself:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">EventSchedulingComponent</span> {\n    <span class=\"s-keyword\">class</span> Coordinator {\n        <span class=\"s-keyword\">var</span> handler: (() -&gt; <span class=\"s-type\">Void</span>)?\n\n        <span class=\"s-keyword\">@objc func</span> callHandler() {\n            handler?()\n        }\n    }\n}</code></pre><p>The beauty of the above approach is that it lets us make full use of our existing UIKit-based components — without even making any modifications to them — while also enabling us to implement dedicated, SwiftUI-friendly APIs for the new views that our components will be embedded in.</p><p>If we now add the two wrappers that we’ve created so far to an actual SwiftUI view, it’s actually quite hard to tell that those wrappers are not “SwiftUI-native” views (which is definitely a good design goal to have):</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventInvitationView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> event: <span class=\"s-type\">Event</span>\n    ...\n    \n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"Invitation\"</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n            <span class=\"s-type\">EventDetailsComponent</span>(event: event)\n            <span class=\"s-type\">EventSchedulingComponent</span> { ... }\n        }\n    }\n}</code></pre><h2>Importing view controllers into SwiftUI</h2><p>Both of the UIKit-based views that we’ve been importing so far have been stand-alone, lower-level components, but we can also bring entire view controllers into SwiftUI as well.</p><p>For example, let’s say that we wanted to reuse the following <code>EventListViewController</code>, which uses an injected <code>EventListLoader</code> to load a list of <code>Event</code> models that it then renders using a <code>UITableView</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventListViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">EventListLoader</span>\n    <span class=\"s-keyword\">private lazy var</span> tableView = <span class=\"s-type\">UITableView</span>()\n    ...\n\n    <span class=\"s-keyword\">init</span>(loader: <span class=\"s-type\">EventListLoader</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">loader</span> = loader\n        <span class=\"s-keyword\">super</span>.<span class=\"s-keyword\">init</span>(nibName: <span class=\"s-keyword\">nil</span>, bundle: <span class=\"s-keyword\">nil</span>)\n    }\n    \n    ...\n\n    <span class=\"s-keyword\">override func</span> viewWillAppear(<span class=\"s-keyword\">_</span> animated: <span class=\"s-type\">Bool</span>) {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewWillAppear</span>(animated)\n\n        <span class=\"s-call\">showActivityIndicator</span>()\n\n        loader.<span class=\"s-call\">loadEvents</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n            switch</span> result {\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> events):\n                <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">eventsDidLoad</span>(events)\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">showError</span>(error)\n            }\n        }\n    }\n    \n    ...\n}</code></pre><p>Given that the above view controller manages its own lifecycle — from loading its models, to rendering them, to handling user input and displaying errors — we’re going to need to use a somewhat different approach to integrate it into one of our SwiftUI views.</p><p>To get started, let’s use SwiftUI’s <code>UIViewControllerRepresentable</code> protocol to implement another wrapper, only this time we’ll simply create an instance of our view controller using a given <code>EventListLoader</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventList: <span class=\"s-type\">UIViewControllerRepresentable</span> {\n    <span class=\"s-keyword\">var</span> loader: <span class=\"s-type\">EventListLoader</span>\n\n    <span class=\"s-keyword\">func</span> makeUIViewController(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">EventListViewController</span> {\n        <span class=\"s-type\">EventListViewController</span>(loader: loader)\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIViewController(<span class=\"s-keyword\">_</span> viewController: <span class=\"s-type\">EventListViewController</span>,\n                                context: <span class=\"s-type\">Context</span>) {\n        <span class=\"s-comment\">// Nothing to do here, since our view controller is\n        // read-only from the outside.</span>\n    }\n}</code></pre><p>The above approach might be completely fine if our list is going to be rendered in isolation (for example by being the <code>destination</code> of a <code>NavigationLink</code>, or when presented using the <code>sheet</code> modifier). However, if we also wanted one of our SwiftUI views to use the same underlying state as our view controller does, then we’d currently need to load that state twice, which would be quite wasteful.</p><p>One way to address that problem would be to make our <code>EventListLoader</code> an <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-objects\"><code>ObservableObject</code></a>, which would let us observe its state directly from within a SwiftUI view, without requiring us to change our view controller in any way. Here’s how we could make that happen by exposing our loader’s last result as an <code>@Published</code>-marked property:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventListLoader: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">typealias</span> Result = <span class=\"s-type\">Swift</span>.<span class=\"s-type\">Result</span>&lt;[<span class=\"s-type\">Event</span>], <span class=\"s-type\">Error</span>&gt;\n    <span class=\"s-keyword\">typealias</span> Handler = (<span class=\"s-type\">Result</span>) -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">@Published private(set) var</span> result: <span class=\"s-type\">Result</span>?\n    <span class=\"s-keyword\">private let</span> networking: <span class=\"s-type\">Networking</span>\n\n    <span class=\"s-keyword\">init</span>(networking: <span class=\"s-type\">Networking</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">networking</span> = networking\n    }\n\n    <span class=\"s-keyword\">func</span> loadEvents(then handler: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Handler</span>) {\n        <span class=\"s-comment\">// Here we wrap the handler that was passed in, in order\n        // to ensure that we'll always update our result property:</span>\n        <span class=\"s-keyword\">let</span> handler: <span class=\"s-type\">Handler</span> = { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n            self</span>?.<span class=\"s-property\">result</span> = result\n            <span class=\"s-call\">handler</span>(result)\n        }\n\n        networking.<span class=\"s-call\">request</span>(.<span class=\"s-dotAccess\">eventList</span>) { result <span class=\"s-keyword\">in\n            do</span> {\n                <span class=\"s-keyword\">let</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n                <span class=\"s-keyword\">let</span> data = <span class=\"s-keyword\">try</span> result.<span class=\"s-call\">get</span>()\n                <span class=\"s-keyword\">let</span> events = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">decode</span>([<span class=\"s-type\">Event</span>].<span class=\"s-keyword\">self</span>, from: data)\n                <span class=\"s-call\">handler</span>(.<span class=\"s-call\">success</span>(events))\n            } <span class=\"s-keyword\">catch</span> {\n                <span class=\"s-call\">handler</span>(.<span class=\"s-call\">failure</span>(error))\n            }\n        }\n    }\n}</code></pre><p>With the above in place, we can now easily connect any SwiftUI view to an <code>EventListLoader</code> instance — for example in order to render a dashboard that displays the user’s next upcoming event on top of our view controller-based <code>EventList</code> view. Since our underlying view controller will manage the actual loading of our models, we simply have to annotate the property that’s storing our <code>EventListLoader</code> with <code>@ObservedObject</code>, and our dashboard will be automatically updated as soon as the user’s events have been loaded:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventDashboard: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> eventListLoader: <span class=\"s-type\">EventListLoader</span>\n\n    <span class=\"s-keyword\">private var</span> nextEvent: <span class=\"s-type\">Event</span>? {\n        <span class=\"s-keyword\">try</span>? eventListLoader.<span class=\"s-property\">result</span>?.<span class=\"s-call\">get</span>().<span class=\"s-property\">first</span>\n    }\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>) {\n            <span class=\"s-keyword\">if let</span> event = nextEvent {\n                <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>) {\n                    <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"Your next event:\"</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">headline</span>)\n                    <span class=\"s-type\">NextEventView</span>(event: event)\n                }\n                .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>)\n            }\n\n            <span class=\"s-type\">EventList</span>(loader: eventListLoader)\n        }\n    }\n}</code></pre><p>However, while the above is certainly very convenient, it could also be considered somewhat of a hack. After all, we’re currently making a very strong assumption that our <code>EventList</code> and its underlying view controller will actually start loading our data, meaning that our <code>EventDashboard</code> ends up having an implicit data dependency on one of its child views, which isn’t ideal.</p><p>While we could of course always call our loader’s <code>loadEvents</code> method directly within our <code>EventDashboard</code> view as well, doing so would both cause two separate network requests to be performed (which we’ve been trying to avoid), and would be somewhat awkward in this case — given that we’d simply discard the result that was passed into that method’s required completion handler.</p><p>Instead, let’s introduce a new type that’ll be responsible for synchronizing our state between the SwiftUI-based <code>EventDashboard</code> and the UIKit-based <code>EventListViewController</code>. Since that new type will be all about storing a collection of <code>Event</code> models, let’s call it <code>EventStore</code>. We’ll once again use the <code>ObservableObject</code> protocol to make it connectable to a SwiftUI view, while also enabling a UIKit-friendly completion handler to be optionally attached when loading its events:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventStore: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> events = [<span class=\"s-type\">Event</span>]()\n    <span class=\"s-keyword\">@Published private(set) var</span> error: <span class=\"s-type\">Error</span>?\n\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">EventListLoader</span>\n    <span class=\"s-keyword\">private var</span> isLoading = <span class=\"s-keyword\">false\n    private var</span> pendingHandlers = [<span class=\"s-type\">EventListLoader</span>.<span class=\"s-type\">Handler</span>]()\n\n    <span class=\"s-keyword\">init</span>(loader: <span class=\"s-type\">EventListLoader</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">loader</span> = loader\n    }\n\n    <span class=\"s-keyword\">func</span> loadEvents(then handler: <span class=\"s-type\">EventListLoader</span>.<span class=\"s-type\">Handler</span>? = <span class=\"s-keyword\">nil</span>) {\n        <span class=\"s-keyword\">if let</span> handler = handler {\n            pendingHandlers.<span class=\"s-call\">append</span>(handler)\n        }\n\n        <span class=\"s-comment\">// This time, we only start loading if a loading operation\n        // isn't already in progress, meaning that this method\n        // can be called multiple times without causing duplicate\n        // network requests to be performed:</span>\n        <span class=\"s-keyword\">if</span> !isLoading {\n            isLoading = <span class=\"s-keyword\">true</span>\n\n            loader.<span class=\"s-call\">loadEvents</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n                self</span>?.<span class=\"s-call\">didFinishLoading</span>(withResult: result)\n            }\n        }\n    }\n}</code></pre><p>Note how we store each <code>handler</code> that was passed into the above <code>loadEvents</code> method in an array, rather than attaching those closures directly to each loading operation. That way we’re able to call all pending handlers at once when our <code>didFinishLoading</code> method is called — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">EventStore</span> {\n    <span class=\"s-keyword\">func</span> didFinishLoading(withResult result: <span class=\"s-type\">EventListLoader</span>.<span class=\"s-type\">Result</span>) {\n        isLoading = <span class=\"s-keyword\">false\n\n        switch</span> result {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> loadedEvents):\n            events = loadedEvents\n            error = <span class=\"s-keyword\">nil\n        case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> encounteredError):\n            error = encounteredError\n        }\n\n        <span class=\"s-keyword\">let</span> handlers = pendingHandlers\n        pendingHandlers.<span class=\"s-call\">removeAll</span>()\n        handlers.<span class=\"s-call\">forEach</span> { $0(result) }\n    }\n}</code></pre><p class=\"info\">We deliberately keep our <code>events</code> array intact even when an error was encountered, to avoid erasing existing view data if the user went offline, or if a given network request failed for another reason.</p><p>With the above in place, we can now go back to our <code>EventDashboard</code> and make it use our new <code>EventStore</code> type, rather than calling <code>EventListLoader</code> directly. We’ll also make it call <code>loadEvents</code> when it appears (which can safely be called multiple times), which makes it completely self-sufficient in terms of its data:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> EventDashboard: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> store: <span class=\"s-type\">EventStore</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>) {\n            <span class=\"s-keyword\">if let</span> event = store.<span class=\"s-property\">events</span>.<span class=\"s-property\">first</span> {\n                <span class=\"s-type\">VStack</span>(alignment: .<span class=\"s-dotAccess\">leading</span>) {\n                    <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"Your next event:\"</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">headline</span>)\n                    <span class=\"s-type\">NextEventView</span>(event: event)\n                }\n                .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>)\n            }\n\n            <span class=\"s-type\">EventList</span>(store: store)\n        }\n        .<span class=\"s-call\">onAppear</span> { store.<span class=\"s-call\">loadEvents</span>() }\n    }\n}</code></pre><p>Much better! However, this approach does also require us to make a few small changes to <code>EventListViewController</code> (and its <code>EventList</code> wrapper type) as well. Thankfully, those changes are really minor, and basically just involves changing all calls to <code>EventListLoader</code> to instead use our new <code>EventStore</code> type, for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EventListViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> store: <span class=\"s-type\">EventStore</span>\n    <span class=\"s-keyword\">private lazy var</span> tableView = <span class=\"s-type\">UITableView</span>()\n    ...\n\n    <span class=\"s-keyword\">init</span>(store: <span class=\"s-type\">EventStore</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">store</span> = store\n        <span class=\"s-keyword\">super</span>.<span class=\"s-keyword\">init</span>(nibName: <span class=\"s-keyword\">nil</span>, bundle: <span class=\"s-keyword\">nil</span>)\n    }\n    \n    ...\n\n    <span class=\"s-keyword\">override func</span> viewWillAppear(<span class=\"s-keyword\">_</span> animated: <span class=\"s-type\">Bool</span>) {\n        <span class=\"s-keyword\">super</span>.<span class=\"s-call\">viewWillAppear</span>(animated)\n\n        <span class=\"s-call\">showActivityIndicator</span>()\n\n        store.<span class=\"s-call\">loadEvents</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n            switch</span> result {\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> events):\n                <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">eventsDidLoad</span>(events)\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                <span class=\"s-keyword\">self</span>?.<span class=\"s-call\">showError</span>(error)\n            }\n        }\n    }\n    \n    ...\n}</code></pre><p class=\"info\">With the above changes in place, we can now revert our <code>EventListLoader</code> back to being a simple stateless loader that can remain completely focused on just loading our list of events.</p><p>Another approach (or perhaps next logical step in our overall migration process) would be to instead make the above view controller also use the <code>@Published</code>-marked properties that our <code>EventStore</code> provides, rather than relying on a separate, completion-handler based API. That’s something that we’ll explore in great detail next week, when we’ll take a look at the other side of the coin — how to bring SwiftUI-based views into UIKit-based view controllers.</p><h2>Conclusion</h2><p>SwiftUI’s strong interoperability with both UIKit and AppKit often gives us quite a lot of flexibility when it comes to adopting it. However, while using protocols like <code>UIViewRepresentable</code> might be relatively simple at the most basic level, sharing mutable state and complex interactions between UIKit-based views and ones built using SwiftUI can often be quite complicated, and might require us to build various bridging layers between those two worlds.</p><p>I hope that this article has given you some tips and inspiration on how to approach importing UIKit-based components into SwiftUI. In <a href=\"https://www.swiftbysundell.com/articles/swiftui-and-uikit-interoperability-part-2\">part two</a>, we’ll go the opposite direction, by taking a look at how SwiftUI views can be imported into view controllers.</p><p>Got questions, comments, or feedback? Feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "A closer look at how SwiftUI and UIKit can be combined in various ways, starting with how we can bring increasingly complex UIKit-based views and view controllers into the declarative world of SwiftUI.",
      "date_published": "2020-11-08T18:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/85",
      "url": "https://www.swiftbysundell.com/podcast/85",
      "title": "Podcast: “Cross-Apple platform development”, with special guest James Thomson",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell85.mp3\" type=\"audio/mpeg\"/></audio><p>James Thomson, creator of PCalc, returns to the show to discuss how developers can bring their apps to multiple Apple platforms using technologies like Catalyst and SwiftUI, and how and when it can be a good idea to share code across platforms.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://geniusscansdk.com\">Genius Scan</a>:</strong> Add advanced document scanning features to your app using Genius Scan’s powerful SDK, which you can integrate with just a single line of code. Learn more at <a href=\"https://geniusscansdk.com\">geniusscansdk.com</a>, and feel free to mention that you heard about them on Swift by Sundell when requesting a demo or quote.</li><li><strong><a href=\"https://nordvpn.com/sundell\">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on, and unlock your video streaming services. Get a massive 68% discount on their two-year plan at <a href=\"https://nordvpn.com/sundell\">nordvpn.com/sundell</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/jamesthomson\">James on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://www.pcalc.com\">PCalc</a></li><li><a href=\"https://www.pcalc.com/dice\">Dice by PCalc</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/49\">Previous episode with James</a></li><li><a href=\"https://tla.systems/blog/2019/10/08/catalytic-converter\">James’s blog post about Catalyst</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/mac_catalyst/choosing_a_user_interface_idiom_for_your_mac_app\">The new “Optimize Interface for Mac” Catalyst feature</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/picker\">SwiftUI’s Picker control</a></li><li><a href=\"https://www.swiftbysundell.com/tips/importing-interactive-uikit-views-into-swiftui\">Importing a UIKit view into SwiftUI</a></li><li><a href=\"https://developer.apple.com/scenekit\">SceneKit</a></li><li><a href=\"https://developer.apple.com/spritekit\">SpriteKit</a></li><li><a href=\"https://developer.apple.com/metal\">Metal</a></li><li><a href=\"https://developer.apple.com/documentation/quartzcore\">Core Animation</a></li><li><a href=\"https://developer.apple.com/documentation/coregraphics\">Core Graphics</a></li><li><a href=\"https://github.com/JohnSundell/ImagineEngine\">Imagine Engine</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "James Thomson, creator of PCalc, returns to the show to discuss how developers can bring their apps to multiple Apple platforms using technologies like Catalyst and SwiftUI, and how and when it can be a good idea to share code across platforms.",
      "date_published": "2020-11-05T19:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/paw-november-2020",
      "url": "https://www.swiftbysundell.com/sponsor/paw-november-2020",
      "title": "Sponsored: Using Paw to test an app’s web API",
      "content_html": "<p>My thanks to the team behind the fantastic HTTP and GraphQL utility <a href=\"https://paw.cloud/sundell\">Paw</a> for sponsoring Swift by Sundell last week. I thought I’d take this opportunity to tell you a bit more about how Paw can be a super useful tool for iOS and Mac developers, since it lets you easily test and debug any web API that your app is talking to.</p><p>Let’s say that you’ve started building a new feature that either requires you to download JSON from a new API endpoint, or to connect to some form of external web API. Using Paw, you can easily make test requests to those endpoints, which will quickly get you access to all sorts of useful information — including headers and other kinds of metadata, but perhaps most importantly, what kind of response data that the server will send you.</p><p>For example, here I’m making a call to GitHub’s search API, which shows me exactly what JSON format that I can expect when making such calls within my app. That in turn lets me quickly and easily model my <code>Codable</code> structs and other Swift code that’ll interact with that data, and also tells me what to expect in terms of caching behavior, rate limiting, and so on:</p><img src=\"https://www.swiftbysundell.com/images/sponsored-posts/paw.png\" alt=\"Paw screenshot\"/><p>Of course, the above example barely scratches the surface of what Paw is capable of. It supports authentication, cloud syncing, all sorts of REST requests (like <code>POST</code>, <code>PUT</code>, and so on), and it now also supports GraphQL as well. All of that, and much more, comes built into a fully native, fast Mac app that is a joy to use.</p><p>The best way to learn more is to simply try it out for yourself. Visit <a href=\"https://paw.cloud/sundell\">paw.cloud/sundell</a> to try Paw for free, and when you use that URL you’ll both directly help support me and my work, and you’ll also get an exclusive 20% discount if you decide to purchase Paw after trying it.</p>",
      "summary": "Thanks a lot to Using Paw to test an app’s web API for sponsoring Swift by Sundell.",
      "date_published": "2020-11-02T14:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/formatting-numbers-in-swift",
      "url": "https://www.swiftbysundell.com/articles/formatting-numbers-in-swift",
      "title": "Formatting numbers in Swift",
      "content_html": "<p>A significant part of any given app’s logic is likely going to involve working with numbers in one way or another. Whether it’s in order to perform layout calculations, to schedule events using time intervals, or by dealing with our own, custom metrics, numbers really are everywhere.</p><p>While working with numbers is one of those things that computers are inherently good at, we also occasionally need to format and present some of our numbers in a human-readable way, which can often be tricker than expected. So this week, let’s explore that topic, and how different kinds of numbers might warrant different formatting strategies.</p><h2>Solving the decimal problem</h2><p>At the most basic level, creating a textual representation of a given number simply involves initializing a <code>String</code> with it, which can either be done directly, or by using a <a href=\"https://www.swiftbysundell.com/articles/string-literals-in-swift\">string literal</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> a = <span class=\"s-type\">String</span>(<span class=\"s-number\">42</span>) <span class=\"s-comment\">// \"42\"</span>\n<span class=\"s-keyword\">let</span> b = <span class=\"s-type\">String</span>(<span class=\"s-number\">3.14</span>) <span class=\"s-comment\">// \"3.14\"</span>\n<span class=\"s-keyword\">let</span> c = <span class=\"s-string\">\"</span>\\(<span class=\"s-number\">42</span>)<span class=\"s-string\">,</span> \\(<span class=\"s-number\">3.14</span>)<span class=\"s-string\">\"</span> <span class=\"s-comment\">// \"42, 3.14\"</span></code></pre><p>However, while that approach might work well for generating simpler descriptions of numbers that are under our complete control, we’ll likely going to need much more robust formatting strategies when dealing with dynamic numbers.</p><p>For example, here we’ve defined a <code>Metric</code> type that lets us associate a given <code>Double</code> with a name, which we then use when generating a custom <code>description</code> for such a value:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Metric: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> value: <span class=\"s-type\">Double</span>\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Metric</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-string\">\"</span>\\(name)<span class=\"s-string\">:</span> \\(value)<span class=\"s-string\">\"</span>\n    }\n}</code></pre><p>Since the above <code>Metric</code> type can contain any <code>Double</code> value, we probably want to format it in a more predictable way. For example, rather than simply converting its <code>Double</code> into a <code>String</code>, we could use a custom format to round it to two decimal places, which will make our output consistent regardless of how precise each underlying <code>Double</code> value actually is:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Metric</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formattedValue = <span class=\"s-type\">String</span>(format: <span class=\"s-string\">\"%.2f\"</span>, value)\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"</span>\\(name)<span class=\"s-string\">:</span> \\(formattedValue)<span class=\"s-string\">\"</span>\n    }\n}</code></pre><p>However, we’ll now <em>always</em> output two decimal places, even when our <code>Double</code> is a whole number, or if it just has a single decimal place — which might not be what we were looking for. Take the number <code>42</code> for example. We probably don’t want it to be formatted as <code>42.00</code>, which is what will happen with our current implementation.</p><p>An initial idea on how to solve that problem might be to go for the manual approach, and trim all trailing zeros and decimal points from our formatted string before returning it — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Metric</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">var</span> formattedValue = <span class=\"s-type\">String</span>(format: <span class=\"s-string\">\"%.2f\"</span>, value)\n\n        <span class=\"s-keyword\">while</span> formattedValue.<span class=\"s-property\">last</span> == <span class=\"s-string\">\"0\"</span> {\n            formattedValue.<span class=\"s-call\">removeLast</span>()\n        }\n\n        <span class=\"s-keyword\">if</span> formattedValue.<span class=\"s-property\">last</span> == <span class=\"s-string\">\".\"</span> {\n            formattedValue.<span class=\"s-call\">removeLast</span>()\n        }\n\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"</span>\\(name)<span class=\"s-string\">:</span> \\(formattedValue)<span class=\"s-string\">\"</span>\n    }\n}</code></pre><p>The above code certainly works, but it’s arguably not very elegant, and also makes the assumption that we’ll always format each of our numbers the same way for all users — which we might not actually want to do. Because it turns out that although mathematics might be a truly universal concept, the way people expect numbers to be represented in text varies quite a lot between different countries and locales.</p><h2>Using NumberFormatter</h2><p>Instead, let’s use Foundation’s <code>NumberFormatter</code> to solve our decimal problem. Just like how a <code>DateFormatter</code> can be used to format <code>Date</code> values in various ways, the <code>NumberFormatter</code> class ships with a quite comprehensive suite of formatting tools that are all specific to numbers.</p><p>For example, using <code>NumberFormatter</code>, we can specify that we want to format each number as a decimal with a maximum of two fraction digits, which will give us our desired result without having to do any manual adjustments. Numbers like <code>42</code>, <code>42.1</code> and <code>42.12</code> will now all be rendered just like that, and any number that’s more precise will still be automatically rounded to two decimal points:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Metric</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">NumberFormatter</span>()\n        formatter.<span class=\"s-property\">numberStyle</span> = .<span class=\"s-dotAccess\">decimal</span>\n        formatter.<span class=\"s-property\">maximumFractionDigits</span> = <span class=\"s-number\">2</span>\n\n        <span class=\"s-keyword\">let</span> number = <span class=\"s-type\">NSNumber</span>(value: value)\n        <span class=\"s-keyword\">let</span> formattedValue = formatter.<span class=\"s-call\">string</span>(from: number)!\n        <span class=\"s-keyword\">return</span> <span class=\"s-string\">\"</span>\\(name)<span class=\"s-string\">:</span> \\(formattedValue)<span class=\"s-string\">\"</span>\n    }\n}</code></pre><p class=\"info\">We can safely force-unwrap the optional that <code>NumberFormatter</code> returns from the above call, since we’re in complete control over the <code>NSNumber</code> that is being passed into it.</p><p>Another major benefit of using <code>NumberFormatter</code> is that it’ll automatically take the user’s current <code>Locale</code> into account when formatting our numbers. For instance, in some countries the number <code>50932.52</code> is expected to be formatted as <code>50 932,52</code>, while other locales prefer <code>50,932.52</code> instead. All of those complexities are now handled for us completely automatically, which is most likely what we want when formatting user-facing numbers.</p><p>However, when that’s <em>not</em> the case, and we’re instead looking for consistency across all locales, then we could either assign a specific <code>Locale</code> to our <code>NumberFormatter</code>, or we could configure it to use specific characters as its <code>decimalSeparator</code> and <code>groupingSeparator</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Metric</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">NumberFormatter</span>()\n        formatter.<span class=\"s-property\">numberStyle</span> = .<span class=\"s-dotAccess\">decimal</span>\n        formatter.<span class=\"s-property\">maximumFractionDigits</span> = <span class=\"s-number\">2</span>\n        formatter.<span class=\"s-property\">decimalSeparator</span> = <span class=\"s-string\">\".\"</span>\n        formatter.<span class=\"s-property\">groupingSeparator</span> = <span class=\"s-string\">\"\"</span>\n\n        ...\n    }\n}</code></pre><p class=\"info\">Worth noting is that we can also produce localized numbers when using <code>String</code> directly, by passing a specific <code>locale</code> (or <code>.current</code>) to the <code>format</code>-based initializer that we used earlier.</p><p>In this case, let’s say that we do want our formatting to be localized. To finish our implementation, let’s move the creation of our <code>NumberFormatter</code> to a static property (which will let us reuse the same instance across all <code>Metric</code> values), and let’s also introduce a dedicated API for retrieving each formatted value by itself — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Metric</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">private static var</span> valueFormatter: <span class=\"s-type\">NumberFormatter</span> = {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">NumberFormatter</span>()\n        formatter.<span class=\"s-property\">numberStyle</span> = .<span class=\"s-dotAccess\">decimal</span>\n        formatter.<span class=\"s-property\">maximumFractionDigits</span> = <span class=\"s-number\">2</span>\n        <span class=\"s-keyword\">return</span> formatter\n    }()\n\n    <span class=\"s-keyword\">var</span> formattedValue: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> number = <span class=\"s-type\">NSNumber</span>(value: value)\n        <span class=\"s-keyword\">return</span> <span class=\"s-type\">Self</span>.<span class=\"s-property\">valueFormatter</span>.<span class=\"s-call\">string</span>(from: number)!\n    }\n\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-string\">\"</span>\\(name)<span class=\"s-string\">:</span> \\(formattedValue)<span class=\"s-string\">\"</span>\n    }\n}</code></pre><p>So <code>NumberFormatter</code> is incredibly useful when we wish to format a raw numeric value into a human-readable description, but it can also do much more than just that. Let’s continue exploring!</p><h2>Domain-specific numbers</h2><p>Depending on what kind of app that we’re working on, chances are that we’ll also have to deal with numbers that are <em>domain-specific</em>. That is, they represent something more than just a raw numeric value.</p><p>For example, let’s say that we’re working on a shopping app, and that we’re using a <code>Double</code> wrapped in a custom <code>Price</code> struct to describe a given product’s price:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Product: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> price: <span class=\"s-type\">Price</span>\n    ...\n}\n\n<span class=\"s-keyword\">struct</span> Price: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> amount: <span class=\"s-type\">Double</span>\n    <span class=\"s-keyword\">var</span> currency: <span class=\"s-type\">Currency</span>\n}\n\n<span class=\"s-keyword\">enum</span> Currency: <span class=\"s-type\">String</span>, <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">case</span> eur\n    <span class=\"s-keyword\">case</span> usd\n    <span class=\"s-keyword\">case</span> sek\n    <span class=\"s-keyword\">case</span> pln\n    ...\n}</code></pre><p>Now the question is, how to format such a <code>Price</code> instance in a way that makes sense to each of our users, regardless of which country that they’re in and what locale that they’re using?</p><p>This is another type of situation in which <code>NumberFormatter</code> can be incredibly useful, as it also includes full support for localized currency formatting. All that we have to do is to set its <code>numberStyle</code> to <code>currency</code> and give it the code of the currency that we’re using — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Price</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">NumberFormatter</span>()\n        formatter.<span class=\"s-property\">numberStyle</span> = .<span class=\"s-dotAccess\">currency</span>\n        formatter.<span class=\"s-property\">currencyCode</span> = currency.<span class=\"s-property\">rawValue</span>\n        formatter.<span class=\"s-property\">maximumFractionDigits</span> = <span class=\"s-number\">2</span>\n\n        <span class=\"s-keyword\">let</span> number = <span class=\"s-type\">NSNumber</span>(value: amount)\n        <span class=\"s-keyword\">return</span> formatter.<span class=\"s-call\">string</span>(from: number)!\n    }\n}</code></pre><p>For example, here’s how a price of <code>3.14</code> in the Swedish currency SEK will be displayed in a few different locales when using the above approach:</p><ul><li>Sweden: <code>3,14 kr</code></li><li>Spain: <code>3.14 SEK</code></li><li>US: <code>SEK 3.14</code></li><li>France: <code>SEK 3,14</code></li></ul><p>Those might seem like minor differences in the grand scheme of things, but making the way we format prices and other numbers seem completely natural to each user can <em>really</em> make an app feel much more polished. Of course, the next step would be to also automatically convert each price into the current user’s own currency, but that’s definitely out of scope for this particular article.</p><p>Besides prices, another common category of numeric values that we likely want to localize is <em>measurements</em>. For example, let’s say that the imaginary shopping app that we were just working on has now pivoted into being solely focused on selling vehicles, and that we’ve converted our <code>Product</code> type into a more specific <code>Vehicle</code> model, which includes properties such as <code>topSpeed</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Vehicle {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> price: <span class=\"s-type\">Price</span>\n    <span class=\"s-keyword\">var</span> topSpeed: <span class=\"s-type\">Double</span>\n    ...\n}</code></pre><p>Currently, our <code>topSpeed</code> property is once again a <code>Double</code>, and while that’s certainly a great choice for most raw numbers that should have floating-point precision, it’s actually not a great fit in this case — since our current implementation doesn’t tell us anything about what <em>unit of measurement</em> that our value is using. It could be kilometers per hour, miles per hour, meters per second, and so on.</p><p>Expressing that kind of unit-based numeric values is exactly what the built-in <code>Measurement</code> type is for, so let’s use that instead. In this case, we’ll specialize it with the <a href=\"https://www.swiftbysundell.com/articles/phantom-types-in-swift\">phantom type</a> <code>UnitSpeed</code>, which makes it crystal clear that our <code>topSpeed</code> value represents a measurement of speed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Vehicle {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> price: <span class=\"s-type\">Price</span>\n    <span class=\"s-keyword\">var</span> topSpeed: <span class=\"s-type\">Measurement</span>&lt;<span class=\"s-type\">UnitSpeed</span>&gt; \n    ...\n}</code></pre><p>When creating instances of the above <code>Vehicle</code> type, we’ll now be required to always specify the underlying unit of measurement for our <code>topSpeed</code> property, which is a great thing, as that significantly educes the ambiguity of those values. But that’s just the beginning, because <code>Measurement</code> also has its very own formatter, which we can now use to easily generate formatted descriptions of each vehicle’s top speed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Vehicle</span> {\n    <span class=\"s-keyword\">var</span> formattedTopSpeed: <span class=\"s-type\">String</span> {\n        <span class=\"s-keyword\">let</span> formatter = <span class=\"s-type\">MeasurementFormatter</span>()\n        <span class=\"s-keyword\">return</span> formatter.<span class=\"s-call\">string</span>(from: topSpeed)\n    }\n}</code></pre><p>What’s really great is that not only will the above description be localized, <code>MeasurementFormatter</code> will also automatically convert each value into the unit preferred by the current user’s locale — which will be either <code>km/h</code> or <code>mph</code> in this case. Really cool!</p><p>However, there’s one thing that we need to keep in mind when using <code>Measurement</code> values, and that’s how they’re encoded and decoded by default. When using compiler-generated <code>Codable</code> conformances, each <code>Measurement</code> value is expected to be decoded from a dictionary containing several metadata properties that are probably not included in any JSON that we’re downloading from our app’s server. Instead, we most likely have an agreed-upon unit of measurement that our server is using, meaning that we’d have have to perform our decoding manually in this case — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Vehicle</span>: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">private enum</span> CodingKeys: <span class=\"s-type\">CodingKey</span> {\n        <span class=\"s-keyword\">case</span> name, price, topSpeed, ...\n    }\n\n    <span class=\"s-keyword\">init</span>(from decoder: <span class=\"s-type\">Decoder</span>) <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> container = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">container</span>(keyedBy: <span class=\"s-type\">CodingKeys</span>.<span class=\"s-keyword\">self</span>)\n\n        <span class=\"s-comment\">// Decoding all other properties</span>\n        ...\n\n        topSpeed = <span class=\"s-keyword\">try</span> <span class=\"s-type\">Measurement</span>(\n            value: container.<span class=\"s-call\">decode</span>(<span class=\"s-type\">Double</span>.<span class=\"s-keyword\">self</span>, forKey: .<span class=\"s-dotAccess\">topSpeed</span>),\n            unit: .<span class=\"s-dotAccess\">kilometersPerHour</span>\n        )\n    }\n    \n    <span class=\"s-comment\">// Encoding implementation</span>\n    ...\n}</code></pre><p>Since custom <code>Codable</code> implementations are often quite cumbersome to maintain, let’s also explore an alternative approach. Here’s how we could create a dedicated <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">property wrapper</a> that lets us encapsulate the conversions between <code>Double</code> and <code>Measurement</code> within a single type:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> KilometersPerHour {\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">Measurement</span>&lt;<span class=\"s-type\">UnitSpeed</span>&gt;\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">KilometersPerHour</span>: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">init</span>(from decoder: <span class=\"s-type\">Decoder</span>) <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> container = <span class=\"s-keyword\">try</span> decoder.<span class=\"s-call\">singleValueContainer</span>()\n        <span class=\"s-keyword\">let</span> rawValue = <span class=\"s-keyword\">try</span> container.<span class=\"s-call\">decode</span>(<span class=\"s-type\">Double</span>.<span class=\"s-keyword\">self</span>)\n\n        wrappedValue = <span class=\"s-type\">Measurement</span>(\n            value: rawValue,\n            unit: .<span class=\"s-dotAccess\">kilometersPerHour</span>\n        )\n    }\n\n    <span class=\"s-keyword\">func</span> encode(to encoder: <span class=\"s-type\">Encoder</span>) <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">var</span> container = encoder.<span class=\"s-call\">singleValueContainer</span>()\n        <span class=\"s-keyword\">try</span> container.<span class=\"s-call\">encode</span>(wrappedValue.<span class=\"s-property\">value</span>)\n    }\n}</code></pre><p>A major benefit of the above approach is that, unless we really need <code>Vehicle</code> to use a custom <code>Codable</code> implementation, we can now simply mark our <code>topSpeed</code> property with <code>@KilometersPerHour</code> and we’ll once again be able to let the compiler generate all of that code for us:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Vehicle: <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> price: <span class=\"s-type\">Price</span>\n    <span class=\"s-keyword\">@KilometersPerHour var</span> topSpeed: <span class=\"s-type\">Measurement</span>&lt;<span class=\"s-type\">UnitSpeed</span>&gt;\n    ...\n}</code></pre><p class=\"info\">For more on using property wrappers to customize <code>Codable</code> on a per-property basis, check out <a href=\"https://www.swiftbysundell.com/tips/default-decoding-values\">“Annotating properties with default decoding values”</a>.</p><p>With the above in place, we’ll now get all of the advantages of using <code>Measurement</code> — from the additional type safety, to the built-in formatting and conversion features — while still being able to use <code>Double</code> values when encoding and decoding our models.</p><h2>Conclusion</h2><p>The task of formatting numbers into human-readable strings is most likely something that we want to delegate to the system as much as possible, especially when we wish to produce descriptions that are localized and otherwise adapted to the current user’s locale. Because simply turning a <code>Double</code> into a <code>String</code> might be a trivial task, but actually formatting each value into a <em>correct</em> string is often much more difficult than what it initially might seem like.</p><p>Got questions, comments or feedback? I’d love to hear from you, either via <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>. And if you enjoyed this article, please take a moment to check out the above sponsor, as that <em>really</em> helps support my work financially.</p><p>Thanks for reading! 🚀</p>",
      "summary": "Formatting numbers into human-readable strings can often be tricker than expected. Let’s explore why that is, and what kind of tools and techniques that can be good to keep in mind when formatting different kinds of numbers.",
      "date_published": "2020-11-01T18:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/questions/swiftui-modifier-order",
      "url": "https://www.swiftbysundell.com/questions/swiftui-modifier-order",
      "title": "Q&A: When does the order of SwiftUI modifiers matter, and why?",
      "content_html": "<p>One of the major differences between SwiftUI and Apple’s previous UI frameworks is how views are configured. Rather than directly modifying various properties, we can instead apply <em>modifiers</em> to the views that we declare, which in turn assign the styles and behaviors that we’re looking to add.</p><p>Sometimes, the order in which we apply such modifiers doesn’t matter at all. For example, here we’re creating a specialized label for showing that a certain item has been verified — which uses the built-in <code>Label</code> view introduced in iOS 14 and macOS Big Sur, along with three modifiers that apply our desired styles to the label’s background and text:</p><pre data-preview=\"initial-view\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Verified\"</span>, systemImage: <span class=\"s-string\">\"checkmark.seal.fill\"</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n    }\n}</code></pre><p>Since none of the modifiers that we use above affect the layout or position of our view, but rather just modify its own internal appearance and the <em><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-and-modifying-the-environment\">environment</a></em> in which it will be rendered, we can change the order of them as much as we want, and we’ll still get the exact same result.</p><p>However, if we’re instead applying a modifier that <em>wraps</em> a given view, for example in order to modify its layout, then the order of our modifiers can end up having a quite big impact on our final UI.</p><p>As an example, let’s now say that we wanted to add a bit of padding to our <code>VerifiedLabel</code>, which can be done like this:</p><pre data-preview=\"initial-view\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Verified\"</span>, systemImage: <span class=\"s-string\">\"checkmark.seal.fill\"</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n            .<span class=\"s-call\">padding</span>()\n    }\n}</code></pre><p>The result of the above code (which you can see by using the <code>PREVIEW</code> button) might initially be quite surprising. It doesn’t look like our view has any padding at all! To explain what’s going on here, let’s take a quick look at what our view hierarchy <em>actually</em> ends up looking like when constructed — which can be done using the <code>type(of:)</code> function, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> label = <span class=\"s-type\">VerifiedLabel</span>()\n<span class=\"s-call\">print</span>(<span class=\"s-call\">type</span>(of: label.<span class=\"s-property\">body</span>))</code></pre><p>Intuitively, we might expect the above expression to simply print the name of our own view type — <code>VerifiedLabel</code> — but here’s what actually ends up getting printed:</p><pre class=\"splash\"><code><span class=\"s-type\">ModifiedContent</span>&lt;\n    <span class=\"s-type\">ModifiedContent</span>&lt;\n        <span class=\"s-type\">ModifiedContent</span>&lt;\n            <span class=\"s-type\">ModifiedContent</span>&lt;\n                <span class=\"s-type\">Label</span>&lt;<span class=\"s-type\">Text</span>, <span class=\"s-type\">Image</span>&gt;,\n                <span class=\"s-type\">_BackgroundModifier</span>&lt;<span class=\"s-type\">Color</span>&gt;\n            &gt;,\n            <span class=\"s-type\">_EnvironmentKeyWritingModifier</span>&lt;\n                <span class=\"s-type\">Optional</span>&lt;<span class=\"s-type\">Color</span>&gt;\n            &gt;\n        &gt;,\n        <span class=\"s-type\">_EnvironmentKeyWritingModifier</span>&lt;\n            <span class=\"s-type\">Optional</span>&lt;<span class=\"s-type\">Font</span>&gt;\n        &gt;\n    &gt;,\n    <span class=\"s-type\">_PaddingLayout</span>\n&gt;</code></pre><p>What the above shows is that each time that we apply a modifier, we actually end up creating a whole new view (at least <em>most of the time</em>), which in turn explains why the padding that we added is seemingly missing when rendering our <code>VerifiedLabel</code>.</p><p>It turns out that the padding is indeed there, it’s just that because we’re applying it <em>after</em> applying our background color, we just <em>can’t see it</em>, since the background color will only apply to our label itself — not to the wrapping padding view that the <code>padding</code> modifier adds. That becomes even more clear if we also add a border after adding our padding, which results in a gap between that border and our label:</p><pre data-preview=\"border\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Verified\"</span>, systemImage: <span class=\"s-string\">\"checkmark.seal.fill\"</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">border</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">red</span>)\n    }\n}</code></pre><p>To now actually fix the issue and get the kind of padding that we originally intended, all that we have to do is to move our <code>background</code> modifier so that it’s applied <em>after</em> our padding has been added — like this:</p><pre data-preview=\"correct-padding\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Verified\"</span>, systemImage: <span class=\"s-string\">\"checkmark.seal.fill\"</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n    }\n}</code></pre><p>The same thing applies to other kinds of wrapping modifiers as well, for example <code>cornerRadius</code>, which wraps a given view using a clipping mask in order to give it rounded corners:</p><pre data-preview=\"corner-radius\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Verified\"</span>, systemImage: <span class=\"s-string\">\"checkmark.seal.fill\"</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>Another case in which the order of our modifiers can be really important is when using ones that are specific to a given type. For example, the <code>bold</code> modifier can only be applied directly to <code>Text</code> values, meaning that if we wanted to change our <code>VerifiedLabel</code> to simply have bold text instead of having an icon, we would need to apply that modifier directly to our <code>Text</code> itself:</p><pre data-preview=\"bold-text\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"Verified\"</span>)\n            .<span class=\"s-call\">bold</span>()\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>However, since the first couple of modifiers (<code>foregroundColor</code> and <code>font</code>) only modify our text’s environment, we can also apply our <code>bold</code> modifier after them as well, as long as we keep getting <code>Text</code> values back from those calls. If we, on the other hand, attempted to apply the <code>bold</code> modifier after adding our view’s <code>padding</code>, then we’d get a compiler error saying that our view doesn’t have such a method, since we’re no longer dealing with a <code>Text</code> instance directly:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> VerifiedLabel: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Text</span>(<span class=\"s-string\">\"Verified\"</span>)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">callout</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">bold</span>()\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">green</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>So, to sum up, here are a few things that can be good to keep in mind when working with SwiftUI modifiers:</p><ul><li>When a modifier just changes the environment that its target view will be rendered in, then the order often doesn’t matter.</li><li>However, if that modifier can only be applied to a specific type of view, then we can only apply it as long as we’re dealing with that kind of view directly.</li><li>The order of modifiers that wrap their target view, on the other hand, often matters <em>quite a lot</em>, and a different modifier order can end up yielding a very different result.</li></ul><p>I hope that you found this answer useful. If you did, please check out this week’s sponsor (link below) to support my work, and feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a> if you have any questions or feedback.</p>",
      "date_published": "2020-10-28T16:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/revenuecat-october-2020",
      "url": "https://www.swiftbysundell.com/sponsor/revenuecat-october-2020",
      "title": "Sponsor: RevenueCat",
      "content_html": "<p>Thanks a lot to <a href=\"https://www.revenuecat.com/?utm_source=sundell&utm_medium=referral&utm_campaign=q4\">RevenueCat</a> for sponsoring Swift by Sundell last week. Their continued support helps me keep the entire site free and available to everyone in the Swift community.</p><p>Implementing in-app purchases is one of those development tasks that can appear deceptively simple at first glance. After all, Apple’s StoreKit framework has everything that we’ll need, right?</p><p>While that might be technically true, successfully building a robust in-app purchase implementation can be <em>really</em> tricky, especially when dealing with subscriptions — as you’ll need to perform receipt validation, handle transactions, parse expiration dates, and so much more. That’s why I recommend <a href=\"https://www.revenuecat.com/?utm_source=sundell&utm_medium=referral&utm_campaign=q4\">checking out RevenueCat</a>, because they’ll handle all of those complexities for you, all through a very simple and elegant Swift API.</p><p>RevenueCat also supports other platforms, such as Android, and includes a suite of really powerful features — including analytics, integrations with other services, web hooks, and more. Getting started is completely free, and by using <a href=\"https://www.revenuecat.com/?utm_source=sundell&utm_medium=referral&utm_campaign=q4\">this link to check out RevenueCat</a>, then you’ll also help support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to RevenueCat for sponsoring Swift by Sundell.",
      "date_published": "2020-10-26T10:40:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/connecting-and-merging-combine-publishers-in-swift",
      "url": "https://www.swiftbysundell.com/articles/connecting-and-merging-combine-publishers-in-swift",
      "title": "Connecting and merging Combine publishers in Swift",
      "content_html": "<p>At first glance, it might seem like Apple’s Combine framework is simply an abstraction for performing various asynchronous operations. However, while that’s certainly a key aspect of it, it could definitely be argued that the true power of Combine lies in how it enables us to construct increasingly complex data pipelines that can use multiple inputs and transformations to load, prepare, and handle an app’s data.</p><p>This week, let’s take a look at some of those capabilities, and how they can enable us to solve real-world problems in concise, yet also highly robust ways.</p><h2>Loading data from multiple sources</h2><p>As an example, let’s say that we’re working on a task management app that lets our users create groups containing their various tasks and todo items. To then load those groups over the network, we use the following <code>TaskGroupsLoader</code>, which in turn uses Combine (along with <code>URLSession</code> and the <code>NetworkResponse</code> wrapper from <em><a href=\"https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift\">“Creating generic networking APIs in Swift”</a></em>) to perform its work:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> TaskGroupsLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">private let</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n\n    <span class=\"s-keyword\">func</span> loadGroupList() -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>], <span class=\"s-type\">Error</span>&gt; {\n        urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">taskGroups</span>)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(\n                type: <span class=\"s-type\">NetworkResponse</span>&lt;[<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>]&gt;.<span class=\"s-keyword\">self</span>,\n                decoder: decoder\n            )\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p class=\"info\">The reason that we can simply use <code>.taskGroups</code> to refer to the URL that we’re calling above is because we’ve extended <code>URL</code> with a series of static APIs that return our various server URLs. To learn more about that approach, and a couple of more powerful alternatives to it, check out the <a href=\"https://www.swiftbysundell.com/clips/4\">“Managing URLs and endpoints”</a> Swift clip.</p><p>The above approach works perfectly fine as long as the URL that we’re calling returns all of the <code>Task.Group</code> data that we need on the client side. However, when working with web APIs that follow the popular REST convention, it’s incredibly common to have to make several, separate calls in order to load all of the data that’s needed to construct a complete model.</p><p>For example, let’s say that in order to load certain metadata, such as the number of tasks that are contained within a given group, or when it was last updated, we need to call another endpoint on a per-group basis — meaning that we now need to perform a series of nested networking tasks in order to be able to form our complete array of <code>Task.Group</code> models.</p><p>To make that happen, let’s start by redefining <code>Task.Group</code> as a struct containing all of the data that we’re looking to load throughout our series of network calls:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Task</span> {\n    <span class=\"s-keyword\">struct</span> Group: <span class=\"s-type\">Identifiable</span> {\n        <span class=\"s-keyword\">let</span> id: <span class=\"s-type\">UUID</span>\n        <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n        <span class=\"s-keyword\">var</span> taskCount: <span class=\"s-type\">Int</span>\n        <span class=\"s-keyword\">var</span> lastUpdated: <span class=\"s-type\">Date</span>\n    }\n}</code></pre><p>Note that we’re no longer making the above model <code>Decodable</code>, since we won’t be decoding instances of it directly from a single network response. Instead, we’ll define two <em>partial models</em> that we’ll use within our <code>TaskGroupsLoader</code>, and since both of those models should be considered private implementation details of our loader, we’ll place them within the same file using a private extension — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span> {\n    <span class=\"s-keyword\">struct</span> ListEntry: <span class=\"s-type\">Decodable</span> {\n        <span class=\"s-keyword\">let</span> id: <span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>.<span class=\"s-type\">ID</span>\n        <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    }\n\n    <span class=\"s-keyword\">struct</span> Metadata: <span class=\"s-type\">Decodable</span> {\n        <span class=\"s-keyword\">var</span> taskCount: <span class=\"s-type\">Int</span>\n        <span class=\"s-keyword\">var</span> lastUpdated: <span class=\"s-type\">Date</span>\n    }\n}</code></pre><p class=\"info\">To learn more about the above way of using extensions, check out last week’s <a href=\"https://www.swiftbysundell.com/articles/the-power-of-extensions-in-swift\">“The power of extensions in Swift”</a>.</p><p>While using <a href=\"https://www.swiftbysundell.com/tips/namespacing-with-nested-types\">nested types</a> like we do above can be a great way to improve the overall semantics and structure of our code, having to repeatedly type those long names can be a bit tedious — so let’s also create two <a href=\"https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift\">type aliases</a> that’ll let us refer to them as just <code>Entry</code> and <code>Metadata</code> within our <code>TaskGroupsLoader</code> implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">TaskGroupsLoader</span> {\n    <span class=\"s-keyword\">typealias</span> Entry = <span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>.<span class=\"s-type\">ListEntry</span>\n    <span class=\"s-keyword\">typealias</span> Metadata = <span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>.<span class=\"s-type\">Metadata</span>\n}</code></pre><p>With the above model code in place, let’s now implement our nested network calls. We’ll start by adding a private method that’ll let us convert a loaded <code>Entry</code> into a complete <code>Task.Group</code> model. To do that, we’ll once again use <code>URLSession</code> to load the current group’s <code>Metadata</code>, and we’ll then combine the result of that operation with the <code>Entry</code> that was passed in — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">TaskGroupsLoader</span> {\n    <span class=\"s-keyword\">func</span> loadGroup(\n        for entry: <span class=\"s-type\">Entry</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">let</span> url = <span class=\"s-type\">URL</span>.<span class=\"s-call\">metadataForTaskGroup</span>(withID: entry.<span class=\"s-property\">id</span>)\n\n        <span class=\"s-keyword\">return</span> urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(\n                type: <span class=\"s-type\">NetworkResponse</span>&lt;<span class=\"s-type\">Metadata</span>&gt;.<span class=\"s-keyword\">self</span>,\n                decoder: decoder\n            )\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">map</span> { metadata <span class=\"s-keyword\">in</span>\n                <span class=\"s-comment\">// Forming our final model by combining the newly\n                // loaded Metadata with the Entry that was passed in:</span>\n                <span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>(\n                    id: entry.<span class=\"s-property\">id</span>,\n                    name: entry.<span class=\"s-property\">name</span>,\n                    taskCount: metadata.<span class=\"s-property\">taskCount</span>,\n                    lastUpdated: metadata.<span class=\"s-property\">lastUpdated</span>\n                )\n            }\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Next, let’s implement another private method that’ll let us convert an <em>array of</em> <code>Entry</code> values into a Combine publisher that’ll emit our final array of <code>Task.Group</code> models. Doing that requires the following three steps (not counting the type-erasing call to <code>eraseToAnyPublisher</code>):</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">TaskGroupsLoader</span> {\n    <span class=\"s-keyword\">func</span> loadGroups(\n        for entries: [<span class=\"s-type\">Entry</span>]\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>], <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-comment\">// First, we convert our Entry array into a publisher:</span>\n        entries.<span class=\"s-property\">publisher</span>\n                <span class=\"s-comment\">// Then, we use the flatMap operator to convert\n                // each Entry element into a nested publisher using\n                // the loadGroup method that we implemented earlier:</span>\n               .<span class=\"s-call\">flatMap</span>(loadGroup)\n               <span class=\"s-comment\">// Finally, we collect the results from all of our\n               // nested publishers into one final array of task groups:</span>\n               .<span class=\"s-call\">collect</span>()\n               .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p class=\"info\">In Combine, the <code>map</code> operator lets us synchronously transform an output value into a new type of value, while the <code>flatMap</code> operator lets us turn an output value into a new <code>Publisher</code> instead.</p><p>With the above pieces in place, all that remains is to make two minor modifications to our original <code>TaskGroupsLoader</code> implementation — to first load an array of <code>Entry</code> values (rather than <code>Task.Group</code> models directly), and to then once again use the <code>flatMap</code> operator to load the final array of models using our newly added <code>loadGroups</code> method:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> TaskGroupsLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">private let</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n\n    <span class=\"s-keyword\">func</span> loadGroupList() -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>], <span class=\"s-type\">Error</span>&gt; {\n        urlSession\n            .<span class=\"s-call\">dataTaskPublisher</span>(for: .<span class=\"s-dotAccess\">taskGroups</span>)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(\n                type: <span class=\"s-type\">NetworkResponse</span>&lt;[<span class=\"s-type\">Entry</span>]&gt;.<span class=\"s-keyword\">self</span>,\n                decoder: decoder\n            )\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">flatMap</span>(loadGroups)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Although it wouldn’t be fair to classify the above code as <em>universally simple</em>, it’s definitely <em>much simpler</em> compared to what we’d have to do to implement the same kind of nested network calls without Combine.</p><p>By using Combine, we were able to decompose the problem into several atomic chains of operations, that could then be combined (hence the name of the framework) into our final data loading pipeline — really nice!</p><h2>Not a silver bullet against race conditions</h2><p>Our above implementation does have a quite major problem though — which might not be obvious as our code now appears almost synchronous (even though it’s highly asynchronous and parallelized under the hood) — and that’s that the <code>Task.Group</code> models within our final array can end up <em>out of order</em>.</p><p>While Combine will automatically handle many of the complexities that are involved in writing parallelized code, it doesn’t give us any guarantees when it comes to the order of output values when using operators like <code>flatMap</code> to perform multiple asynchronous operations at once.</p><p>So, currently, each <code>Task.Group</code> array that our <code>TaskGroupsLoader</code> will emit will have an order determined by when each nested network call was finished, which gives us a quite substantial race condition within that part of the app.</p><p>One way to fix that problem would be by explicitly sorting our final output array before emitting it. To make it somewhat easier to do so, let’s start by extending Combine’s <code>Publisher</code> protocol with a transforming API (also known as an <em>operator</em>) for sorting the output of any publisher that emits <code>Sequence</code>-conforming values — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Output</span>: <span class=\"s-type\">Sequence</span> {\n    <span class=\"s-keyword\">typealias</span> Sorter = (<span class=\"s-type\">Output</span>.<span class=\"s-type\">Element</span>, <span class=\"s-type\">Output</span>.<span class=\"s-type\">Element</span>) -&gt; <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">func</span> sort(\n        by sorter: <span class=\"s-keyword\">@escaping</span> <span class=\"s-type\">Sorter</span>\n    ) -&gt; <span class=\"s-type\">Publishers</span>.<span class=\"s-type\">Map</span>&lt;<span class=\"s-type\">Self</span>, [<span class=\"s-type\">Output</span>.<span class=\"s-type\">Element</span>]&gt; {\n        <span class=\"s-call\">map</span> { sequence <span class=\"s-keyword\">in</span>\n            sequence.<span class=\"s-call\">sorted</span>(by: sorter)\n        }\n    }\n}</code></pre><p>Then, we simply have to append our new <code>sort</code> operator to the pipeline within our <code>loadGroups</code> method, and the final array of <code>Task.Group</code> values will now have a predictable order. A reasonable approach in this case might be to sort our groups based on when they were last updated, with the most recently updated group first:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">TaskGroupsLoader</span> {\n    <span class=\"s-keyword\">func</span> loadGroups(\n        for entries: [<span class=\"s-type\">Entry</span>]\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>], <span class=\"s-type\">Error</span>&gt; {\n        entries.<span class=\"s-property\">publisher</span>\n               .<span class=\"s-call\">flatMap</span>(loadGroup)\n               .<span class=\"s-call\">collect</span>()\n               .<span class=\"s-call\">sort</span> { $0.<span class=\"s-property\">lastUpdated</span> &gt; $1.<span class=\"s-property\">lastUpdated</span> }\n               .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>But what if we don’t have a specific piece of data that we can use for sorting — how could we still ensure a stable output order based on our initial array of <code>Entry</code> values? One way to do that would be by constructing a dictionary of indexes before we start our nested loading operations, and to then base our final sorting on those indexes — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">TaskGroupsLoader</span> {\n    <span class=\"s-keyword\">func</span> loadGroups(\n        for entries: [<span class=\"s-type\">Entry</span>]\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>], <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">var</span> indexes = [<span class=\"s-type\">Task</span>.<span class=\"s-type\">Group</span>.<span class=\"s-type\">ID</span> : <span class=\"s-type\">Int</span>]()\n\n        <span class=\"s-keyword\">for</span> (index, entry) <span class=\"s-keyword\">in</span> entries.<span class=\"s-call\">enumerated</span>() {\n            indexes[entry.<span class=\"s-property\">id</span>] = index\n        }\n\n        <span class=\"s-keyword\">return</span> entries.<span class=\"s-property\">publisher</span>\n               .<span class=\"s-call\">flatMap</span>(loadGroup)\n               .<span class=\"s-call\">collect</span>()\n               .<span class=\"s-call\">sort</span> { a, b <span class=\"s-keyword\">in</span>\n                   <span class=\"s-comment\">// Here we can safely force-unwrap both of\n                   // our indexes, since we're dealing with local\n                   // data that's under our complete control:</span>\n                   indexes[a.<span class=\"s-property\">id</span>]! &lt; indexes[b.<span class=\"s-property\">id</span>]!\n               }\n               .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>With either of the above sorting strategies in place, we’re now able to load our data from multiple sources, and to then turn that data into a single, predictable array of output values — which is really nice, but we’re still just scratching the surface of what Combine is <em>actually</em> capable of.</p><h2>Completely reactive pipelines</h2><p>In the next series of examples, we’re going to use the following <code>SearchResultsLoader</code>, which enables us to load an array of <code>SearchResult</code> values using a <code>String</code>-based query, along with an optional <code>SearchFilter</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SearchResultsLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">private let</span> decoder = <span class=\"s-type\">JSONDecoder</span>()\n\n    <span class=\"s-keyword\">func</span> loadResults(\n        forQuery query: <span class=\"s-type\">String</span>,\n        filter: <span class=\"s-type\">SearchFilter</span>?\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;[<span class=\"s-type\">SearchResult</span>], <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-comment\">// When given a query that's less than 3 characters long,\n        // we simply return an empty array as our result:</span>\n        <span class=\"s-keyword\">guard</span> query.<span class=\"s-property\">count</span> &gt; <span class=\"s-number\">2</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Just</span>([])\n                .<span class=\"s-call\">setFailureType</span>(to: <span class=\"s-type\">Error</span>.<span class=\"s-keyword\">self</span>)\n                .<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        <span class=\"s-keyword\">let</span> url = <span class=\"s-type\">URL</span>.<span class=\"s-call\">search</span>(for: query, filter: filter)\n\n        <span class=\"s-keyword\">return</span> urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(\n                type: <span class=\"s-type\">NetworkResponse</span>&lt;[<span class=\"s-type\">SearchResult</span>]&gt;.<span class=\"s-keyword\">self</span>,\n                decoder: decoder\n            )\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>To connect the above <code>SearchResultsLoader</code> to our UI, we’ll then use a <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift\">view model</a> that’ll let us observe a <code>Published</code>-marked <code>output</code> property from either a SwiftUI view or a view controller. To also enable errors to be <a href=\"https://www.swiftbysundell.com/articles/propagating-user-facing-errors-in-swift\">correctly propagated to the user</a>, we’ll make that <code>output</code> property contain a <a href=\"https://www.swiftbysundell.com/basics/result\"><code>Result</code></a> value — giving us the following class declaration:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> SearchViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">typealias</span> Output = <span class=\"s-type\">Result</span>&lt;[<span class=\"s-type\">SearchResult</span>], <span class=\"s-type\">Error</span>&gt;\n\n    <span class=\"s-keyword\">@Published private(set) var</span> output = <span class=\"s-type\">Output</span>.<span class=\"s-call\">success</span>([])\n\n    <span class=\"s-keyword\">var</span> query = <span class=\"s-string\">\"\"</span> { <span class=\"s-keyword\">didSet</span> { <span class=\"s-call\">loadResults</span>() } }\n    <span class=\"s-keyword\">var</span> filter: <span class=\"s-type\">SearchFilter</span>? { <span class=\"s-keyword\">didSet</span> { <span class=\"s-call\">loadResults</span>() } }\n\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">SearchResultsLoader</span>\n\n    <span class=\"s-keyword\">init</span>(loader: <span class=\"s-type\">SearchResultsLoader</span> = .<span class=\"s-keyword\">init</span>()) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">loader</span> = loader\n    }\n}</code></pre><p>Finally, let’s implement the <code>loadResults</code> method that we’re calling above whenever our <code>query</code> or <code>filter</code> was changed. Within that method, we’ll first call our <code>SearchResultsLoader</code> to obtain a publisher that emits an array of <code>SearchResult</code> values. We’ll then use <a href=\"https://www.swiftbysundell.com/articles/the-power-of-extensions-in-swift/#specializing-generics\">this custom operator</a> to convert that publisher into one that emits <code>Result</code> values (rather than separate errors), which we can then assign directly to our view model’s <code>output</code> property — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">SearchViewModel</span> {\n    <span class=\"s-keyword\">func</span> loadResults() {\n        loader.<span class=\"s-call\">loadResults</span>(forQuery: query, filter: filter)\n              .<span class=\"s-call\">asResult</span>()\n              .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n              .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$output</span>)\n    }\n}</code></pre><p class=\"info\">Note how we’re making an explicit jump over to the <code>main</code> queue before performing our assignment, since we’re now dealing with code that we’re looking to use from within our view layer.</p><p>Once again we have an implementation that works reasonably well, but it could definitely be improved. Specifically, it would be great if our view model would both <em>debounce</em> its calls to our <code>SearchResultsLoader</code> (as to avoid either duplicate or redundant network requests when its <code>query</code> is being rapidly changed), and we should also ensure that any delayed network calls are discarded once a new one is started.</p><p>Thankfully, Combine offers complete support for implementing that kind of functionality, but let’s also take things a bit further this time around — by making our view model’s implementation <em>completely reactive</em>, rather than requiring us to manually call <code>loadResults</code> each time that either of our input properties were changed.</p><p>To make that sort of pattern easier to implement in a way that’s fully compatible with both SwiftUI and UIKit, let’s introduce the following <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">property wrapper</a>, which will let us access any property annotated with that wrapper as a Combine publisher:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@propertyWrapper\nstruct</span> Input&lt;Value&gt; {\n    <span class=\"s-keyword\">var</span> wrappedValue: <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">get</span> { subject.<span class=\"s-property\">value</span> }\n        <span class=\"s-keyword\">set</span> { subject.<span class=\"s-call\">send</span>(newValue) }\n    }\n\n    <span class=\"s-keyword\">var</span> projectedValue: <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Value</span>, <span class=\"s-type\">Never</span>&gt; {\n        subject.<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n\n    <span class=\"s-keyword\">private let</span> subject: <span class=\"s-type\">CurrentValueSubject</span>&lt;<span class=\"s-type\">Value</span>, <span class=\"s-type\">Never</span>&gt;\n\n    <span class=\"s-keyword\">init</span>(wrappedValue: <span class=\"s-type\">Value</span>) {\n        subject = <span class=\"s-type\">CurrentValueSubject</span>(wrappedValue)\n    }\n}</code></pre><p>What makes the above <code>Input</code> type different from the <code>Published</code> property wrapper that Combine ships with is that it won’t trigger the automatic <code>objectWillChange</code> publisher that SwiftUI uses to connect <code>ObservableObject</code> types to a given view’s <code>body</code>. That means that we’ll be able to freely observe <code>Input</code>-marked properties without causing any unnecessary SwiftUI view updates, or other kinds of <code>objectWillChange</code> observations.</p><p>Next, let’s update our initial <code>SearchViewModel</code> declaration to now use our new <code>Input</code> property wrapper. We’ll also remove our <code>didSet</code> property observers, and we’re now calling a new <code>configureDataPipeline</code> method from within our initializer:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> SearchViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">typealias</span> Output = <span class=\"s-type\">Result</span>&lt;[<span class=\"s-type\">SearchResult</span>], <span class=\"s-type\">Error</span>&gt;\n\n    <span class=\"s-keyword\">@Published private(set) var</span> output = <span class=\"s-type\">Output</span>.<span class=\"s-call\">success</span>([])\n    <span class=\"s-keyword\">@Input var</span> query = <span class=\"s-string\">\"\"</span>\n    <span class=\"s-keyword\">@Input var</span> filter: <span class=\"s-type\">SearchFilter</span>?\n\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">SearchResultsLoader</span>\n\n    <span class=\"s-keyword\">init</span>(loader: <span class=\"s-type\">SearchResultsLoader</span> = .<span class=\"s-keyword\">init</span>()) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">loader</span> = loader\n        <span class=\"s-call\">configureDataPipeline</span>()\n    }\n}</code></pre><p>Now, here comes the <em>really cool</em> part. Since we’re now able to observe both <code>query</code> and <code>filter</code> as publishers, we can actually construct all of our view model’s internal logic using a single Combine pipeline.</p><p>To do that, we’ll start by observing our <code>query</code> publisher, and after debouncing and de-duplicating its emitted values, we’ll use the <code>combineLatest</code> operator to combine it with our <code>filter</code> publisher. We’ll then call our <code>SearchResultsLoader</code> using the combined output of those two publishers, and finally we’ll use the <code>switchToLatest</code> operator to always emit the results loaded for the latest request — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">SearchViewModel</span> {\n    <span class=\"s-keyword\">func</span> configureDataPipeline() {\n        <span class=\"s-property\">$query</span>\n            .<span class=\"s-call\">dropFirst</span>()\n            .<span class=\"s-call\">debounce</span>(for: <span class=\"s-number\">0.5</span>, scheduler: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">removeDuplicates</span>()\n            .<span class=\"s-call\">combineLatest</span>(<span class=\"s-property\">$filter</span>)\n            .<span class=\"s-call\">map</span> { [loader] query, filter <span class=\"s-keyword\">in</span>\n                loader.<span class=\"s-call\">loadResults</span>(\n                    forQuery: query,\n                    filter: filter\n                )\n                .<span class=\"s-call\">asResult</span>()\n            }\n            .<span class=\"s-call\">switchToLatest</span>()\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">assign</span>(to: &amp;<span class=\"s-property\">$output</span>)\n    }\n}</code></pre><p class=\"info\">The reason we start the above pipeline by calling <code>dropFirst</code> is because a <code>CurrentValueSubject</code> (which we’re using to implement our <code>Input</code> property wrapper) emits its current value when a subscription is attached to it. Since that’ll always be an empty <code>query</code> string in this case, we’re simply ignoring it.</p><p>The beauty of the above type of abstraction is that it completely hides all of the complexity involved in dealing with multiple inputs, network calls and JSON decoding from our UI layer — which, especially when implemented using SwiftUI, can be kept really simple:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SearchView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">SearchViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-comment\">// We'd probably want to use a more properly styled\n            // search field here, for example by importing either\n            // UISearchTextField or UISearchBar from UIKit:</span>\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Search\"</span>, text: <span class=\"s-property\">$viewModel</span>.<span class=\"s-property\">query</span>)\n\n            <span class=\"s-keyword\">switch</span> viewModel.<span class=\"s-property\">output</span> {\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> results):\n                <span class=\"s-type\">List</span>(results) { result <span class=\"s-keyword\">in</span>\n                    <span class=\"s-type\">SearchResultView</span>(result: result)\n                }\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                <span class=\"s-type\">ErrorView</span>(error: error)\n            }\n        }\n    }\n}</code></pre><p>Our <code>SearchViewModel</code> is also fully UIKit-compatible, since we can manually assign new values to both <code>query</code> and <code>filter</code>, and we can use Combine’s <code>sink</code> operator to observe our view model’s <code>output</code> property in order to bind our search results to something like a <code>UITableView</code> or a <code>UICollectionView</code>. For more on how to setup those kinds of bindings when using UIKit, check out <em><a href=\"https://www.swiftbysundell.com/articles/published-properties-in-swift\">“Published properties in Swift”</a></em>.</p><h2>Conclusion</h2><p>Combine definitely lives up to its name by offering us a suite of powerful tools that let us combine multiple publishers into a single stream of values — whether those are input values that are assigned from our UI, or output values from previous asynchronous operations.</p><p>That in turn often enables us to decompose complex asynchronous tasks (such as nested network calls) into smaller, composable building blocks — which can really help make such logic easier to read, debug, and maintain.</p><p>There are of course many other aspects of Combine that we’ll have to save for future articles, including more ways that publishers can be combined and merged, but I hope that this article has given you a bit of insight into how I use Combine to accomplish these kinds of asynchronous tasks. If you have any questions, comments, or feedback — then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "How Combine’s operators for connecting and merging publishers can be used to solve real-world problems, such as nested network calls, handling multiple input sources, and more.",
      "date_published": "2020-10-25T19:50:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/84",
      "url": "https://www.swiftbysundell.com/podcast/84",
      "title": "Podcast: “Key paths, functions and closures”, with special guest Vincent Pradeilles",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell84.mp3\" type=\"audio/mpeg\"/></audio><p>Vincent Pradeilles joins John to discuss various ways to use Swift language features like key paths and closures, how they relate to patterns typically used within functional programming, and when and how to adopt such patterns.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to learn more about Instabug’s new App Performance Monitoring feature, and to start your free trial.</li><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/v_pradeilles\">Vincent on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://twitter.com/ios_memes\">ios_memes</a></li><li><a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">Function builders</a></li><li><a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">Property wrappers</a></li><li><a href=\"https://www.swiftbysundell.com/tips/combining-dynamic-member-lookup-with-key-paths\">Combining dynamic member lookup with key paths</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/list\">SwiftUI’s List type</a></li><li><a href=\"https://remote.nsspain.com\">NSSpain (use offer code “Sundell” for 10% off, by the way)</a></li><li><a href=\"https://www.swiftbysundell.com/articles/the-power-of-key-paths-in-swift\">Key paths</a></li><li><a href=\"https://www.swiftbysundell.com/tips/passing-key-paths-as-functions\">Passing key paths as functions</a></li><li><a href=\"https://www.swiftbysundell.com/basics/map-flatmap-and-compactmap\">Map, FlatMap and CompactMap</a></li><li><a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a></li><li><a href=\"https://graphql.org\">GraphQL</a></li><li><a href=\"https://developer.apple.com/documentation/swift/caseiterable\">CaseIterable</a></li><li><a href=\"https://github.com/krzysztofzablocki/Sourcery\">Sourcery</a></li><li><a href=\"https://www.swiftbysundell.com/articles/first-class-functions-in-swift\">First class functions</a></li><li><a href=\"https://www.swiftbysundell.com/articles/functional-networking-in-swift/#currying\">Function currying</a></li><li><a href=\"https://www.haskell.org\">Haskell</a></li><li><a href=\"https://www.swiftbysundell.com/tips/dependency-injection-using-functions\">Dependency injection using functions</a></li><li><a href=\"https://www.swiftbysundell.com/articles/pure-functions-in-swift\">Pure functions</a></li><li><a href=\"https://vimeo.com/292702159\">Vincent’s talk about function composition</a></li><li><a href=\"https://www.youtube.com/watch?v=CYkpF7COpVY\">Vincent’s talk about implementing pseudo-keywords through functional programing</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swifts-closure-capturing-mechanics\">Swift’s closure capturing mechanics</a></li><li><a href=\"https://github.com/kickstarter/ios-oss\">Kickstarter’s iOS app</a></li><li><a href=\"https://www.swiftbysundell.com/articles/delegation-in-swift\">The delegate pattern</a></li><li><a href=\"https://github.com/vincent-pradeilles/KeyPathKit\">Vincent’s KeyPathKit library</a></li><li><a href=\"https://www.youtube.com/channel/UCjkoQk5fOk6lH-shlm53vlw\">Vincent’s YouTube channel</a></li><li><a href=\"https://medium.com/@vin.pradeilles/crazy-idea-what-if-we-used-marketing-to-start-a-tech-blog-ff01e96cc99a\">“Crazy idea: What if we used marketing to start a tech blog?“</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Vincent Pradeilles joins John to discuss various ways to use Swift language features like key paths and closures, how they relate to patterns typically used within functional programming, and when and how to adopt such patterns.",
      "date_published": "2020-10-22T18:55:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/simgenie-october-2020",
      "url": "https://www.swiftbysundell.com/sponsor/simgenie-october-2020",
      "title": "Sponsor: Sim Genie",
      "content_html": "<p>My thanks to the indie development shop Breakpoint Studio for sponsoring Swift by Sundell last week to promote <a href=\"https://simgenie.app/?utm_source=swiftbysundell&utm_medium=site&utm_campaign=sponsor_oct_2020\">Sim Genie</a>, their excellent new iOS development tool that turns many repetitive simulator tasks into instant actions.</p><p>Using Sim Genie you can do things like easily browse and modify each simulator’s data, change your app’s granted permissions, send push notifications, empty the keychain, capture screenshots and videos, and so much more.</p><p>Sim Genie can also help you make your marketing videos and screenshots look fantastic, with built-in support for configuring the status bar to have just the right look, and Sim Genie even integrates with Unsplash to let you import high-quality placeholder images with just a click.</p><p>So I really recommend checking out <a href=\"https://simgenie.app/?utm_source=swiftbysundell&utm_medium=site&utm_campaign=sponsor_oct_2020\">Sim Genie</a>, and the good news is that you can try it completely for free, and by using <a href=\"https://simgenie.app/?utm_source=swiftbysundell&utm_medium=site&utm_campaign=sponsor_oct_2020\">this link</a> to do so you also directly help support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to Sim Genie for sponsoring Swift by Sundell.",
      "date_published": "2020-10-19T08:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/the-power-of-extensions-in-swift",
      "url": "https://www.swiftbysundell.com/articles/the-power-of-extensions-in-swift",
      "title": "The power of extensions in Swift",
      "content_html": "<p>Extensions enable us to add new functionality to existing types and protocols, including ones that we didn’t define ourselves — such as those that ship as part of the Swift standard library or Apple’s various SDKs, or in any third party package that we’ve included within our project.</p><p>However, the ways in which Swift’s extensions can be used include far more advanced concepts that simply adding new properties and methods to external objects, which in turn makes them one of the most powerful and versatile features that the language has to offer. This week, let’s explore some of those aspects, and the kind of patterns and techniques that they enable us to adopt.</p><h2>Existing types, new functionality</h2><p>Let’s start with the basics. One way to use extensions is to add new, custom APIs to the various types that ship as part of the system, for example within the Swift standard library. As an example, let’s say that we’re working on an app which logic requires us to access specific elements within various arrays — so to avoid having to always check if the index that we’re looking to access is within a given array’s bounds, we could add the following method that does that work for us:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Array</span> {\n    <span class=\"s-keyword\">func</span> element(at index: <span class=\"s-type\">Int</span>) -&gt; <span class=\"s-type\">Element</span>? {\n        <span class=\"s-keyword\">guard</span> index &gt;= <span class=\"s-number\">0</span>, index &lt; count <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return nil</span>\n        }\n\n        <span class=\"s-keyword\">return self</span>[index]\n    }\n}</code></pre><p>That’s already quite powerful, as we’ll now be able to use the above method on <em>any</em> <code>Array</code> within our code base, but what’s perhaps even more powerful is the fact that we could also have made the above extension target the <code>RandomAccessCollection</code> protocol instead.</p><p>Since <code>RandomAccessCollection</code> defines the requirements for collections that provide <em>random access</em> to its elements, extending that protocol (rather than the concrete <code>Array</code> type) would let us use our new method on any such collection, including <code>Array</code> itself:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">RandomAccessCollection</span> {\n    <span class=\"s-keyword\">func</span> element(at index: <span class=\"s-type\">Index</span>) -&gt; <span class=\"s-type\">Element</span>? {\n        <span class=\"s-keyword\">guard</span> indices.<span class=\"s-call\">contains</span>(index) <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return nil</span>\n        }\n\n        <span class=\"s-keyword\">return self</span>[index]\n    }\n}</code></pre><p>With the above in place, we’ll now be able to call our new method on types like <code>Array</code>, <code>ArraySlice</code> and <code>Range</code>, all using one single implementation:</p><pre class=\"splash\"><code><span class=\"s-comment\">// Extracting an optional element from an Array</span>\n<span class=\"s-keyword\">guard let</span> fifthElement = array.<span class=\"s-call\">element</span>(at: <span class=\"s-number\">4</span>) <span class=\"s-keyword\">else</span> {\n    <span class=\"s-keyword\">return</span>\n}\n\n<span class=\"s-comment\">// Doing the same thing, but using an ArraySlice instead:</span>\n<span class=\"s-keyword\">let</span> slice = array[<span class=\"s-number\">0</span>..&lt;<span class=\"s-number\">3</span>]\n\n<span class=\"s-keyword\">guard let</span> secondElement = slice.<span class=\"s-call\">element</span>(at: <span class=\"s-number\">1</span>) <span class=\"s-keyword\">else</span> {\n    <span class=\"s-keyword\">return</span>\n}\n\n<span class=\"s-comment\">// We could also use our new method with types like Range:</span>\n<span class=\"s-keyword\">guard let</span> thirdValue = range.<span class=\"s-call\">element</span>(at: <span class=\"s-number\">2</span>) <span class=\"s-keyword\">else</span> {\n    <span class=\"s-keyword\">return</span>\n}</code></pre><p>So, when it’s possible and practical to do so, extending protocols (rather than concrete types) gives us a lot more flexibility, as we’ll be able to use the methods and properties that we add with a much wider range of types.</p><p>However, not all extensions that we’ll end up adding are going to be as general-purpose as the one above, so although we might still opt for the protocol-based approach, we could also apply <em>constraints</em> to make such an extension more specific.</p><p>For example, the following extension adds a method that lets us calculate the total price for a sequence of products, and by using a <em>same type constraint</em> we can establish a compile-time guarantee that this method will only ever be called on <code>Sequence</code>-conforming types that contain <code>Product</code> values:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Element</span> == <span class=\"s-type\">Product</span> {\n    <span class=\"s-keyword\">func</span> totalPrice() -&gt; <span class=\"s-type\">Int</span> {\n        <span class=\"s-call\">reduce</span>(<span class=\"s-number\">0</span>) { price, product <span class=\"s-keyword\">in</span>\n            price + product.<span class=\"s-property\">price</span>\n        }\n    }\n}</code></pre><p class=\"info\">The above API is defined as a method, rather than a computed property, since it has <code>O(n)</code> <a href=\"https://www.swiftbysundell.com/basics/time-complexity\">time complexity</a>. For more details, check out <a href=\"https://www.swiftbysundell.com/articles/computed-properties-in-swift\">“Computed properties in Swift”</a>.</p><p>One thing that’s really cool is that constraints can not only refer to concrete types and protocols, but also to closure types as well — which lets us do things like add a method that calls all closures within a given sequence, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Element</span> == () -&gt; <span class=\"s-type\">Void</span> {\n    <span class=\"s-keyword\">func</span> callAll() {\n        <span class=\"s-call\">forEach</span> { closure <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">closure</span>()\n        }\n    }\n}</code></pre><p>Swift 5.3 takes the above capability even further, by enabling us to now also apply constraints to individual methods declarations that refer to their enclosing type. That lets us create a second overload of the above method that accepts an argument matching the input type of the closures that are contained within the sequence:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Sequence</span> {\n    <span class=\"s-keyword\">func</span> callAll&lt;T&gt;(with input: <span class=\"s-type\">T</span>) <span class=\"s-keyword\">where</span> <span class=\"s-type\">Element</span> == (<span class=\"s-type\">T</span>) -&gt; <span class=\"s-type\">Void</span> {\n        <span class=\"s-call\">forEach</span> { closure <span class=\"s-keyword\">in</span>\n            <span class=\"s-call\">closure</span>(input)\n        }\n    }\n}</code></pre><p>The above new method could become very useful in situations where we want to pass the same value to a number of different closures — for example in order to notify all observers that an <code>Observable</code> type’s <code>value</code> was changed:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> Observable&lt;Value&gt; {\n    <span class=\"s-keyword\">var</span> value: <span class=\"s-type\">Value</span> {\n        <span class=\"s-keyword\">didSet</span> { observations.<span class=\"s-call\">callAll</span>(with: value) }\n    }\n\n    <span class=\"s-keyword\">private var</span> observations = [(<span class=\"s-type\">Value</span>) -&gt; <span class=\"s-type\">Void</span>]()\n\n    ...\n}</code></pre><p class=\"info\">For more on the observer pattern, check out the two-part article <a href=\"https://www.swiftbysundell.com/articles/observers-in-swift-part-1\">“Observers in Swift”</a>.</p><p>The examples that we’ve explored so far have definitely all been non-essential convenience APIs — however, when tactically deployed, those kinds of APIs can often help us reduce both the verbosity and repetitiveness of our code, and continuously make a project easier to work with over time.</p><h2>Organizing APIs and protocol conformances</h2><p>Extensions are also commonly used as a code organization tool, which is a practice that Swift inherited from its predecessor, Objective-C. Since Objective-C’s version of extensions — categories — support giving each extension an explicit name, they’ve often been used to group a series of APIs together based on what kind of functionality that they provide.</p><p>In Swift, we could use that same approach to structure a given type’s APIs based on their <em><a href=\"https://www.swiftbysundell.com/basics/access-control\">access level</a></em>. Let’s take a look at an example from <a href=\"https://github.com/JohnSundell/Publish\">Publish</a>, the static site generator used to build this very website, in which a <a href=\"https://github.com/JohnSundell/Publish/blob/master/Sources/Publish/API/Section.swift\"><code>Section</code></a> type uses a series of extensions to form groups containing its <code>public</code>, <code>internal</code> and <code>private</code> APIs:</p><pre class=\"splash\"><code><span class=\"s-keyword\">public struct</span> Section&lt;Site: <span class=\"s-type\">Website</span>&gt;: <span class=\"s-type\">Location</span> {\n    <span class=\"s-keyword\">public let</span> id: <span class=\"s-type\">Site</span>.<span class=\"s-type\">SectionID</span>\n    <span class=\"s-keyword\">public private(set) var</span> items = [<span class=\"s-type\">Item</span>&lt;<span class=\"s-type\">Site</span>&gt;]()\n    ...\n}\n\n<span class=\"s-keyword\">public extension</span> <span class=\"s-type\">Section</span> {\n    <span class=\"s-keyword\">func</span> item(at path: <span class=\"s-type\">Path</span>) -&gt; <span class=\"s-type\">Item</span>&lt;<span class=\"s-type\">Site</span>&gt;? {\n        ...\n    }\n    \n    <span class=\"s-keyword\">func</span> items(taggedWith tag: <span class=\"s-type\">Tag</span>) -&gt; [<span class=\"s-type\">Item</span>&lt;<span class=\"s-type\">Site</span>&gt;] {\n        ...\n    }\n    \n    ...\n}\n\n<span class=\"s-keyword\">internal extension</span> <span class=\"s-type\">Section</span> {\n    <span class=\"s-keyword\">mutating func</span> addItem(<span class=\"s-keyword\">_</span> item: <span class=\"s-type\">Item</span>&lt;<span class=\"s-type\">Site</span>&gt;) {\n        ...\n    }\n}\n\n<span class=\"s-keyword\">private extension</span> <span class=\"s-type\">Section</span> {\n    ...\n    \n    <span class=\"s-keyword\">mutating func</span> rebuildIndexes() {\n        ...\n    }\n}</code></pre><p>Besides the organizational aspects, one benefit of the above approach is that we no longer have to give each method or property an explicit access level, as each API will automatically inherit the access level of its enclosing extension.</p><p>We could also follow the above pattern when conforming to protocols as well, as we’re able to attach such a conformance to any extension that we’ll define. For example, here we’re making a <code>ListViewController</code> conform to UIKit’s <code>UITableViewDelegate</code> protocol through such an extension:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ListViewController</span>: <span class=\"s-type\">UITableViewDelegate</span> {\n    <span class=\"s-keyword\">func</span> tableView(<span class=\"s-keyword\">_</span> tableView: <span class=\"s-type\">UITableView</span>,\n                   didSelectRowAt indexPath: <span class=\"s-type\">IndexPath</span>) {\n        <span class=\"s-keyword\">let</span> item = items[indexPath.<span class=\"s-property\">item</span>]\n        <span class=\"s-call\">showDetailViewController</span>(for: item)\n    }\n    \n    ...\n}</code></pre><p>Just like how we previously applied constraints when defining extensions containing custom methods and properties, we can do the same thing when extending a given type to conform to a protocol as well, which is especially useful when it comes to <em>wrapper types</em> — such as the generic <code>NetworkResponse</code> wrapper from <a href=\"https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift\">“Creating generic networking APIs in Swift”</a>.</p><p>Here we’re making that wrapper type conditionally conform to protocols like <code>Equatable</code> and <code>Hashable</code> only when its <code>Wrapped</code> type also conforms to those protocols:</p><pre class=\"splash\"><code><span class=\"s-comment\">// The compiler can still automatically generate the code required\n// to conform to protocols like Equatable and Hashable even when\n// adding those conformances through extensions:</span>\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">NetworkResponse</span>: <span class=\"s-type\">Equatable</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Wrapped</span>: <span class=\"s-type\">Equatable</span> {}\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">NetworkResponse</span>: <span class=\"s-type\">Hashable</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Wrapped</span>: <span class=\"s-type\">Hashable</span> {}\n\n<span class=\"s-comment\">// Most protocols will probably require us to write some form of\n// bridging code ourselves, though. For example, here we make our\n// network response use its wrapped type's description when it's\n// being converted into a string, rather than defining its own:</span>\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">NetworkResponse</span>: <span class=\"s-type\">CustomStringConvertible</span>\n    <span class=\"s-keyword\">where</span> <span class=\"s-type\">Wrapped</span>: <span class=\"s-type\">CustomStringConvertible</span> {\n\n    <span class=\"s-keyword\">var</span> description: <span class=\"s-type\">String</span> {\n        result.<span class=\"s-property\">description</span>\n    }\n}</code></pre><p>So extensions can also prove to be an incredibly useful tool when organizing a given type by splitting it up according to the access level or functionality of its various APIs, or when we want to make a type conform to a protocol, either with or without constraints.</p><h2>Specializing generics</h2><p>Finally, let’s take a look at how extensions can also be used to specialize generic types and protocols for concrete use cases.</p><p>Just like the <code>Sequence</code> and <code>RandomAccessCollection</code> protocols that we previously extended with convenience APIs, several of Apple’s most modern frameworks make heavy use of generics in order to make their APIs both flexible and fully type-safe. For example, all of <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine’s</a> various publishers are implemented using the <code>Publisher</code> protocol, which contains generic types that define what <code>Output</code> that a given publisher produces, as well as what sort of <code>Failure</code> error that might be emitted.</p><p>Those two generic types in turn enable us to write extensions that contain completely custom Combine operators — such as the following one that makes any publisher emit unified <a href=\"https://www.swiftbysundell.com/basics/result\"><code>Result</code></a> values, rather than separate ones for its output and errors:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Publisher</span> {\n    <span class=\"s-keyword\">func</span> asResult() -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Output</span>, <span class=\"s-type\">Failure</span>&gt;, <span class=\"s-type\">Never</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-call\">map</span>(<span class=\"s-type\">Result</span>.<span class=\"s-property\">success</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(.<span class=\"s-call\">failure</span>(error))\n            }\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p class=\"info\">To learn more about the <code>Just</code> publisher that’s used above, check out <a href=\"https://www.swiftbysundell.com/tips/constant-combine-publishers\">“Publishing constant values using Combine”</a>.</p><p>The above extension then lets us write Combine pipelines like the one used by the following <code>AsyncValue</code>, which assign their output directly to a <code>Result</code>-based property — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> AsyncValue&lt;Value: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> result: <span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Value</span>, <span class=\"s-type\">Error</span>&gt;?\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    <span class=\"s-keyword\">func</span> load(from url: <span class=\"s-type\">URL</span>,\n              using session: <span class=\"s-type\">URLSession</span> = .<span class=\"s-dotAccess\">shared</span>,\n              decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>()) {\n        cancellable = session.<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">Value</span>.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">asResult</span>()\n            .<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n                self</span>?.<span class=\"s-property\">result</span> = result\n            }\n    }\n}</code></pre><p>Combining the above approach with generic type constraints also lets us take advantage of Swift’s powerful type inference capabilities, which is something that SwiftUI makes <em>heavy</em> use of when defining convenience APIs for its various built-in views.</p><p>As an example, let’s say that an app that we’re working on contains an <code>IconView</code> that renders an icon from a pre-defined set. To make it easy to create a <code>Button</code> containing such an icon, we could write the following extension — which uses a same type constraint on the generic <code>Label</code> type that defines what sort of content view that a given <code>Button</code> is rendering:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Button</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Label</span> == <span class=\"s-type\">IconView</span> {\n    <span class=\"s-keyword\">init</span>(icon: <span class=\"s-type\">Icon</span>, action: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Void</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(action: action, label: {\n            <span class=\"s-type\">IconView</span>(icon: icon)\n        })\n    }\n}</code></pre><p>The cool thing is that we can now simply use the above API to create a <code>Button</code> instance, and the compiler will automatically infer that we wish to use <code>IconView</code> as that button’s <code>Label</code> type — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ProductView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ProductViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            ...\n            <span class=\"s-type\">Button</span>(icon: .<span class=\"s-dotAccess\">shoppingCart</span>) {\n                viewModel.<span class=\"s-call\">performPurchase</span>()\n            }\n        }\n    }\n}</code></pre><p class=\"info\">For more options on how to style SwiftUI views, check out <a href=\"https://www.swiftbysundell.com/articles/encapsulating-swiftui-view-styles\">“Encapsulating SwiftUI view styles”</a>.</p><p>The above pattern is also used all throughout <a href=\"https://github.com/JohnSundell/Plot\">Plot</a>, which is the HTML <a href=\"https://www.swiftbysundell.com/articles/building-dsls-in-swift\">DSL</a> that’s used to define themes for Publish-based websites. When using Plot, each HTML element is defined using a generic <code>Node</code> type, which in turn uses <a href=\"https://www.swiftbysundell.com/articles/phantom-types-in-swift\">phantom types</a> to ensure that each element is placed within a valid context. Then, each built-in element and component is created just like how we defined our SwiftUI convenience API above — using constrained extensions:</p><pre class=\"splash\"><code><span class=\"s-keyword\">public extension</span> <span class=\"s-type\">Node</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Context</span>: <span class=\"s-type\">HTML</span>.<span class=\"s-type\">BodyContext</span> {\n    <span class=\"s-keyword\">static func</span> a(<span class=\"s-keyword\">_</span> nodes: <span class=\"s-type\">Node</span>&lt;<span class=\"s-type\">HTML</span>.<span class=\"s-type\">AnchorContext</span>&gt;...) -&gt; <span class=\"s-type\">Node</span> {\n        .<span class=\"s-call\">element</span>(named: <span class=\"s-string\">\"a\"</span>, nodes: nodes)\n    }\n    \n    ...\n    \n    <span class=\"s-keyword\">static func</span> div(<span class=\"s-keyword\">_</span> nodes: <span class=\"s-type\">Node</span>&lt;<span class=\"s-type\">HTML</span>.<span class=\"s-type\">BodyContext</span>&gt;...) -&gt; <span class=\"s-type\">Node</span> {\n        .<span class=\"s-call\">element</span>(named: <span class=\"s-string\">\"div\"</span>, nodes: nodes)\n    }\n    \n    ...\n}</code></pre><p>Similar to our earlier SwiftUI-based example, the compiler is then able to automatically infer what type of <code>Node</code> that we’re looking to create purely based on the static method call used to create it:</p><pre class=\"splash\"><code><span class=\"s-comment\">// The type of this value will be Node&lt;HTML.BodyContext&gt;, which\n// the compiler will infer based on our method call:</span>\n<span class=\"s-keyword\">let</span> div = <span class=\"s-type\">Node</span>.<span class=\"s-call\">div</span>(.<span class=\"s-call\">a</span>(.<span class=\"s-call\">href</span>(<span class=\"s-string\">\"https://swiftbysundell.com\"</span>)))</code></pre><p>The beauty of the above capabilities is that they let us model various domains in very advanced, strongly typed ways — while still making our call sites as simple as possible, as we don’t always need to specify each underlying generic type manually.</p><h2>Conclusion</h2><p>While extensions might, at first glance, seem like one of Swift’s simpler features, once we start diving into all of the various patterns and capabilities that they enable us to adopt, they can actually turn out to be one of the <em>most powerful</em> features that the language has to offer.</p><p>Extensions give us the flexibility to add new features to existing types, to conditionally enable certain methods or properties to be used on either a type or a protocol, and to craft strongly typed APIs that remain easy to use. I hope that this article has given you a comprehensive overview of the sort of things that Swift’s extensions can do, and if you have any questions, comments, or feedback, then please reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "An overview of the sort of patterns and techniques that Swift’s extensions enable us to adopt, and how extensions can turn out to be one of the most powerful features that the language has to offer.",
      "date_published": "2020-10-18T18:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/constant-combine-publishers",
      "url": "https://www.swiftbysundell.com/tips/constant-combine-publishers",
      "title": "Publishing constant values using Combine",
      "content_html": "<p>Although Combine is definitely the most useful when it comes to building highly dynamic data pipelines for publishing streams of values over time, sometimes we might also want to use it to emit <em>constant</em> values as well.</p><p>As an example, let’s say that we’re working on an app that includes an <code>ImageLoader</code> class for downloading remote images over the network. To do that, we’re using the Combine version of Foundation’s <code>URLSession</code> API, along with a series of operators for decoding our downloaded data into <code>UIImage</code> instances — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ImageLoader {\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n\n    <span class=\"s-keyword\">init</span>(urlSession: <span class=\"s-type\">URLSession</span> = .<span class=\"s-dotAccess\">shared</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">urlSession</span> = urlSession\n    }\n\n    <span class=\"s-keyword\">func</span> publisher(for url: <span class=\"s-type\">URL</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">tryMap</span> { data <span class=\"s-keyword\">in\n                guard let</span> image = <span class=\"s-type\">UIImage</span>(data: data) <span class=\"s-keyword\">else</span> {\n                    <span class=\"s-keyword\">throw</span> <span class=\"s-type\">URLError</span>(.<span class=\"s-dotAccess\">badServerResponse</span>, userInfo: [\n                        <span class=\"s-type\">NSURLErrorFailingURLErrorKey</span>: url\n                    ])\n                }\n\n                <span class=\"s-keyword\">return</span> image\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p class=\"info\">Note how we’re jumping over to the <code>main</code> queue at the end of our Combine pipeline, since the images downloaded using our <code>ImageLoader</code> are highly likely to be rendered using either a <code>UIImageView</code> or a SwiftUI <code>Image</code>, both of which are main-queue-only APIs.</p><p>Now, let’s say that we wanted to add local, in-memory caching to the above <code>ImageLoader</code>, for example using another Foundation class — <code>NSCache</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ImageLoader {\n    <span class=\"s-keyword\">private let</span> urlSession: <span class=\"s-type\">URLSession</span>\n    <span class=\"s-keyword\">private let</span> cache: <span class=\"s-type\">NSCache</span>&lt;<span class=\"s-type\">NSURL</span>, <span class=\"s-type\">UIImage</span>&gt;\n\n    <span class=\"s-keyword\">init</span>(urlSession: <span class=\"s-type\">URLSession</span> = .<span class=\"s-dotAccess\">shared</span>,\n         cache: <span class=\"s-type\">NSCache</span>&lt;<span class=\"s-type\">NSURL</span>, <span class=\"s-type\">UIImage</span>&gt; = .<span class=\"s-keyword\">init</span>()) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">urlSession</span> = urlSession\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">cache</span> = cache\n    }\n\n    ...\n}</code></pre><p class=\"info\">We need to use Objective-C’s <code>NSURL</code>, rather than Swift’s own <code>URL</code>, as our cache’s key type, since <code>NSCache</code> only supports Objective-C compatible types. To learn more about caching in general, check out <a href=\"https://www.swiftbysundell.com/articles/caching-in-swift\">“Caching in Swift”</a>.</p><p>With our cache injected and stored, we now need to do two things — cache all images that were downloaded, and check the cache for an existing image before starting a given download. The first can be accomplished by using the <code>handleEvents</code> operator at the end of our existing Combine pipeline — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ImageLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> publisher(for url: <span class=\"s-type\">URL</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">tryMap</span> { data <span class=\"s-keyword\">in</span>\n                ...\n            }\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">handleEvents</span>(receiveOutput: { [cache] image <span class=\"s-keyword\">in</span>\n                cache.<span class=\"s-call\">setObject</span>(image, forKey: url <span class=\"s-keyword\">as</span> <span class=\"s-type\">NSURL</span>)\n            })\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>For the second task (retrieving images from the cache), we’re going to need a <em>separate</em> pipeline from the one used for downloading, since we don’t wish to kick off any network calls if a cached image exists.</p><p>This is where Combine’s constant value API comes very much in handy, since it enables us to construct a pipeline with just a single value — using the appropriately named <code>Just</code> publisher. Here’s how we might use that publisher to directly return any cached image that was found for a given URL:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ImageLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> publisher(for url: <span class=\"s-type\">URL</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">if let</span> image = cache.<span class=\"s-call\">object</span>(forKey: url <span class=\"s-keyword\">as</span> <span class=\"s-type\">NSURL</span>) {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Just</span>(image)\n                .<span class=\"s-call\">setFailureType</span>(to: <span class=\"s-type\">Error</span>.<span class=\"s-keyword\">self</span>)\n                .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n                .<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        ...\n    }\n}</code></pre><p>Note how we need to explicitly set <code>Error</code> as our <code>Just</code> publisher’s failure type, since constant publishers aren’t capable of emitting errors by default. We also still want to always return our result on the main queue, even for constant values, to give our API complete consistency around what <code>DispatchQueue</code> that it emits values on.</p><p>Finally, Combine also offers a way to emit constant <em>errors</em> as well, by using the built-in <code>Fail</code> publisher. Here’s an example showing how we might use that API to directly return an error in case an image with a non-<code>HTTPS</code> URL was requested:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ImageLoader {\n    ...\n\n    <span class=\"s-keyword\">func</span> publisher(for url: <span class=\"s-type\">URL</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">UIImage</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">guard</span> url.<span class=\"s-property\">scheme</span> == <span class=\"s-string\">\"https\"</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Fail</span>(error: <span class=\"s-type\">URLError</span>(.<span class=\"s-dotAccess\">badURL</span>, userInfo: [\n                <span class=\"s-type\">NSLocalizedFailureReasonErrorKey</span>: <span class=\"s-string\">\"\"\"\n                Image loading may only be performed over HTTPS\n                \"\"\"</span>,\n                <span class=\"s-type\">NSURLErrorFailingURLErrorKey</span>: url\n            ]))\n            .<span class=\"s-call\">receive</span>(on: <span class=\"s-type\">DispatchQueue</span>.<span class=\"s-property\">main</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        ...\n    }\n}</code></pre><p>The <code>Just</code> and <code>Fail</code> publishers are also incredibly useful for unit testing as well, as they enable us to easily set up a Combine pipeline with either a mocked value or error.</p>",
      "date_published": "2020-10-15T14:55:00.000Z"
    },
    {
      "guid": "swiftbysundell/links/building-a-unit-testing-suite-with-xctest-swift-and-bitrise",
      "url": "https://blog.bitrise.io/building-a-unit-testing-suite-with-xctest-swift-and-bitrise",
      "title": "Link: Building a unit testing suite with XCTest, Swift, and Bitrise",
      "content_html": "<p>Unit testing can be a fantastic tool for verifying that an app’s various pieces of logic keep working as expected even as they’re being iterated on. However, if a given project only has a very limited amount of tests in place, or if there are no tests at all, then it can often be difficult to know where to start.</p><p>So, in my latest guest article on the Bitrise blog, I take a look at a few different angles that we can approach this kind of testing from, and how each of those approaches can provide a great starting point for either extending or getting started with building a comprehensive unit testing suite for a Swift app.</p><p><strong><a href=\"https://blog.bitrise.io/building-a-unit-testing-suite-with-xctest-swift-and-bitrise\">Read the full article on the Bitrise blog</a></strong></p>",
      "date_published": "2020-10-12T15:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/strings-october-2020",
      "url": "https://www.swiftbysundell.com/sponsor/strings-october-2020",
      "title": "Sponsor: Strings",
      "content_html": "<p>Thanks a lot to the team behind <a href=\"https://www.strings.design/developers?utm_source=Swift%20by%20Sundell&utm_medium=email&utm_campaign=Swift%20by%20Sundell\">Strings</a> for sponsoring Swift by Sundell this past week. Their support is helping me keep the website and all of its content free and accessible to everyone.</p><p>I’m a big fan of tools that help bridge the gap between the different disciplines that are involved in building a truly great app, and <a href=\"https://www.strings.design/developers?utm_source=Swift%20by%20Sundell&utm_medium=email&utm_campaign=Swift%20by%20Sundell\">Strings</a> is definitely one of those tools — as it makes it easy to enable copywriters to directly update your app’s localized strings, without requiring them to clone and update the project’s various Xcode files.</p><p>Simply set up your project with Strings, and it will give the people working on your app’s localization and copy a very writer-friendly, web-based UI for them to use — but here’s the trick, it will then also automatically create Pull Requests for the changes that they’ll make, which you can then approve and merge into your project’s repository.</p><p>So if you’re often getting requests for string changes in tasks, emails, on Slack, or in bug comments — then I can really recommend trying out Strings. It’s free to try, and by using <a href=\"https://www.strings.design/developers?utm_source=Swift%20by%20Sundell&utm_medium=email&utm_campaign=Swift%20by%20Sundell\">this link to check out Strings</a>, then you also directly help support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to Strings for sponsoring Swift by Sundell.",
      "date_published": "2020-10-12T10:05:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/handling-loading-states-in-swiftui",
      "url": "https://www.swiftbysundell.com/articles/handling-loading-states-in-swiftui",
      "title": "Handling loading states within SwiftUI views",
      "content_html": "<p>When building any kind of modern app, chances are incredibly high that, at one point or another, we’ll need to load some form of data asynchronously. It could be by fetching a given view’s content over the network, by reading a file on a background thread, or by performing a database operation, just to name a few examples.</p><p>One of the most important aspects of that kind of asynchronous work, at least when it comes to building UI-based apps, is figuring out how to reliably update our various views according to the current state of the background operations that we’ll perform. So this week, let’s take a look at a few different options on how to do just that when building views using SwiftUI.</p><h2>Self-loading views</h2><p>When working with Apple’s previous UI frameworks, UIKit and AppKit, it’s been really common to perform view-related loading tasks within the view controllers that make up an app’s overall UI structure. So, when transitioning to SwiftUI, an initial idea might be to follow the same kind of pattern, and let each top-level <code>View</code> type be responsible for loading its own data.</p><p>For example, the following <code>ArticleView</code> gets injected with the <code>ID</code> of the article that it should display, and then uses an <code>ArticleLoader</code> instance to load that model — the result of which is stored in a local <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#state-properties\"><code>@State</code></a> property:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> articleID: <span class=\"s-type\">Article</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">var</span> loader: <span class=\"s-type\">ArticleLoader</span>\n    \n    <span class=\"s-keyword\">@State private var</span> result: <span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Article</span>, <span class=\"s-type\">Error</span>&gt;?\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        ...\n    }\n    \n    <span class=\"s-keyword\">private func</span> loadArticle() {\n        loader.<span class=\"s-call\">loadArticle</span>(withID: articleID) {\n            result = $0\n        }\n    }\n}</code></pre><p>Within the above view’s <code>body</code> property, we could then switch on our current <code>result</code> value, and construct our UI accordingly — which gives us the following implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> articleID: <span class=\"s-type\">Article</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">var</span> loader: <span class=\"s-type\">ArticleLoader</span>\n    \n    <span class=\"s-keyword\">@State private var</span> result: <span class=\"s-type\">Result</span>&lt;<span class=\"s-type\">Article</span>, <span class=\"s-type\">Error</span>&gt;?\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">switch</span> result {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> article):\n            <span class=\"s-comment\">// Rendering our article content within a scroll view:</span>\n            <span class=\"s-type\">ScrollView</span> {\n                <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">20</span>) {\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">title</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">body</span>)\n                }\n                .<span class=\"s-call\">padding</span>()\n            }\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-comment\">// Showing any error that was encountered using a\n            // dedicated ErrorView, which runs a given closure\n            // when the user tapped an embedded \"Retry\" button:</span>\n            <span class=\"s-type\">ErrorView</span>(error: error, retryHandler: loadArticle)\n        <span class=\"s-keyword\">case nil</span>:\n            <span class=\"s-comment\">// We display a classic loading spinner while we're\n            // waiting for our content to load, and we start our\n            // loading operation once that view appears:</span>\n            <span class=\"s-type\">ProgressView</span>().<span class=\"s-call\">onAppear</span>(perform: loadArticle)\n        }\n    }\n\n    <span class=\"s-keyword\">private func</span> loadArticle() {\n        loader.<span class=\"s-call\">loadArticle</span>(withID: articleID) {\n            result = $0\n        }\n    }\n}</code></pre><p>It could definitely be argued that the above pattern works perfectly fine for simpler views — however, mixing view code with tasks like data loading and networking is not really considered a good practice, as doing so tends to lead to quite messy and intertwined implementations over time.</p><h2>View models</h2><p>So let’s separate those concerns instead. One way of doing so would be to introduce a <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-view-models-in-swift\">view model companion</a> to the above <code>ArticleView</code>, which could take on tasks like data loading and state management, letting our view remain focused on what views do best — rendering our UI.</p><p>In this case, let’s implement an <code>ArticleViewModel</code>, which’ll act as an <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-objects\"><code>ObservableObject</code></a> by publishing a <code>state</code> property. We’ll reuse our existing <code>ArticleLoader</code> from before to perform our actual loading, which we’ll implement within a dedicated <code>load</code> method (since we don’t want our initializer to trigger side-effects like networking):</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ArticleViewModel: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">enum</span> State {\n        <span class=\"s-keyword\">case</span> idle\n        <span class=\"s-keyword\">case</span> loading\n        <span class=\"s-keyword\">case</span> failed(<span class=\"s-type\">Error</span>)\n        <span class=\"s-keyword\">case</span> loaded(<span class=\"s-type\">Article</span>)\n    }\n\n    <span class=\"s-keyword\">@Published private(set) var</span> state = <span class=\"s-type\">State</span>.<span class=\"s-property\">idle</span>\n    \n    <span class=\"s-keyword\">private let</span> articleID: <span class=\"s-type\">Article</span>.<span class=\"s-type\">ID</span>\n    <span class=\"s-keyword\">private let</span> loader: <span class=\"s-type\">ArticleLoader</span>\n\n    <span class=\"s-keyword\">init</span>(articleID: <span class=\"s-type\">Article</span>.<span class=\"s-type\">ID</span>, loader: <span class=\"s-type\">ArticleLoader</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">articleID</span> = articleID\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">loader</span> = loader\n    }\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        loader.<span class=\"s-call\">loadArticle</span>(withID: articleID) { [<span class=\"s-keyword\">weak self</span>] result <span class=\"s-keyword\">in\n            switch</span> result {\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">success</span>(<span class=\"s-keyword\">let</span> article):\n                <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">state</span> = .<span class=\"s-call\">loaded</span>(article)\n            <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n                <span class=\"s-keyword\">self</span>?.<span class=\"s-property\">state</span> = .<span class=\"s-call\">failed</span>(error)\n            }\n        }\n    }\n}</code></pre><p>With the above in place, we can now have our <code>ArticleView</code> contain just a single property — its view model — and by observing it using the <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide/#observing-objects\"><code>@ObservedObject</code></a> attribute, we can then simply switch on its <code>state</code> property within our view’s body in order to render our UI according to the current state:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">switch</span> viewModel.<span class=\"s-property\">state</span> {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">idle</span>:\n            <span class=\"s-comment\">// Render a clear color and start the loading process\n            // when the view first appears, which should make the\n            // view model transition into its loading state:</span>\n            <span class=\"s-type\">Color</span>.<span class=\"s-property\">clear</span>.<span class=\"s-call\">onAppear</span>(perform: viewModel.<span class=\"s-property\">load</span>)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loading</span>:\n            <span class=\"s-type\">ProgressView</span>()\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failed</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-type\">ErrorView</span>(error: error, retryHandler: viewModel.<span class=\"s-property\">load</span>)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loaded</span>(<span class=\"s-keyword\">let</span> article):\n            <span class=\"s-type\">ScrollView</span> {\n                <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">20</span>) {\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">title</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">body</span>)\n                }\n                .<span class=\"s-call\">padding</span>()\n            }\n        }\n    }\n}</code></pre><p>That’s already quite a substantial improvement when it comes to separation of concerns and <a href=\"https://www.swiftbysundell.com/articles/code-encapsulation-in-swift\">code encapsulation</a>, as we’ll now be able to keep iterating on our model and networking logic without having to update our view, and vice versa.</p><p>But let’s see if we can take things a bit further, shall we?</p><h2>A generic concept</h2><p>Depending on what kind of app that we’re working on, chances are quite high that we won’t just have <em>one</em> view that relies on asynchronously loaded data. Instead, it’s likely a pattern that’s repeated throughout our code base, which in turn makes it an ideal candidate for generalization.</p><p>If we think about it, the <code>State</code> enum that we previously nested within our <code>ArticleViewModel</code> doesn’t really have much to do with loading articles at all, but is instead a quite generic encapsulation of the various states that <em>any</em> asynchronous loading operation can end up in. So, let’s actually turn it into just that, by first extracting it out from our view model, and by then converting it into a generic <code>LoadingState</code> type — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">enum</span> LoadingState&lt;Value&gt; {\n    <span class=\"s-keyword\">case</span> idle\n    <span class=\"s-keyword\">case</span> loading\n    <span class=\"s-keyword\">case</span> failed(<span class=\"s-type\">Error</span>)\n    <span class=\"s-keyword\">case</span> loaded(<span class=\"s-type\">Value</span>)\n}</code></pre><p>Along those same lines, if we end up following the view model-based architecture that we started using within our <code>ArticleView</code> all throughout our app, then we’re highly likely to end up with a number of different view model implementations that all have a published <code>state</code> property and a <code>load</code> method. So, let’s also turn those aspects into a more generic API as well — this time by creating a protocol called <code>LoadableObject</code> that we’ll be able to use as a shared abstraction for those capabilities:</p><pre class=\"splash\"><code><span class=\"s-keyword\">protocol</span> LoadableObject: <span class=\"s-type\">ObservableObject</span> {\n    <span class=\"s-keyword\">associatedtype</span> Output\n    <span class=\"s-keyword\">var</span> state: <span class=\"s-type\">LoadingState</span>&lt;<span class=\"s-type\">Output</span>&gt; { <span class=\"s-keyword\">get</span> }\n    <span class=\"s-keyword\">func</span> load()\n}</code></pre><p class=\"info\">Note how we can’t strictly require each implementation of the above protocol to annotate its <code>state</code> property with <code>@Published</code>, but we <em>can</em> require each conforming type to be an <code>ObservableObject</code>.</p><p>With the above pieces in place, we now have everything needed to create a truly generic view for loading and displaying asynchronously loaded content. Let’s call it <code>AsyncContentView</code>, and make it use a <code>LoadableObject</code> implementation as its <code>Source</code>, and then have it call an injected <code>content</code> closure in order to transform the output of that loadable object into a SwiftUI view — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AsyncContentView&lt;Source: <span class=\"s-type\">LoadableObject</span>, Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> source: <span class=\"s-type\">Source</span>\n    <span class=\"s-keyword\">var</span> content: (<span class=\"s-type\">Source</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">switch</span> source.<span class=\"s-property\">state</span> {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">idle</span>:\n            <span class=\"s-type\">Color</span>.<span class=\"s-property\">clear</span>.<span class=\"s-call\">onAppear</span>(perform: source.<span class=\"s-property\">load</span>)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loading</span>:\n            <span class=\"s-type\">ProgressView</span>()\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failed</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-type\">ErrorView</span>(error: error, retryHandler: source.<span class=\"s-property\">load</span>)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loaded</span>(<span class=\"s-keyword\">let</span> output):\n            <span class=\"s-call\">content</span>(output)\n        }\n    }\n}</code></pre><p>While the above implementation will work perfectly fine as long as we’re always just returning a single view expression within each <code>content</code> closure, if we wanted to, we could also annotate that closure with SwiftUI’s <code>@ViewBuilder</code> attribute — which would enable us to use the full power of <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api\">SwiftUI’s DSL</a> within such closures:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AsyncContentView&lt;Source: <span class=\"s-type\">LoadableObject</span>, Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> source: <span class=\"s-type\">Source</span>\n    <span class=\"s-keyword\">var</span> content: (<span class=\"s-type\">Source</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">init</span>(source: <span class=\"s-type\">Source</span>,\n         <span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Source</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">source</span> = source\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">content</span> = content\n    }\n    \n    ...\n}</code></pre><p class=\"info\">Note how we (currently) need to implement a dedicated initializer if we wish to add view building capabilities to a closure, since it can’t be applied directly to a closure-based property. To learn more about what adding those capabilities enables us to do, check out articles like <a href=\"https://www.swiftbysundell.com/tips/adding-swiftui-viewbuilder-to-functions\">“Adding SwiftUI’s ViewBuilder attribute to functions”</a> and <a href=\"https://www.swiftbysundell.com/articles/how-swift-5-3-enhances-swiftui-dsl\">“How Swift 5.3 enhances SwiftUI’s DSL”</a>.</p><p>With our <code>AsyncContentView</code> completed, let’s now make our <code>ArticleView</code> from before use it — which once again lets us simplify its implementation by handing off parts of its required work to other, dedicated types:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleViewModel</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">AsyncContentView</span>(source: viewModel) { article <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">ScrollView</span> {\n                <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">20</span>) {\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">title</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">body</span>)\n                }\n                .<span class=\"s-call\">padding</span>()\n            }\n        }\n    }\n}</code></pre><p>Really nice! With the above change in place, our <code>ArticleView</code> is now truly focused on just a single task — rendering an <code>Article</code> model.</p><h2>Connecting Combine publishers to views</h2><p>Adopting SwiftUI also often provides a great opportunity to start adopting <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a> as well, as both of those two frameworks follow a very similar, declarative and data-driven design.</p><p>So, rather than having each of our views follow the classic one-time load-and-render pattern, perhaps we’d like to be able to continuously feed new data to our various views as our overall app state changes.</p><p>To update our current loading state management system to support that kind of approach, let’s start by creating a <code>LoadableObject</code> implementation that takes a Combine publisher, and then uses that to load and update its published <code>state</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> PublishedObject&lt;Wrapped: <span class=\"s-type\">Publisher</span>&gt;: <span class=\"s-type\">LoadableObject</span> {\n    <span class=\"s-keyword\">@Published private(set) var</span> state = <span class=\"s-type\">LoadingState</span>&lt;<span class=\"s-type\">Wrapped</span>.<span class=\"s-type\">Output</span>&gt;.<span class=\"s-property\">idle</span>\n\n    <span class=\"s-keyword\">private let</span> publisher: <span class=\"s-type\">Wrapped</span>\n    <span class=\"s-keyword\">private var</span> cancellable: <span class=\"s-type\">AnyCancellable</span>?\n\n    <span class=\"s-keyword\">init</span>(publisher: <span class=\"s-type\">Wrapped</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">publisher</span> = publisher\n    }\n\n    <span class=\"s-keyword\">func</span> load() {\n        state = .<span class=\"s-dotAccess\">loading</span>\n\n        cancellable = publisher\n            .<span class=\"s-call\">map</span>(<span class=\"s-type\">LoadingState</span>.<span class=\"s-property\">loaded</span>)\n            .<span class=\"s-call\">catch</span> { error <span class=\"s-keyword\">in</span>\n                <span class=\"s-type\">Just</span>(<span class=\"s-type\">LoadingState</span>.<span class=\"s-call\">failed</span>(error))\n            }\n            .<span class=\"s-call\">sink</span> { [<span class=\"s-keyword\">weak self</span>] state <span class=\"s-keyword\">in\n                self</span>?.<span class=\"s-property\">state</span> = state\n            }\n    }\n}</code></pre><p>Then, using the power of Swift’s advanced generics system, we could then extend our <code>AsyncContentView</code> with a type-constrained method that automatically transforms any <code>Publisher</code> into an instance of the above <code>PublishedObject</code> type — which in turn makes it possible for us to pass any publisher directly as such a view’s <code>source</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">AsyncContentView</span> {\n    <span class=\"s-keyword\">init</span>&lt;P: <span class=\"s-type\">Publisher</span>&gt;(\n        source: <span class=\"s-type\">P</span>,\n        <span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">P</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>\n    ) <span class=\"s-keyword\">where</span> <span class=\"s-type\">Source</span> == <span class=\"s-type\">PublishedObject</span>&lt;<span class=\"s-type\">P</span>&gt; {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(\n            source: <span class=\"s-type\">PublishedObject</span>(publisher: source),\n            content: content\n        )\n    }\n}</code></pre><p class=\"info\">The above method is using a new feature in Swift 5.3, which enables us to attach generic constraints based on the enclosing type to individual method declarations.</p><p>The above gives us quite a lot of added flexibility, as we’re now able to make any of our views use a <code>Publisher</code> directly, rather than going through an abstraction, such as a view model. While that’s likely not something that we want <em>each</em> of our views to do, when it comes to views that simply render a stream of values, that could be a great option.</p><p>For example, here’s what our <code>ArticleView</code> could look like if we updated it to use that pattern:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> publisher: <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Article</span>, <span class=\"s-type\">Error</span>&gt;\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">AsyncContentView</span>(source: publisher) { article <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">ScrollView</span> {\n                <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">20</span>) {\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">title</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                    <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">body</span>)\n                }\n                .<span class=\"s-call\">padding</span>()\n            }\n        }\n    }\n}</code></pre><p>A type of situation that the above pattern could become quite useful in is when a given view primarily acts as a detail view for some kind of list — in which the list itself only contains a subset of the complete data that will be lazily loaded when each detail view is opened.</p><p>As a concrete example, here’s how our <code>ArticleView</code> might now be used within an <code>ArticleListView</code>, which in turn has a view model that creates an <code>Article</code> publisher for each preview that the list contains:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleListView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> viewModel: <span class=\"s-type\">ArticleListViewModel</span>\n    \n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">List</span>(viewModel.<span class=\"s-property\">articlePreviews</span>) { preview <span class=\"s-keyword\">in</span>\n            <span class=\"s-type\">NavigationLink</span>(preview.<span class=\"s-property\">title</span>\n                destination: <span class=\"s-type\">ArticleView</span>(\n                    publisher: viewModel.<span class=\"s-call\">publisher</span>(for: preview.<span class=\"s-property\">id</span>)\n                )\n            )\n        }\n    }\n}</code></pre><p>However, when using the above kind of pattern, it’s important to make sure that our publishers only start loading data <em>once a subscription is attached to them</em> — since otherwise we’d end up loading all of our data up-front, which would likely be quite unnecessary.</p><p class=\"info\">Since the topic of Combine-based data management is much larger than what can be covered in this article, we’ll take a much closer look at various ways to manage those kinds of data pipelines within future articles.</p><h2>Supporting custom loading views</h2><p>Finally, let’s take a look at how we could also extend our <code>AsyncContentView</code> to not only support different kinds of data sources, but also completely custom loading views. Because chances are that we don’t <em>always</em> want to show a simple loading spinner while our data is being loaded — sometimes we might want to display a tailor-made placeholder view instead.</p><p>To make that happen, let’s start by making <code>AsyncContentView</code> capable of using any <code>View</code>-conforming type as its loading view, rather than always rendering a <code>ProgressView</code> in that situation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> AsyncContentView&lt;Source: <span class=\"s-type\">LoadableObject</span>,\n                        LoadingView: <span class=\"s-type\">View</span>,\n                        Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> source: <span class=\"s-type\">Source</span>\n    <span class=\"s-keyword\">var</span> loadingView: <span class=\"s-type\">LoadingView</span>\n    <span class=\"s-keyword\">var</span> content: (<span class=\"s-type\">Source</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>\n\n    <span class=\"s-keyword\">init</span>(source: <span class=\"s-type\">Source</span>,\n         loadingView: <span class=\"s-type\">LoadingView</span>,\n         <span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Source</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">source</span> = source\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">loadingView</span> = loadingView\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">content</span> = content\n    }\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">switch</span> source.<span class=\"s-property\">state</span> {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">idle</span>:\n            <span class=\"s-type\">Color</span>.<span class=\"s-property\">clear</span>.<span class=\"s-call\">onAppear</span>(perform: source.<span class=\"s-property\">load</span>)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loading</span>:\n            loadingView\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failed</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-type\">ErrorView</span>(error: error, retryHandler: source.<span class=\"s-property\">load</span>)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loaded</span>(<span class=\"s-keyword\">let</span> output):\n            <span class=\"s-call\">content</span>(output)\n        }\n    }\n}</code></pre><p>However, while the above change does successfully give us the <em>option</em> to use custom loading views, it now also <em>requires</em> us to always manually pass a loading view when creating an <code>AsyncContentView</code> instance, which is a quite substantial regression in terms of convenience.</p><p>To fix that problem, let’s once again use the power of generic type constraints, this time by adding a convenience initializer that lets us create an <code>AsyncContentView</code> with a <code>ProgressView</code> as its loading view by simply omitting that parameter:</p><pre class=\"splash\"><code><span class=\"s-keyword\">typealias</span> DefaultProgressView = <span class=\"s-type\">ProgressView</span>&lt;<span class=\"s-type\">EmptyView</span>, <span class=\"s-type\">EmptyView</span>&gt;\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">AsyncContentView</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">LoadingView</span> == <span class=\"s-type\">DefaultProgressView</span> {\n    <span class=\"s-keyword\">init</span>(\n        source: <span class=\"s-type\">Source</span>,\n        <span class=\"s-keyword\">@ViewBuilder</span> content: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Source</span>.<span class=\"s-type\">Output</span>) -&gt; <span class=\"s-type\">Content</span>\n    ) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(\n            source: source,\n            loadingView: <span class=\"s-type\">ProgressView</span>(),\n            content: content\n        )\n    }\n}</code></pre><p class=\"info\">The above pattern is also heavily used within SwiftUI’s own public API, and is what lets us do things like create <code>Button</code> and <code>NavigationLink</code> instances using strings as their labels, rather than always having to inject a proper <code>View</code> instance.</p><p>With the above in place, let’s now go back to our <code>ArticleView</code> and first extract the parts of it that we’re using to render its actual content, which we’ll then use to implement a <code>Placeholder</code> type using SwiftUI’s new <a href=\"https://www.swiftbysundell.com/tips/swiftui-automatic-placeholders\">redaction API</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">ArticleView</span> {\n    <span class=\"s-keyword\">struct</span> ContentView: <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">var</span> article: <span class=\"s-type\">Article</span>\n\n        <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n            <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">20</span>) {\n                <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">title</span>).<span class=\"s-call\">font</span>(.<span class=\"s-dotAccess\">title</span>)\n                <span class=\"s-type\">Text</span>(article.<span class=\"s-property\">body</span>)\n            }\n            .<span class=\"s-call\">padding</span>()\n        }\n    }\n\n    <span class=\"s-keyword\">struct</span> Placeholder: <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n            <span class=\"s-type\">ContentView</span>(article: <span class=\"s-type\">Article</span>(\n                title: <span class=\"s-string\">\"Title\"</span>,\n                body: <span class=\"s-type\">String</span>(repeating: <span class=\"s-string\">\"Body\"</span>, count: <span class=\"s-number\">100</span>)\n            )).<span class=\"s-call\">redacted</span>(reason: .<span class=\"s-dotAccess\">placeholder</span>)\n        }\n    }\n}</code></pre><p>Then, let’s turn our <code>ArticleView</code> into its final form — a view that renders a custom placeholder while its content is being asynchronously loaded, all through a very compact implementation that utilizes shared abstractions to perform a large part of its work:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ArticleView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> publisher: <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Article</span>, <span class=\"s-type\">Error</span>&gt;\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">ScrollView</span> {\n            <span class=\"s-type\">AsyncContentView</span>(\n                source: publisher,\n                loadingView: <span class=\"s-type\">Placeholder</span>(),\n                content: <span class=\"s-type\">ContentView</span>.<span class=\"s-keyword\">init</span>\n            )\n        }\n    }\n}</code></pre><h2>Conclusion</h2><p>In many ways, making full use of what SwiftUI has to offer really requires us to break down many of the conventions and assumptions that we might have established when using frameworks like UIKit and AppKit. That’s not to say that SwiftUI is universally <em>better</em> than those older frameworks, but it’s definitely <em>different</em> — which in turn warrants different patterns and different approaches when it comes to tasks like data loading and state management.</p><p>I hope that this article has given you a few different ideas and options on how loading states could be handled and rendered within SwiftUI views — and if you have any questions, comments, or feedback, then feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "A few different patterns and approaches that can be used to handle and render asynchronous loading states within SwiftUI-based views.",
      "date_published": "2020-10-11T17:20:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/83",
      "url": "https://www.swiftbysundell.com/podcast/83",
      "title": "Podcast: “Adventure into widgets”, with Scriptable developer Simon Støvring",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell83.mp3\" type=\"audio/mpeg\"/></audio><p>Simon Støvring, the developer behind several powerful iOS productivity apps, including Scriptable, joins John on an episode all about the new home screen widgets introduced in iOS 14. Topics include how to create and update dynamic widgets, managing and sharing data between an app and its widgets, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://nordvpn.com/sundell\">NordVPN</a>:</strong> Make your Internet connection private and secure, no matter which network that you’re on, and unlock your video streaming services. Get a massive 68% discount on their two-year plan at <a href=\"https://nordvpn.com/sundell\">nordvpn.com/sundell</a>.</li><li><strong><a href=\"https://nsspain.com\">NSSpain</a>:</strong> An online, continuous 36-hour Apple developer conference taking place on November 19th and 20th, 2020. Get a 10% discount on your ticket by using the offer code <em>SUNDELL</em> when buying your ticket at <a href=\"https://nsspain.com\">nsspain.com</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/simonbs\">Simon on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/48\">The previous episode with Simon</a></li><li><a href=\"https://scriptable.app\">Scriptable</a></li><li><a href=\"https://datajar.app\">Data Jar</a></li><li><a href=\"https://jayson.app\">Jayson</a></li><li><a href=\"https://apps.apple.com/us/app/widgetsmith/id1523682319\">Widgetsmith</a></li><li><a href=\"https://twitter.com/marco79/status/1309882504179077125\">A Scriptable widget using the Spotify web API</a></li><li><a href=\"https://twitter.com/FirePanther/status/1313249283857166337\">A custom calendar and app launcher built with Scriptable</a></li><li><a href=\"https://twitter.com/GeoffreyDMartin/status/1312469856487313409\">Displaying custom weather and calendar information using Scriptable</a></li><li><a href=\"https://developer.apple.com/documentation/javascriptcore\">JavaScriptCore</a></li><li><a href=\"https://developer.apple.com/documentation/javascriptcore/jsexport\">The JSExport protocol</a></li><li><a href=\"https://developer.apple.com/documentation/widgetkit\">WidgetKit</a></li><li><a href=\"https://developer.apple.com/documentation/widgetkit/making-a-configurable-widget\">Configurable widgets using intents</a></li><li><a href=\"https://developer.apple.com/documentation/widgetkit/timelineprovider\">The TimelineProvider protocol</a></li><li><a href=\"https://www.swiftbysundell.com/articles/the-power-of-userdefaults-in-swift/#sharing-data-within-an-app-group\">Sharing UserDefaults data within an app group</a></li><li><a href=\"https://developer.apple.com/documentation/widgetkit/widgetcenter\">WidgetCenter</a></li><li><a href=\"https://developer.apple.com/documentation/sirikit/resolving_and_handling_intents/handling_an_intent\">In-app intent handling</a></li><li><a href=\"https://github.com/SDWebImage/SDWebImage\">SDWebImage</a></li><li><a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">SwiftUI’s state management system</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Simon Støvring, the developer behind several powerful iOS productivity apps, including Scriptable, joins John on an episode all about the new home screen widgets introduced in iOS 14. Topics include how to create and update dynamic widgets, managing and sharing data between an app and its widgets, and much more.",
      "date_published": "2020-10-08T18:45:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/lazy-property-observers",
      "url": "https://www.swiftbysundell.com/tips/lazy-property-observers",
      "title": "Tip: Lazy property observers",
      "content_html": "<p><strong>New in Swift 5.3:</strong> Property observers can now be attached to <code>lazy</code> properties, which makes it possible for us to automatically observe when a new value was assigned to a given property, even if its value is lazily loaded when first accessed.</p><p>As an example, let’s say that an app that we’re working on supports multiple themes, and that we’ve implemented a <code>ThemeController</code> that’s responsible for keeping track of which theme that the user has currently selected, as well as for loading and syncing such <code>Theme</code> values to disk using Foundation’s <a href=\"https://www.swiftbysundell.com/articles/the-power-of-userdefaults-in-swift\"><code>UserDefaults</code></a> API.</p><p>To make sure that the latest value is always persisted, we’ve added a <code>didSet</code> <a href=\"https://www.swiftbysundell.com/articles/property-observers-in-swift\">property observer</a> to our controller’s <code>theme</code> property, but before Swift 5.3, we couldn’t then also make that property <code>lazy</code> — meaning that we’d first have to give it a default value when declaring it, and then load its <em>actual</em> underlying value as part of our controller’s initializer, like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ThemeController {\n    <span class=\"s-keyword\">var</span> theme = <span class=\"s-type\">Theme</span>.<span class=\"s-call\">systemDefault</span> {\n        <span class=\"s-keyword\">didSet</span> { <span class=\"s-call\">saveTheme</span>() }\n    }\n\n    <span class=\"s-keyword\">private let</span> defaults: <span class=\"s-type\">UserDefaults</span>\n    <span class=\"s-keyword\">private let</span> defaultsKey = <span class=\"s-string\">\"theme\"</span>\n\n    <span class=\"s-keyword\">init</span>(defaults: <span class=\"s-type\">UserDefaults</span> = .<span class=\"s-dotAccess\">standard</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">defaults</span> = defaults\n        theme = <span class=\"s-call\">loadTheme</span>()\n    }\n\n    <span class=\"s-keyword\">private func</span> loadTheme() -&gt; <span class=\"s-type\">Theme</span> {\n        <span class=\"s-keyword\">let</span> savedTheme = defaults\n            .<span class=\"s-call\">string</span>(forKey: defaultsKey)\n            .<span class=\"s-call\">flatMap</span>(<span class=\"s-type\">Theme</span>.<span class=\"s-keyword\">init</span>)\n\n        <span class=\"s-keyword\">return</span> savedTheme ?? .<span class=\"s-dotAccess\">systemDefault</span>\n    }\n\n    <span class=\"s-keyword\">private func</span> saveTheme() {\n        defaults.<span class=\"s-call\">setValue</span>(theme.<span class=\"s-property\">rawValue</span>, forKey: defaultsKey)\n    }\n}</code></pre><p>But now, when using Swift 5.3, we can make that property load its value lazily when it’s first accessed, which lets us call our <code>loadTheme</code> method directly from within its declaration — giving us a simpler (and possibly slightly faster) implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ThemeController {\n    <span class=\"s-keyword\">lazy var</span> theme = <span class=\"s-call\">loadTheme</span>() {\n        <span class=\"s-keyword\">didSet</span> { <span class=\"s-call\">saveTheme</span>() }\n    }\n\n    ...\n\n    <span class=\"s-keyword\">init</span>(defaults: <span class=\"s-type\">UserDefaults</span> = .<span class=\"s-dotAccess\">standard</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-property\">defaults</span> = defaults\n    }\n\n    ...\n}</code></pre><p class=\"info\">To learn more about lazy properties in general, check out <a href=\"https://www.swiftbysundell.com/articles/using-lazy-properties-in-swift\">“Using lazy properties in Swift”</a>.</p><p>The above is definitely not a ground-breaking feature that will forever change the way we write Swift code, but it’s another one of those small but really nice improvements that continue to refine how Swift’s various language features can be combined.</p>",
      "date_published": "2020-10-06T15:20:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/magic-lasso-october-2020",
      "url": "https://www.swiftbysundell.com/sponsor/magic-lasso-october-2020",
      "title": "Sponsor: Magic Lasso Adblock",
      "content_html": "<p>My thanks to indie developer Matthew Bickham for sponsoring Swift by Sundell last week to promote his <a href=\"https://www.magiclasso.co\">Magic Lasso ad blocker</a>.</p><p>Now, I realize that advertising an ad blocker might seem a bit strange, but what I really like about Magic Lasso is that it cleans up the web by removing many of the user-hostile ads that are out there, while still keeping completely native ads (like the ones that you’ll find on Swift by Sundell) intact.</p><p>Magic Lasso will automatically block things like autoplaying video ads, unwanted popups, banners, privacy-invading trackers, and more — which in turn can make browsing the web using Safari up to two times faster.</p><p>So if you still want to support your favorite indie creators by seeing their native, privacy-focused ads, but also want to block the ones that track you across the web and that make many popular websites so much slower than they need to be — then try Magic Lasso Adblock. It’s <a href=\"https://www.magiclasso.co\">free to download</a>, and it’s available on both iOS and macOS.</p>",
      "summary": "Thanks a lot to Magic Lasso Adblock for sponsoring Swift by Sundell.",
      "date_published": "2020-10-05T09:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/testing-networking-logic-in-swift",
      "url": "https://www.swiftbysundell.com/articles/testing-networking-logic-in-swift",
      "title": "Testing networking logic in Swift",
      "content_html": "<p>When discussing the topic of unit testing and automated tests in general, it’s incredibly common to use the term <em>testable code</em> — code that’s synchronous, predictable, and always produces the same output for a given set of inputs. Networking code, however, tends to fall on the complete opposite end of that spectrum.</p><p>What makes networking code so difficult to test is both the fact that it’s inherently asynchronous, and that it relies on several external factors — such as a solid internet connection, servers, and many other kinds of systems that are involved in performing, loading, and decoding the result of a given network request.</p><p>While we’ve already taken a look at several different ways to <a href=\"https://www.swiftbysundell.com/articles/unit-testing-asynchronous-swift-code\">test asynchronous code in general</a>, this week, let’s focus on how to test networking code in particular — using Foundation’s <code>URLSession</code> API, as well as the <code>Endpoint</code> system from last month’s <em><a href=\"https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift\">“Creating generic networking APIs in Swift”</a></em>, as a starting point.</p><p class=\"info\">This article is going to assume that you’ve read the above mentioned article about <a href=\"https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift\">generic networking APIs</a> (since the following code samples are going to build directly on the code introduced in that article), and that you’re familiar with <a href=\"https://www.swiftbysundell.com/basics/unit-testing\">the basics of unit testing</a>.</p><h2>Verifying request generation logic</h2><p>When starting to write a brand new suite of tests, it’s typically a good idea to start from the bottom, and figure out how to reliably test the most foundational logic first, before moving on to testing higher-level APIs.</p><p>In this case, let’s start by verifying that the way we generate <code>URLRequest</code> values from a given <code>Endpoint</code> works as expected under a few different conditions. To make those tests as predictable as possible, let’s create a <a href=\"https://www.swiftbysundell.com/articles/defining-testing-data-in-swift/#stubbing-values\">stubbed version</a> of our <code>EndpointKind</code> protocol that doesn’t modify our requests in any way:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">EndpointKinds</span> {\n    <span class=\"s-keyword\">enum</span> Stub: <span class=\"s-type\">EndpointKind</span> {\n        <span class=\"s-keyword\">static func</span> prepare(<span class=\"s-keyword\">_</span> request: <span class=\"s-keyword\">inout</span> <span class=\"s-type\">URLRequest</span>,\n                            with data: <span class=\"s-type\">Void</span>) {\n            <span class=\"s-comment\">// No-op</span>\n        }\n    }\n}</code></pre><p class=\"info\">What makes a stub different from <a href=\"https://www.swiftbysundell.com/articles/mocking-in-swift\">a mock</a> is that a stub is simply used to fulfill one of our API requirements, without modifying our code’s behavior in any way.</p><p>With the above in place, we can actually already write our first test — in which we’ll verify that the correct request URL is generated for a basic endpoint that doesn’t contain any query items or HTTP headers:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EndpointTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testBasicRequestGeneration() {\n        <span class=\"s-keyword\">let</span> endpoint = <span class=\"s-type\">Endpoint</span>&lt;<span class=\"s-type\">EndpointKinds</span>.<span class=\"s-type\">Stub</span>, <span class=\"s-type\">String</span>&gt;(path: <span class=\"s-string\">\"path\"</span>)\n        <span class=\"s-keyword\">let</span> request = endpoint.<span class=\"s-call\">makeRequest</span>(with: ())\n        <span class=\"s-call\">XCTAssertEqual</span>(request?.<span class=\"s-property\">url</span>, <span class=\"s-type\">URL</span>(string: <span class=\"s-string\">\"https://api.myapp.com/path\"</span>))\n    }\n}</code></pre><p>That’s a great start, but there are a few ways that the above code could be improved.</p><p>For starters, we currently could end up getting <em>false positives</em> if both the generated <code>URLRequest</code> and our expected <code>URL</code> turned out to be <code>nil</code> (which might seem unlikely, but when writing tests it’s typically a good idea to eliminate all sources of potential ambiguity).</p><p>Second, we’re currently assuming that our request’s host will always be <code>api.myapp.com</code>, which might not be the case — since modern apps often support multiple networking environments (such as staging and production), and our app might also need to talk to several servers with different host addresses.</p><p>Let’s start by addressing the first issue by using the built-in <code>XCTUnwrap</code> function to verify that our generated request didn’t end up being <code>nil</code>. We’ll also take this opportunity to create a <a href=\"https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift\"><code>typealias</code></a> for our specialized <code>Endpoint</code> type as well — which gives us the following implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EndpointTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">typealias</span> StubbedEndpoint = <span class=\"s-type\">Endpoint</span>&lt;<span class=\"s-type\">EndpointKinds</span>.<span class=\"s-type\">Stub</span>, <span class=\"s-type\">String</span>&gt;\n\n    <span class=\"s-keyword\">func</span> testBasicRequestGeneration() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> endpoint = <span class=\"s-type\">StubbedEndpoint</span>(path: <span class=\"s-string\">\"path\"</span>)\n        <span class=\"s-keyword\">let</span> request = <span class=\"s-keyword\">try</span> <span class=\"s-type\">XCTUnwrap</span>(endpoint.<span class=\"s-call\">makeRequest</span>(with: ()))\n        <span class=\"s-call\">XCTAssertEqual</span>(request.<span class=\"s-property\">url</span>, <span class=\"s-type\">URL</span>(string: <span class=\"s-string\">\"https://api.myapp.com/path\"</span>))\n    }\n}</code></pre><p>Next, to make it possible to control what exact host that a given request should target, let’s introduce a dedicated <code>URLHost</code> type — which will essentially be a simple wrapper around a raw <code>String</code> value:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> URLHost: <span class=\"s-type\">RawRepresentable</span> {\n    <span class=\"s-keyword\">var</span> rawValue: <span class=\"s-type\">String</span>\n}</code></pre><p>A major benefit of implementing dedicated types for specific kinds of values is that doing so lets us encapsulate our most common variations using <a href=\"https://www.swiftbysundell.com/articles/lightweight-api-design-in-swift/#light-as-an-enum-capable-as-a-struct\">enum-like static properties</a>. For example, in this case we might create such properties for our <code>staging</code> and <code>production</code> hosts, as well as a convenience API called <code>default</code> that automatically resolves the right host depending on whether our app is running in <code>DEBUG</code> mode or not:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLHost</span> {\n    <span class=\"s-keyword\">static var</span> staging: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">URLHost</span>(rawValue: <span class=\"s-string\">\"staging.api.myapp.com\"</span>)\n    }\n\n    <span class=\"s-keyword\">static var</span> production: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">URLHost</span>(rawValue: <span class=\"s-string\">\"api.myapp.com\"</span>)\n    }\n\n    <span class=\"s-keyword\">static var</span> `default`: <span class=\"s-type\">Self</span> {\n        <span class=\"s-preprocessing\">#if DEBUG</span>\n        <span class=\"s-keyword\">return</span> staging\n        <span class=\"s-preprocessing\">#else</span>\n        <span class=\"s-keyword\">return</span> production\n        <span class=\"s-preprocessing\">#endif</span>\n    }\n}</code></pre><p>With the above in place, let’s now update our <code>Endpoint</code> type’s <code>URLRequest</code> generation method by enabling a <code>URLHost</code> value to be injected into it (while keeping <code>default</code> as the, well, default):</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Endpoint</span> {\n    <span class=\"s-keyword\">func</span> makeRequest(with data: <span class=\"s-type\">Kind</span>.<span class=\"s-type\">RequestData</span>,\n                     host: <span class=\"s-type\">URLHost</span> = .<span class=\"s-dotAccess\">default</span>) -&gt; <span class=\"s-type\">URLRequest</span>? {\n        <span class=\"s-keyword\">var</span> components = <span class=\"s-type\">URLComponents</span>()\n        components.<span class=\"s-property\">scheme</span> = <span class=\"s-string\">\"https\"</span>\n        components.<span class=\"s-property\">host</span> = host.<span class=\"s-property\">rawValue</span>\n        components.<span class=\"s-property\">path</span> = <span class=\"s-string\">\"/\"</span> + path\n        components.<span class=\"s-property\">queryItems</span> = queryItems.<span class=\"s-property\">isEmpty</span> ? <span class=\"s-keyword\">nil</span> : queryItems\n\n        <span class=\"s-keyword\">guard let</span> url = components.<span class=\"s-property\">url</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return nil</span>\n        }\n\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(url: url)\n        <span class=\"s-type\">Kind</span>.<span class=\"s-call\">prepare</span>(&amp;request, with: data)\n        <span class=\"s-keyword\">return</span> request\n    }\n}</code></pre><p>To avoid having to manually write each URL that we’ll use for verification within our tests, let’s also extend <code>URLHost</code> with a test-specific convenience API that’ll enable us to easily generate an expected URL for a given path — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLHost</span> {\n    <span class=\"s-keyword\">func</span> expectedURL(withPath path: <span class=\"s-type\">String</span>) <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">URL</span> {\n        <span class=\"s-keyword\">let</span> url = <span class=\"s-type\">URL</span>(string: <span class=\"s-string\">\"https://\"</span> + rawValue + <span class=\"s-string\">\"/\"</span> + path)\n        <span class=\"s-keyword\">return try</span> <span class=\"s-type\">XCTUnwrap</span>(url)\n    }\n}</code></pre><p>Not only does the above set of additions make our production code more capable and dynamic (since we’re now automatically supporting both staging and production environments, as well as custom hosts), we’re now able to make our initial test much easier to read — while also making it slightly more robust and predictable as well:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EndpointTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">typealias</span> StubbedEndpoint = <span class=\"s-type\">Endpoint</span>&lt;<span class=\"s-type\">EndpointKinds</span>.<span class=\"s-type\">Stub</span>, <span class=\"s-type\">String</span>&gt;\n\n    <span class=\"s-keyword\">let</span> host = <span class=\"s-type\">URLHost</span>(rawValue: <span class=\"s-string\">\"test\"</span>)\n\n    <span class=\"s-keyword\">func</span> testBasicRequestGeneration() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> endpoint = <span class=\"s-type\">StubbedEndpoint</span>(path: <span class=\"s-string\">\"path\"</span>)\n        <span class=\"s-keyword\">let</span> request = endpoint.<span class=\"s-call\">makeRequest</span>(with: (), host: host)\n\n        <span class=\"s-keyword\">try</span> <span class=\"s-call\">XCTAssertEqual</span>(\n            request?.<span class=\"s-property\">url</span>,\n            host.<span class=\"s-call\">expectedURL</span>(withPath: <span class=\"s-string\">\"path\"</span>)\n        )\n    }\n}</code></pre><p>While we did just spend a bit of time and effort on building a few test-specific convenience APIs, and to make our production code more dynamic, the benefit of doing that work is that we can now start writing many kinds of <code>Endpoint</code> verification tests very quickly. For example, here’s one that verifies the <code>URLRequest</code> generated for an endpoint that uses query items:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EndpointTests: <span class=\"s-type\">XCTestCase</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> testGeneratingRequestWithQueryItems() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> endpoint = <span class=\"s-type\">StubbedEndpoint</span>(path: <span class=\"s-string\">\"path\"</span>, queryItems: [\n            <span class=\"s-type\">URLQueryItem</span>(name: <span class=\"s-string\">\"a\"</span>, value: <span class=\"s-string\">\"1\"</span>),\n            <span class=\"s-type\">URLQueryItem</span>(name: <span class=\"s-string\">\"b\"</span>, value: <span class=\"s-string\">\"2\"</span>)\n        ])\n\n        <span class=\"s-keyword\">let</span> request = endpoint.<span class=\"s-call\">makeRequest</span>(with: (), host: host)\n\n        <span class=\"s-keyword\">try</span> <span class=\"s-call\">XCTAssertEqual</span>(\n            request?.<span class=\"s-property\">url</span>,\n            host.<span class=\"s-call\">expectedURL</span>(withPath: <span class=\"s-string\">\"path?a=1&amp;b=2\"</span>)\n        )\n    }\n}</code></pre><p>We might also want to add a few tests that’ll use some of our <em>real</em> endpoints as well, just to make sure that those are working correctly. It’s probably not worth testing <em>all</em> of our endpoints this way (it’s important to <a href=\"https://www.swiftbysundell.com/articles/pragmatic-unit-testing-in-swift\">be pragmatic</a> when writing tests, after all), but we might choose to do something like test one of our endpoints that require authentication — which’ll let us verify that the correct <code>Authorization</code> header was added when generating a request:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> EndpointTests: <span class=\"s-type\">XCTestCase</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> testAddingAccessTokenToPrivateEndpoint() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> endpoint = <span class=\"s-type\">Endpoint</span>.<span class=\"s-call\">search</span>(for: <span class=\"s-string\">\"query\"</span>)\n        <span class=\"s-keyword\">let</span> token = <span class=\"s-type\">AccessToken</span>(rawValue: <span class=\"s-string\">\"12345\"</span>)\n        <span class=\"s-keyword\">let</span> request = endpoint.<span class=\"s-call\">makeRequest</span>(with: token, host: host)\n\n        <span class=\"s-keyword\">try</span> <span class=\"s-call\">XCTAssertEqual</span>(\n            request?.<span class=\"s-property\">url</span>,\n            host.<span class=\"s-call\">expectedURL</span>(withPath: <span class=\"s-string\">\"search?q=query\"</span>)\n        )\n\n        <span class=\"s-call\">XCTAssertEqual</span>(request?.<span class=\"s-property\">allHTTPHeaderFields</span>, [\n            <span class=\"s-string\">\"Authorization\"</span>: <span class=\"s-string\">\"Bearer 12345\"</span>\n        ])\n    }\n}</code></pre><p>While there are certainly more tests that we could’ve written to cover other aspects of our <code>Endpoint</code>-related logic, the above three tests already give us a quite broad coverage, and will likely help us identify any substantial regressions to that logic in the future.</p><h2>Integration tests instead of abstractions</h2><p>Now let’s move on to testing our <em>actual</em> networking code. As a reminder, we’re currently using Foundation’s <code>URLSession</code> API in combination with a few <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine operators</a> to build our core networking pipeline — which looks like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLSession</span> {\n    <span class=\"s-keyword\">func</span> publisher&lt;K, R&gt;(\n        for endpoint: <span class=\"s-type\">Endpoint</span>&lt;<span class=\"s-type\">K</span>, <span class=\"s-type\">R</span>&gt;,\n        using requestData: <span class=\"s-type\">K</span>.<span class=\"s-type\">RequestData</span>,\n        decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>()\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">R</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">guard let</span> request = endpoint.<span class=\"s-call\">makeRequest</span>(with: requestData) <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Fail</span>(\n                error: <span class=\"s-type\">InvalidEndpointError</span>(endpoint: endpoint)\n            ).<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        <span class=\"s-keyword\">return</span> <span class=\"s-call\">dataTaskPublisher</span>(for: request)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">NetworkResponse</span>&lt;<span class=\"s-type\">R</span>&gt;.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Successfully testing the above code is definitely not very straightforward, as it uses a series of system APIs that would each need to be mocked, stubbed, or controlled in some other manner in order for our tests to become completely predictable.</p><p>A very common technique used in situations like this is to abstract each system API and asynchronous operation behind a protocol, and while that’s certainly a fine approach in many cases, let’s use a somewhat different strategy this time.</p><p>Internally, <code>URLSession</code> uses a class called <code>URLProtocol</code> to actually perform our various network calls, and the system also offers complete support for building our own custom implementations using that class as well. That means that we’ll be able to completely replace the default HTTP networking stack with a mocked version within our tests, without having to modify the above Combine pipeline at all — essentially giving us an <em><a href=\"https://www.swiftbysundell.com/articles/integration-tests-in-swift\">integration test</a></em> that verifies how our own custom logic integrates with system components like <code>URLSession</code> and Combine.</p><p>One downside of <code>URLProtocol</code> from a testing perspective, however, is that it relies heavily on static methods, which means that we’ll have to implement our various mocks as separate types. To make that a bit easier, let’s start by introducing a <code>MockURLResponder</code> protocol — which will essentially let us write various “mock servers” that respond to a given request by either returning <code>Data</code>, or by throwing an error:</p><pre class=\"splash\"><code><span class=\"s-keyword\">protocol</span> MockURLResponder {\n    <span class=\"s-keyword\">static func</span> respond(to request: <span class=\"s-type\">URLRequest</span>) <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">Data</span>\n}</code></pre><p>With the above in place, let’s now implement our custom URL protocol, which requires us to override four methods from the abstract <code>URLProtocol</code> base class — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> MockURLProtocol&lt;Responder: <span class=\"s-type\">MockURLResponder</span>&gt;: <span class=\"s-type\">URLProtocol</span> {\n    <span class=\"s-keyword\">override class func</span> canInit(with request: <span class=\"s-type\">URLRequest</span>) -&gt; <span class=\"s-type\">Bool</span> {\n        <span class=\"s-keyword\">true</span>\n    }\n\n    <span class=\"s-keyword\">override class func</span> canonicalRequest(for request: <span class=\"s-type\">URLRequest</span>) -&gt; <span class=\"s-type\">URLRequest</span> {\n        request\n    }\n\n    <span class=\"s-keyword\">override func</span> startLoading() {\n        <span class=\"s-keyword\">guard let</span> client = client <span class=\"s-keyword\">else</span> { <span class=\"s-keyword\">return</span> }\n\n        <span class=\"s-keyword\">do</span> {\n            <span class=\"s-comment\">// Here we try to get data from our responder type, and\n            // we then send that data, as well as a HTTP response,\n            // to our client. If any of those operations fail,\n            // we send an error instead:</span>\n            <span class=\"s-keyword\">let</span> data = <span class=\"s-keyword\">try</span> <span class=\"s-type\">Responder</span>.<span class=\"s-call\">respond</span>(to: request)\n            <span class=\"s-keyword\">let</span> response = <span class=\"s-keyword\">try</span> <span class=\"s-type\">XCTUnwrap</span>(<span class=\"s-type\">HTTPURLResponse</span>(\n                url: <span class=\"s-type\">XCTUnwrap</span>(request.<span class=\"s-property\">url</span>),\n                statusCode: <span class=\"s-number\">200</span>,\n                httpVersion: <span class=\"s-string\">\"HTTP/1.1\"</span>,\n                headerFields: <span class=\"s-keyword\">nil</span>\n            ))\n\n            client.<span class=\"s-call\">urlProtocol</span>(<span class=\"s-keyword\">self</span>,\n                didReceive: response,\n                cacheStoragePolicy: .<span class=\"s-dotAccess\">notAllowed</span>\n            )\n            client.<span class=\"s-call\">urlProtocol</span>(<span class=\"s-keyword\">self</span>, didLoad: data)\n        } <span class=\"s-keyword\">catch</span> {\n            client.<span class=\"s-call\">urlProtocol</span>(<span class=\"s-keyword\">self</span>, didFailWithError: error)\n        }\n\n        client.<span class=\"s-call\">urlProtocolDidFinishLoading</span>(<span class=\"s-keyword\">self</span>)\n    }\n\n    <span class=\"s-keyword\">override func</span> stopLoading() {\n        <span class=\"s-comment\">// Required method, implement as a no-op.</span>\n    }\n}</code></pre><p>The next thing that we’ll need is a way to tell a given <code>URLSession</code> instance to use our new mock protocol, rather than its default HTTP-based implementation. One way to do that would be to create a convenience initializer that takes a <code>MockURLResponder</code>-conforming type, and then creates a <code>URLSession</code> instance that uses a <code>MockURLProtocol</code> specialized with that responder type. We’ll also need to register that specialization with <code>URLProtocol</code> itself — which gives us the following implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLSession</span> {\n    <span class=\"s-keyword\">convenience init</span>&lt;T: <span class=\"s-type\">MockURLResponder</span>&gt;(mockResponder: <span class=\"s-type\">T</span>.<span class=\"s-type\">Type</span>) {\n        <span class=\"s-keyword\">let</span> config = <span class=\"s-type\">URLSessionConfiguration</span>.<span class=\"s-property\">ephemeral</span>\n        config.<span class=\"s-property\">protocolClasses</span> = [<span class=\"s-type\">MockURLProtocol</span>&lt;<span class=\"s-type\">T</span>&gt;.<span class=\"s-keyword\">self</span>]\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(configuration: config)\n        <span class=\"s-type\">URLProtocol</span>.<span class=\"s-call\">registerClass</span>(<span class=\"s-type\">MockURLProtocol</span>&lt;<span class=\"s-type\">T</span>&gt;.<span class=\"s-keyword\">self</span>)\n    }\n}</code></pre><p class=\"info\">Typically, it’s not considered a good practice to have initializers generate side-effects (such as the above <code>URLProtocol</code> registration), as the act of simply creating an object should ideally not cause any other logic to be triggered. However, in this particular case, we might choose to optimize for ease of use (rather than for complete architectural correctness) as always having to manually register each mock URL protocol would be quite inconvenient.</p><p>With all of those underlying pieces in place, let’s now go ahead and create our first concrete implementation of our <code>MockURLResponder</code> protocol — for example one that responds with an encoded <code>Item</code> model:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Item</span> {\n    <span class=\"s-keyword\">enum</span> MockDataURLResponder: <span class=\"s-type\">MockURLResponder</span> {\n        <span class=\"s-keyword\">static let</span> item = <span class=\"s-type\">Item</span>(title: <span class=\"s-string\">\"Title\"</span>, description: <span class=\"s-string\">\"Description\"</span>)\n\n        <span class=\"s-keyword\">static func</span> respond(to request: <span class=\"s-type\">URLRequest</span>) <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">Data</span> {\n            <span class=\"s-keyword\">let</span> response = <span class=\"s-type\">NetworkResponse</span>(result: item)\n            <span class=\"s-keyword\">return try</span> <span class=\"s-type\">JSONEncoder</span>().<span class=\"s-call\">encode</span>(response)\n        }\n    }\n}</code></pre><p>Before we start writing our tests, however, let’s add one final piece of infrastructure that’ll make it much easier to synchronously wait for a given Combine publisher to complete (since that’s what our networking API is based on).</p><p>To do that, let’s follow an approach that’s very similar to what we did in <em><a href=\"https://www.swiftbysundell.com/articles/useful-apis-when-writing-scripts-and-tools-in-swift\">“Useful APIs when writing scripts and tools in Swift”</a></em> — only this time we’ll use XCTest’s built-in expectation system to implement our waiting logic, rather than using a <a href=\"https://www.swiftbysundell.com/articles/a-deep-dive-into-grand-central-dispatch-in-swift\">Grand Central Dispatch semaphore</a>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> awaitCompletion&lt;T: <span class=\"s-type\">Publisher</span>&gt;(\n        of publisher: <span class=\"s-type\">T</span>,\n        timeout: <span class=\"s-type\">TimeInterval</span> = <span class=\"s-number\">10</span>\n    ) <span class=\"s-keyword\">throws</span> -&gt; [<span class=\"s-type\">T</span>.<span class=\"s-type\">Output</span>] {\n        <span class=\"s-comment\">// An expectation lets us await the result of an asynchronous\n        // operation in a synchronous manner:</span>\n        <span class=\"s-keyword\">let</span> expectation = <span class=\"s-keyword\">self</span>.<span class=\"s-call\">expectation</span>(\n            description: <span class=\"s-string\">\"Awaiting publisher completion\"</span>\n        )\n\n        <span class=\"s-keyword\">var</span> completion: <span class=\"s-type\">Subscribers</span>.<span class=\"s-type\">Completion</span>&lt;<span class=\"s-type\">T</span>.<span class=\"s-type\">Failure</span>&gt;?\n        <span class=\"s-keyword\">var</span> output = [<span class=\"s-type\">T</span>.<span class=\"s-type\">Output</span>]()\n\n        <span class=\"s-keyword\">let</span> cancellable = publisher.<span class=\"s-call\">sink</span> {\n            completion = $0\n            expectation.<span class=\"s-call\">fulfill</span>()\n        } receiveValue: {\n            output.<span class=\"s-call\">append</span>($0)\n        }\n\n        <span class=\"s-comment\">// Our test execution will stop at this point until our\n        // expectation has been fulfilled, or until the given timeout\n        // interval has elapsed:</span>\n        <span class=\"s-call\">waitForExpectations</span>(timeout: timeout)\n\n        <span class=\"s-keyword\">switch</span> completion {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failure</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-keyword\">throw</span> error\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">finished</span>:\n            <span class=\"s-keyword\">return</span> output\n        <span class=\"s-keyword\">case nil</span>:\n            <span class=\"s-comment\">// If we enter this code path, then our test has\n            // already been marked as failing, since our\n            // expectation was never fullfilled.</span>\n            cancellable.<span class=\"s-call\">cancel</span>()\n            <span class=\"s-keyword\">return</span> []\n        }\n    }\n}</code></pre><p>Just like when testing our <code>Endpoint</code> system earlier, we’ve now spent a fair amount of effort building out a quite complex set of underlying infrastructure, but all of that work is about to pay off in a big way — since we’ll now be able to test a wide range of networking scenarios with very few lines of code. For example, here’s how we could test that we’re able to successfully load and decode the response for a given request:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> NetworkIntegrationTests: <span class=\"s-type\">XCTestCase</span> {\n    <span class=\"s-keyword\">func</span> testSuccessfullyPerformingRequest() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> session = <span class=\"s-type\">URLSession</span>(mockResponder: <span class=\"s-type\">Item</span>.<span class=\"s-type\">MockDataURLResponder</span>.<span class=\"s-keyword\">self</span>)\n        <span class=\"s-keyword\">let</span> accessToken = <span class=\"s-type\">AccessToken</span>(rawValue: <span class=\"s-string\">\"12345\"</span>)\n\n        <span class=\"s-keyword\">let</span> publisher = session.<span class=\"s-call\">publisher</span>(for: .<span class=\"s-dotAccess\">latestItem</span>, using: accessToken)\n        <span class=\"s-keyword\">let</span> result = <span class=\"s-keyword\">try</span> <span class=\"s-call\">awaitCompletion</span>(of: publisher)\n\n        <span class=\"s-call\">XCTAssertEqual</span>(result, [<span class=\"s-type\">Item</span>.<span class=\"s-type\">MockDataURLResponder</span>.<span class=\"s-property\">item</span>])\n    }\n}</code></pre><p>Really nice! As a second and final example, here’s how we could verify that our networking pipeline correctly produces a top-level error when a given request ended up failing:</p><pre class=\"splash\"><code><span class=\"s-keyword\">enum</span> MockErrorURLResponder: <span class=\"s-type\">MockURLResponder</span> {\n    <span class=\"s-keyword\">static func</span> respond(to request: <span class=\"s-type\">URLRequest</span>) <span class=\"s-keyword\">throws</span> -&gt; <span class=\"s-type\">Data</span> {\n        <span class=\"s-keyword\">throw</span> <span class=\"s-type\">URLError</span>(.<span class=\"s-dotAccess\">badServerResponse</span>)\n    }\n}\n\n<span class=\"s-keyword\">class</span> NetworkIntegrationTests: <span class=\"s-type\">XCTestCase</span> {\n    ...\n\n    <span class=\"s-keyword\">func</span> testFailingWhenEncounteringError() <span class=\"s-keyword\">throws</span> {\n        <span class=\"s-keyword\">let</span> session = <span class=\"s-type\">URLSession</span>(mockResponder: <span class=\"s-type\">MockErrorURLResponder</span>.<span class=\"s-keyword\">self</span>)\n        <span class=\"s-keyword\">let</span> accessToken = <span class=\"s-type\">AccessToken</span>(rawValue: <span class=\"s-string\">\"12345\"</span>)\n\n        <span class=\"s-keyword\">let</span> publisher = session.<span class=\"s-call\">publisher</span>(for: .<span class=\"s-dotAccess\">latestItem</span>, using: accessToken)\n        <span class=\"s-call\">XCTAssertThrowsError</span>(<span class=\"s-keyword\">try</span> <span class=\"s-call\">awaitCompletion</span>(of: publisher))\n    }\n}</code></pre><p>We could then continue expanding the above test case to include other scenarios as well — for example in order to make sure that our networking pipeline correctly handles JSON decoding failures, or to verify any custom error handling logic that we might have in place.</p><h2>Conclusion</h2><p>While there’s definitely a very large number of different approaches that we can take when testing our networking code and its associated logic, basing those tests on our <em>actual</em> pipelines and operations tends to make them more <em>realistic</em>, and in turn, more likely to catch bugs and regressions.</p><p>The techniques used in this article might initially seem rather complicated, but since they’re all based on core system networking APIs (like <code>URLRequest</code>, <code>URLSession</code>, and <code>URLProtocol</code>), they’re likely going to be easier to maintain that a complex series of interconnected protocols that are only really there to enable testability.</p><p>But, like always, I encourage you to experiment with various approaches in order to find one that fits your particular project the best. Either way, I hope that you found this article interesting, and if you have any questions, comments or other kinds of feedback — feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "How networking code can be tested without needing to introduce complex abstractions within our production code, by using system-provided APIs for overriding and mocking various kinds of requests.",
      "date_published": "2020-10-04T16:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/importing-interactive-uikit-views-into-swiftui",
      "url": "https://www.swiftbysundell.com/tips/importing-interactive-uikit-views-into-swiftui",
      "title": "Importing interactive UIKit views into SwiftUI",
      "content_html": "<p>SwiftUI’s <code>UIViewRepresentable</code> protocol makes it possible for us third party developers to bring any UIKit-based view, either one provided by Apple or one that we’ve written ourselves, into a SwiftUI view hierarchy.</p><p>While importing a static, non-interactive view is typically <a href=\"https://www.swiftbysundell.com/tips/inline-wrapping-of-uikit-or-appkit-views-within-swiftui\">quite straightforward</a>, whenever we’re dealing with some kind of interactive control that relies on UIKit-style conventions (such as either the target/action or delegate pattern), performing the necessary bridging to <a href=\"https://www.swiftbysundell.com/articles/swiftui-state-management-guide\">SwiftUI’s state management system</a> might initially seem rather difficult.</p><p>As an example, let’s say that we wanted to use <code>UITextView</code> to add a larger user-editable text area within an app, rather than using SwiftUI’s built-in <code>TextEditor</code> view that was introduced in iOS 14 and macOS Big Sur (since that view is still quite limited in terms of functionality).</p><p>To get started, we might write the following implementation, which wraps a <code>UITextView</code> instance in a <code>UIViewRepresentable</code>-conforming struct:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> TextView: <span class=\"s-type\">UIViewRepresentable</span> {\n    <span class=\"s-keyword\">@Binding var</span> text: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">func</span> makeUIView(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">UITextView</span> {\n        <span class=\"s-keyword\">let</span> view = <span class=\"s-type\">UITextView</span>()\n        view.<span class=\"s-property\">font</span> = .<span class=\"s-call\">preferredFont</span>(forTextStyle: .<span class=\"s-dotAccess\">body</span>)\n        <span class=\"s-keyword\">return</span> view\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIView(<span class=\"s-keyword\">_</span> view: <span class=\"s-type\">UITextView</span>, context: <span class=\"s-type\">Context</span>) {\n        view.<span class=\"s-property\">text</span> = text\n    }\n}</code></pre><p>However, while the above is a great starting point, we’re currently not capturing any edits that the user will make to the above <code>text</code>, since we haven’t connected its <code>Binding</code> to the text view itself.</p><p>Since a <code>UITextView</code> instance uses the <a href=\"https://www.swiftbysundell.com/articles/delegation-in-swift\">delegate pattern</a> to let us observe its current text, and since only reference types (specifically, <code>NSObject</code> subclasses) can conform to <code>UITextViewDelegate</code>, we won’t be able to perform that kind of observation within our <code>TextView</code> struct itself. But thankfully, SwiftUI provides a built-in mechanism that’s perfect for this type of situation.</p><p>Any <code>UIViewRepresentable</code> or <code>UIViewControllerRepresentable</code> type can declare a nested <code>Coordinator</code> type which can be used to, well, <em>coordinate</em> its underlying <code>UIView</code> or <code>UIViewController</code>. In our case, we can use such a type as our text view’s delegate, and then make it sync any updates to an injected <code>Binding</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">TextView</span> {\n    <span class=\"s-keyword\">class</span> Coordinator: <span class=\"s-type\">NSObject</span>, <span class=\"s-type\">UITextViewDelegate</span> {\n        <span class=\"s-keyword\">@Binding private var</span> text: <span class=\"s-type\">String</span>\n\n        <span class=\"s-keyword\">init</span>(text: <span class=\"s-type\">Binding</span>&lt;<span class=\"s-type\">String</span>&gt;) {\n            <span class=\"s-comment\">// Here we assign our injected Binding directly\n            // to our text property, rather than assigning\n            // its wrapped value:</span>\n            _text = text\n        }\n\n        <span class=\"s-keyword\">func</span> textViewDidChange(<span class=\"s-keyword\">_</span> textView: <span class=\"s-type\">UITextView</span>) {\n            text = textView.<span class=\"s-property\">text</span>\n        }\n    }\n}</code></pre><p>With the above in place, let’s now go back to our <code>TextView</code> struct and add the (now required) <code>makeCoordinator</code> method to it, and we’ll also assign the current coordinator instance as our text field’s <code>delegate</code> within our <code>makeUIView</code> method:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> TextView: <span class=\"s-type\">UIViewRepresentable</span> {\n    <span class=\"s-keyword\">@Binding var</span> text: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">func</span> makeCoordinator() -&gt; <span class=\"s-type\">Coordinator</span> {\n        <span class=\"s-type\">Coordinator</span>(text: <span class=\"s-property\">$text</span>)\n    }\n\n    <span class=\"s-keyword\">func</span> makeUIView(context: <span class=\"s-type\">Context</span>) -&gt; <span class=\"s-type\">UITextView</span> {\n        <span class=\"s-keyword\">let</span> view = <span class=\"s-type\">UITextView</span>()\n        view.<span class=\"s-property\">font</span> = .<span class=\"s-call\">preferredFont</span>(forTextStyle: .<span class=\"s-dotAccess\">body</span>)\n        view.<span class=\"s-property\">delegate</span> = context.<span class=\"s-property\">coordinator</span>\n        <span class=\"s-keyword\">return</span> view\n    }\n\n    <span class=\"s-keyword\">func</span> updateUIView(<span class=\"s-keyword\">_</span> view: <span class=\"s-type\">UITextView</span>, context: <span class=\"s-type\">Context</span>) {\n        view.<span class=\"s-property\">text</span> = text\n    }\n}</code></pre><p>That’s it! We’ll now be able to use our new <code>TextView</code> type within any SwiftUI view, and we can also apply standard modifiers like <code>border</code> and <code>padding</code> to it as well:</p><pre data-preview=\"textview\"><code><span class=\"s-keyword\">struct</span> BiographyEditView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> biography: <span class=\"s-type\">String</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">TextView</span>(text: <span class=\"s-property\">$biography</span>)\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">border</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">primary</span>, width: <span class=\"s-number\">0.5</span>)\n            .<span class=\"s-call\">padding</span>()\n            .<span class=\"s-call\">navigationTitle</span>(<span class=\"s-string\">\"Edit your biography\"</span>)\n    }\n}</code></pre><p class=\"info\">💡 Tip: You can use the <code>PREVIEW</code> button within the above code sample to see what it looks like when rendered within a <code>NavigationView</code>.</p><p>The fact that we can keep reusing our <code>UIView</code>-based components when starting to adopt SwiftUI within an existing project is incredibly convenient, and the fact that we can at any point jump back into UIKit also acts as a neat “escape hatch” for when SwiftUI can’t yet accomplish a given task.</p>",
      "date_published": "2020-10-01T18:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/instabug-september-2020",
      "url": "https://www.swiftbysundell.com/sponsor/instabug-september-2020",
      "title": "Sponsor: Instabug",
      "content_html": "<p>My thanks to <a href=\"https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q320-sept&utm_content=Spon\">Instabug</a> for sponsoring Swift by Sundell this past week. I’ve personally been using Instabug for bug and crash reporting in several projects, and it’s always been rock-solid and extremely valuable when solving all sorts of bugs and issues.</p><p>When you include Instabug’s lightweight SDK within your app, it’ll not only automatically notify you of crashes and other issues that your users might encounter, it’ll also help you monitor your app’s overall performance, and lets you easily add various support tools — such as in-app bug reporting and surveys — to your app as well.</p><p>Instabug also keeps getting better and better, and at the time of writing, they’re just about to launch their brand new Application Performance Monitoring feature — which will give you super valuable insights into how your app is performing on various devices, all completely automatically. I’ve been beta-testing that new feature during the past week, and I’m really excited to soon get to use it in production.</p><p>Try Instabug (for free!) today by <a href=\"https://try.instabug.com/swiftbysundell?utm_source=swiftbysundell&utm_medium=nativeads&utm_campaign=swiftbysundell-nativeads-q320-sept&utm_content=Spon\">using this link</a>, and you’ll also directly help support Swift by Sundell.</p>",
      "summary": "Thanks a lot to Instabug for sponsoring Swift by Sundell.",
      "date_published": "2020-09-28T11:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/encapsulating-swiftui-view-styles",
      "url": "https://www.swiftbysundell.com/articles/encapsulating-swiftui-view-styles",
      "title": "Encapsulating SwiftUI view styles",
      "content_html": "<p>Regardless of what framework or tool that’s used to build a given UI, finding a good way to separate the structure and internal logic of our various views from the styles that are being applied to them is often key in order to make UI code easier to maintain and manage.</p><p>While certain technologies offer a quite natural way of separating those two aspects of UI development, such as how websites declare their structure through HTML and their styles using CSS — when it comes to SwiftUI, it might not initially seem like that kind of separation is practical, or even encouraged.</p><p>However, if we start exploring SwiftUI’s various APIs and conventions a bit further, it turns out that there are a number of tools and techniques that we can use to create a clean separation between our view hierarchy, its styles, and the components that we’re looking to reuse across a given project.</p><p>That’s exactly what we’ll take a look at in this week’s article.</p><h2>Reusable components</h2><p>As an example, let’s say that we’re currently working on a <code>LoginView</code> that lets our users enter their username and password in order to log into our app. For those two text fields we’re using the system-provided “round border” style, and for the button that performs the actual login action we’ve applied a series of modifiers to give it a custom look:</p><pre data-preview=\"loginview\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> handler: (<span class=\"s-type\">LoginCredentials</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">@State private var</span> username = <span class=\"s-string\">\"\"</span>\n    <span class=\"s-keyword\">@State private var</span> password = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Username\"</span>, text: <span class=\"s-property\">$username</span>)\n                .<span class=\"s-call\">textFieldStyle</span>(<span class=\"s-type\">RoundedBorderTextFieldStyle</span>())\n            <span class=\"s-type\">SecureField</span>(<span class=\"s-string\">\"Password\"</span>, text: <span class=\"s-property\">$password</span>)\n                .<span class=\"s-call\">textFieldStyle</span>(<span class=\"s-type\">RoundedBorderTextFieldStyle</span>())\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                <span class=\"s-call\">handler</span>(<span class=\"s-type\">LoginCredentials</span>(\n                    username: username,\n                    password: password\n                ))\n            }\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n        }\n    }\n}</code></pre><p class=\"info\">💡 Tip: You can use the <code>PREVIEW</code> button within the above code sample to see what it looks like when rendered.</p><p>While that setup works perfectly fine as long as the above button is only displayed within that particular view, if we instead wanted to reuse that button style across our app, we’d currently have to manually apply that same set of modifiers in each place — which would both be repetitive, and likely lead to a ton of inconsistencies over time — so let’s instead turn those styles into a reusable component that we can just insert whenever needed.</p><p>One way to do that would be to extract the above <code>Button</code> view, along with the modifiers that we apply to it, into a new <code>View</code> implementation — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ActionButton: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">var</span> title: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> action: () -&gt; <span class=\"s-type\">Void</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Button</span>(title, action: action)\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>However, while implementing reusable components as custom <code>View</code> types is certainly a common and incredibly useful pattern, it does give us a few downsides in cases like this.</p><p>First of all, since we’re now wrapping our <code>Button</code> within a new, separate <code>ActionButton</code> type, we have to replicate all of the <code>Button</code> APIs that we want our new view to support. For instance, we’ve already had to replicate the <code>title</code> and <code>action</code> properties that <code>Button</code> gives us for free.</p><p>If we then wanted to mimmic the <em>exact</em> initializer that we previously used when creating the button within our <code>LoginView</code>, we’d have to extend our new <code>ActionButton</code> type with a custom initializer that removes the external parameter label for the <code>title</code> property. We can also no longer use <code>Button</code>-specific modifiers directly on instances of our new type, and we can no longer pass those instances to any API that accepts <code>Button</code> arguments.</p><p>One way to solve those issues would be to <em>extend</em> the built-in <code>Button</code> type, rather than wrapping it — for example by implementing a modifier-like method that applies our custom styles to <em>any button instance</em>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Button</span> {\n    <span class=\"s-keyword\">func</span> withActionButtonStyles() -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>With the above in place, we can now style our login button from before by simply calling our new method on it — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n            ...\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                <span class=\"s-call\">handler</span>(<span class=\"s-type\">LoginCredentials</span>(\n                    username: username,\n                    password: password\n                ))\n            }\n            .<span class=\"s-call\">withActionButtonStyles</span>()\n        }\n    }\n}</code></pre><p>Although modeling shared view styles using extensions <em>could</em> potentially make discovering those styles slightly more difficult compared to when using separate <code>View</code> types, doing so gives us so much more flexibility, and creates a neat separation between our actual views and the styles that are being applied to them.</p><h2>Dedicated style types</h2><p>One way to address that discoverability aspect, while still giving our styles extension-like characteristics, would be to embrace the pattern that SwiftUI itself uses for many of its own, built-in styles — <em>dedicated style types</em>.</p><p>Most built-in SwiftUI controls come with a companion protocol that can be used to implement reusable style configurations for that particular control. We actually have already been using that convention within our <code>LoginView</code>, when styling our two text fields using <code>RoundedBorderTextFieldStyle</code>, and it turns out that we can also use that system to create our own custom styles as well.</p><p>For example, the <code>ButtonStyle</code> protocol enables us to do just that for our custom action button styles:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ActionButtonStyle: <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        configuration.<span class=\"s-property\">label</span>\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>)\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>With the above in place, we can once again easily apply our custom set of styles to any <code>Button</code> — only now we’ll do it using the built-in <code>buttonStyle</code> modifier, combined with an instance of our new <code>ActionButtonStyle</code> type:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n            ...\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                <span class=\"s-call\">handler</span>(<span class=\"s-type\">LoginCredentials</span>(\n                    username: username,\n                    password: password\n                ))\n            }\n            .<span class=\"s-call\">buttonStyle</span>(<span class=\"s-type\">ActionButtonStyle</span>())\n        }\n    }\n}</code></pre><p>However, just like with all things programming, there are always trade-offs. Although the above technique lets us neatly encapsulate our styles within a specific type, while also giving us the flexibility to apply those styles to any <code>Button</code> — since we’re now using a completely custom <code>ButtonStyle</code>, the system will no longer apply any default styles or behaviors to the above button. For example, our button will no longer automatically react to taps by making its title brighter, which might make it seem less responsive to user interactions.</p><p>Thankfully, that problem can be fixed quite easily. All that we have to do is to use the <code>Configuration</code> object that gets passed into our custom <code>ButtonStyle</code> to check if the button is currently being pressed, and to then modify our styles accordingly — for example like this:</p><pre data-preview=\"button-pressed-state\"><code><span class=\"s-keyword\">struct</span> ActionButtonStyle: <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        configuration.<span class=\"s-property\">label</span>\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>.<span class=\"s-call\">opacity</span>(\n                configuration.<span class=\"s-property\">isPressed</span> ? <span class=\"s-number\">0.5</span> : <span class=\"s-number\">1</span>\n            ))\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>The system will still automatically apply animations when transitioning between our button’s pressed and default states, so with the above change in place, our button now looks just as responsive and native as it initially did — really nice.</p><p>Besides all of the encapsulation aspects, one major advantage of implementing our shared view styles using SwiftUI’s various style protocols is that we can apply them to an entire view hierarchy at once. For example, let’s say that we wanted to add a second button to our <code>LoginView</code> that lets our users reset their passwords — we could now give both of those buttons the same styles by applying our <code>ActionButtonStyle</code> directly to our view’s root <code>VStack</code>:</p><pre data-preview=\"two-buttons\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">enum</span> Action {\n        <span class=\"s-keyword\">case</span> login(<span class=\"s-type\">LoginCredentials</span>)\n        <span class=\"s-keyword\">case</span> resetPassword\n    }\n\n    <span class=\"s-keyword\">var</span> handler: (<span class=\"s-type\">Action</span>) -&gt; <span class=\"s-type\">Void</span>\n    <span class=\"s-keyword\">@State private var</span> username = <span class=\"s-string\">\"\"</span>\n    <span class=\"s-keyword\">@State private var</span> password = <span class=\"s-string\">\"\"</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n            <span class=\"s-type\">TextField</span>(<span class=\"s-string\">\"Username\"</span>, text: <span class=\"s-property\">$username</span>)\n            <span class=\"s-type\">SecureField</span>(<span class=\"s-string\">\"Password\"</span>, text: <span class=\"s-property\">$password</span>)\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                <span class=\"s-call\">handler</span>(.<span class=\"s-call\">login</span>(<span class=\"s-type\">LoginCredentials</span>(\n                    username: username,\n                    password: password\n                )))\n            }\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Password reset\"</span>) {\n                <span class=\"s-call\">handler</span>(.<span class=\"s-dotAccess\">resetPassword</span>)\n            }\n        }\n        .<span class=\"s-call\">textFieldStyle</span>(<span class=\"s-type\">RoundedBorderTextFieldStyle</span>())\n        .<span class=\"s-call\">buttonStyle</span>(<span class=\"s-type\">ActionButtonStyle</span>())\n    }\n}</code></pre><p>Note that we’re now also applying the styles for our two text fields by modifying our root <code>VStack</code>, and that same pattern can be used to configure any SwiftUI control that supports type-based styling.</p><h2>Variants and overrides</h2><p>While being able to configure multiple views with the same set of styles is incredibly powerful and convenient, chances are that we’ll also occasionally want to tweak some of those styles on a per-view basis.</p><p>For example, the two buttons within our <code>LoginView</code> currently have the exact same look, which also gives them the same amount of <em>prominence</em> within our UI — something that we might not want in this case, considering that our password reset action should probably be considered secondary to the action of logging in.</p><p>Now there are multiple ways that we can address that issue — including by adding various parameters to our <code>ActionButtonStyle</code> type, or by applying a different set of modifiers to our reset password button — but perhaps the simplest way to deal with common variations like this would be to create additional style implementations to match them.</p><p>Here’s how we could do just that for all of the <em>secondary</em> buttons within our app:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SecondaryButtonStyle: <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-comment\">// Our secondary style uses less horizontal padding and\n        // a gray background color, rather than a blue one:</span>\n        configuration.<span class=\"s-property\">label</span>\n            .<span class=\"s-call\">foregroundColor</span>(.<span class=\"s-dotAccess\">white</span>)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">caption</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(<span class=\"s-number\">10</span>)\n            .<span class=\"s-call\">background</span>(\n                <span class=\"s-type\">Color</span>.<span class=\"s-property\">gray</span>.<span class=\"s-call\">opacity</span>(configuration.<span class=\"s-property\">isPressed</span> ? <span class=\"s-number\">0.5</span> : <span class=\"s-number\">1</span>)\n            )\n            .<span class=\"s-call\">cornerRadius</span>(<span class=\"s-number\">10</span>)\n    }\n}</code></pre><p>If we then rename our <code>ActionButtonStyle</code> type from before to <code>PrimaryButtonStyle</code>, we could now either style our two buttons separately, or we could do the following — and apply our default, primary style to our view hierarchy as a whole, while also overriding the <code>ButtonStyle</code> used for our password reset button specifically, like this:</p><pre data-preview=\"multiple-button-styles\"><code><span class=\"s-keyword\">struct</span> LoginView: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span>(spacing: <span class=\"s-number\">15</span>) {\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Log in\"</span>) {\n                <span class=\"s-call\">handler</span>(.<span class=\"s-call\">login</span>(<span class=\"s-type\">LoginCredentials</span>(\n                    username: username,\n                    password: password\n                )))\n            }\n            <span class=\"s-type\">Button</span>(<span class=\"s-string\">\"Password reset\"</span>) {\n                <span class=\"s-call\">handler</span>(.<span class=\"s-dotAccess\">resetPassword</span>)\n            }\n            .<span class=\"s-call\">buttonStyle</span>(<span class=\"s-type\">SecondaryButtonStyle</span>())\n        }\n        .<span class=\"s-call\">textFieldStyle</span>(<span class=\"s-type\">RoundedBorderTextFieldStyle</span>())\n        .<span class=\"s-call\">buttonStyle</span>(<span class=\"s-type\">PrimaryButtonStyle</span>())\n    }\n}</code></pre><p>That’s another thing that makes SwiftUI’s styling system so powerful — in that we can always override any particular style for a specific part of our view hierarchy, while still assigning our most common set of styles as defaults.</p><p>However, while implementing each of our various styles as separate types often lets us keep our code simple and free of complex conditions, doing so can also lead to a fair amount of code duplication. While it could definitely be argued that in the above case, the duplication between our <code>PrimaryButtonStyle</code> and <code>SecondaryButtonStyle</code> is so insignificant that we can simply ignore it, let’s also take a look at how we <em>could</em> share certain common configurations between those two types.</p><p>One way to do that would be to implement them both within the same file, and to then extend the styling protocol that they both conform to — <code>ButtonStyle</code> in this case — with the properties that we’re looking to share between the two:</p><pre class=\"splash\"><code><span class=\"s-keyword\">private extension</span> <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">var</span> foregroundColor: <span class=\"s-type\">Color</span> { .<span class=\"s-dotAccess\">white</span> }\n    <span class=\"s-keyword\">var</span> padding: <span class=\"s-type\">CGFloat</span> { <span class=\"s-number\">10</span> }\n    <span class=\"s-keyword\">var</span> cornerRadius: <span class=\"s-type\">CGFloat</span> { <span class=\"s-number\">10</span> }\n    <span class=\"s-keyword\">var</span> pressedColorOpacity: <span class=\"s-type\">Double</span> { <span class=\"s-number\">0.5</span> }\n}</code></pre><p>We could then simply reference the above properties when applying those shared styles, rather than hard-coding those values within each implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> PrimaryButtonStyle: <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        configuration.<span class=\"s-property\">label</span>\n            .<span class=\"s-call\">foregroundColor</span>(foregroundColor)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">body</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(padding)\n            .<span class=\"s-call\">padding</span>(.<span class=\"s-dotAccess\">horizontal</span>, <span class=\"s-number\">20</span>)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">blue</span>.<span class=\"s-call\">opacity</span>(\n                configuration.<span class=\"s-property\">isPressed</span> ? pressedColorOpacity : <span class=\"s-number\">1</span>\n            ))\n            .<span class=\"s-call\">cornerRadius</span>(cornerRadius)\n    }\n}\n\n<span class=\"s-keyword\">struct</span> SecondaryButtonStyle: <span class=\"s-type\">ButtonStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        configuration.<span class=\"s-property\">label</span>\n            .<span class=\"s-call\">foregroundColor</span>(foregroundColor)\n            .<span class=\"s-call\">font</span>(<span class=\"s-type\">Font</span>.<span class=\"s-property\">caption</span>.<span class=\"s-call\">bold</span>())\n            .<span class=\"s-call\">padding</span>(padding)\n            .<span class=\"s-call\">background</span>(<span class=\"s-type\">Color</span>.<span class=\"s-property\">gray</span>.<span class=\"s-call\">opacity</span>(\n                configuration.<span class=\"s-property\">isPressed</span> ? pressedColorOpacity : <span class=\"s-number\">1</span>\n            ))\n            .<span class=\"s-call\">cornerRadius</span>(cornerRadius)\n    }\n}</code></pre><p>There are of course a number of other ways that the above kind of code sharing could be accomplished — including by extending types like <code>Font</code> and <code>Color</code> directly, or by implementing other dedicated types for those shared styles (for example some form of <code>AppTheme</code> struct). Or, we could simply choose to ignore that source of code duplication entirely if we don’t think that it’ll be an issue within our particular project.</p><h2>A common pattern within SwiftUI</h2><p>Just like how we’ve now used dedicated style types to configure both buttons and text fields, we can use that same pattern with a number of different SwiftUI views — including toggles, pickers, lists, progress views, labels, and many more.</p><p>As a final example, here’s how we could create a custom <code>LabelStyle</code> that renders a given label’s <code>icon</code> and <code>title</code> vertically, rather than horizontally (which is the default):</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> VerticalLabelStyle: <span class=\"s-type\">LabelStyle</span> {\n    <span class=\"s-keyword\">func</span> makeBody(configuration: <span class=\"s-type\">Configuration</span>) -&gt; <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            configuration.<span class=\"s-property\">icon</span>\n            configuration.<span class=\"s-property\">title</span>\n        }\n    }\n}</code></pre><p>Just like our other styles from before, our new <code>VerticalLabelStyle</code> can now be applied to a series of labels all at once — and in case we don’t wish to place them within any particular layout stack, we could always use a <code>Group</code>, like this:</p><pre data-preview=\"labels\"><code><span class=\"s-type\">Group</span> {\n    <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Top rated\"</span>, systemImage: <span class=\"s-string\">\"star.fill\"</span>)\n    <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Localized\"</span>, systemImage: <span class=\"s-string\">\"globe\"</span>)\n    <span class=\"s-type\">Label</span>(<span class=\"s-string\">\"Encrypted\"</span>, systemImage: <span class=\"s-string\">\"checkmark.seal\"</span>)\n}\n.<span class=\"s-call\">labelStyle</span>(<span class=\"s-type\">VerticalLabelStyle</span>())</code></pre><p>So since using various implementations of a shared styling protocol is such a common pattern within the world of SwiftUI, it’s often a great option for encapsulating our own custom styles as well.</p><h2>Conclusion</h2><p>The fact that SwiftUI was very much designed around the idea of composition often gives us several different options when it comes to how we want to accomplish a given task. In the case of view styling in particular, we can choose to build a brand new <code>View</code> type for each component or style, we can use modifiers and extensions, or we can use custom implementations of SwiftUI’s various styling protocols — and we can pick the best fit among those options within each given situation.</p><p>Hopefully this article has given you an overview of those options and their various pros and cons. If you have any questions, comments, or feedback — feel free to reach out via either <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "An overview of the tools and techniques that we can use to create a clean separation between our view hierarchy, its styles, and the components that we’re looking to reuse across a given project.",
      "date_published": "2020-09-27T16:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/82",
      "url": "https://www.swiftbysundell.com/podcast/82",
      "title": "Podcast: “Translating designs into code”, with special guest Jordan Singer",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell82.mp3\" type=\"audio/mpeg\"/></audio><p>Jordan Singer joins John to discuss various approaches of turning designs into fully implemented UIs, how to manage things like mock data during the development process, and when to turn a given view into a reusable component. Also, the story behind the Airport app and Jordan’s recent SwiftUI experiments.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://instabug.com/sundell\">Instabug</a>:</strong> Bug, crash, and performance monitoring for iOS apps. Go to <a href=\"https://instabug.com/sundell\">instabug.com/sundell</a> to learn more about Instabug’s new App Performance Monitoring feature, and to start your free trial.</li><li><strong><a href=\"https://www.revenuecat.com\">RevenueCat</a>:</strong> In-app subscriptions made easy. RevenueCat handles the pain points of implementing subscriptions and in-app purchases, so that you can get back to building your app. Learn more at <a href=\"https://www.revenuecat.com\">revenuecat.com</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/jsngr\">Jordan on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://ibuildmyideas.com\">Jordan’s website: ibuildmyideas.com</a></li><li><a href=\"https://cash.app\">Cash App</a></li><li><a href=\"https://airport.community\">Airport</a></li><li><a href=\"https://lil.software\">lil software</a></li><li><a href=\"https://www.sketch.com\">Sketch</a></li><li><a href=\"https://www.figma.com\">Figma</a></li><li><a href=\"https://www.framer.com\">Framer</a></li><li><a href=\"https://twitter.com/jsngr/status/1284323848880623616\">SwiftUI implementation of “About this Mac”</a></li><li><a href=\"https://twitter.com/jsngr/status/1287860562345500679\">SwiftUiPod Classic</a></li><li><a href=\"https://twitter.com/jsngr/status/1280619068794470402\">Rdio remake</a></li><li><a href=\"https://developer.apple.com/documentation/app_clips/fruta_building_a_feature-rich_app_with_swiftui\">Apple’s Fruta example app</a></li><li><a href=\"https://wwdcbysundell.com/2020/building-entire-apps-with-swiftui\">Using SwiftUI’s App protocol</a></li><li><a href=\"https://twitter.com/johnsundell/status/1275806023236882432\">An entire SwiftUI app within a tweet</a></li><li><a href=\"https://www.swiftbysundell.com/articles/using-compiler-directives-in-swift\">Swift’s warning directive</a></li><li><a href=\"https://www.swiftbysundell.com/podcast/66\">Episode with Meng To</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/buttonstyle\">SwiftUI’s ButtonStyle protocol</a></li><li><a href=\"https://developer.apple.com/documentation/swiftui/insetgroupedliststyle\">InsetGroupedListStyle</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Jordan Singer joins John to discuss various approaches of turning designs into fully implemented UIs, how to manage things like mock data during the development process, and when to turn a given view into a reusable component. Also, the story behind the Airport app and Jordan’s recent SwiftUI experiments.",
      "date_published": "2020-09-24T13:00:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/bitrise-september-2020",
      "url": "https://www.swiftbysundell.com/sponsor/bitrise-september-2020",
      "title": "Sponsor: Bitrise",
      "content_html": "<p>My thanks to <a href=\"https://bitrise.io/swift\">Bitrise</a> for sponsoring Swift by Sundell for the past two weeks, enabling me to keep the site free and open to the entire Swift community.</p><p>Bitrise is my favorite continuous integration service, and this time of the year, I’m always reminded of a big reason why that is. Every time that a new release of Xcode comes out — whether it’s a new minor version, a new beta seed, or an entirely new major release — it just takes the team at Bitrise mere hours to add support for it.</p><p>So when Apple released the Xcode 12 GM this past Tuesday, Bitrise had it up and running on their servers in less than 24 hours — enabling all of their customers (myself included) to immediately build, test, and distribute their apps using the new iOS 14 SDK. Simply leave it up to Bitrise to keep your CI and build pipeline up to date, so that you can focus on working on your app and delivering new features to your users.</p><p>Bitrise takes just a few minutes to setup, it doesn’t require you to fiddle around with any obscure configuration files or build settings — it just works! Try it for free today, to run your builds and tests automatically in the cloud, by visiting <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a>.</p><p>Using the above link also directly helps support Swift by Sundell as well.</p>",
      "summary": "Thanks a lot to Bitrise for sponsoring Swift by Sundell.",
      "date_published": "2020-09-21T08:35:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift",
      "url": "https://www.swiftbysundell.com/articles/creating-generic-networking-apis-in-swift",
      "title": "Creating generic networking APIs in Swift",
      "content_html": "<p>When implementing an app’s networking layer, there’s often a number of different server endpoints that we need to support, and while each of those endpoints might return different kinds of models and data, the underlying logic used to call them tends to remain quite similar, at least within a single code base.</p><p>So this week, let’s take a look at few different techniques that can help us share as much of that common networking logic as possible — while also utilizing Swift’s advanced type system to make our networking code more robust and easier to validate.</p><h2>Modeling shared structures</h2><p>When working with certain web APIs, especially those that are following a REST-like design, it’s incredibly common to receive JSON responses that contain their actual data nested under a key that’s common among all endpoints. For example, the following JSON uses <code>result</code> as such a top-level key:</p><pre><code class=\"no-highlight\">{\n    \"result\": {\n        \"id\": \"D4F28578-51BD-40F4-A8BD-387668E06EF8\",\n        \"name\": \"John Sundell\",\n        \"twitterHandle\": \"johnsundell\",\n        \"gitHubUsername\": \"johnsundell\"\n    }\n}</code></pre><p>Now the question is, what would be an elegant way to handle the above kind of situation on the client side, especially when using <a href=\"https://www.swiftbysundell.com/basics/codable\"><code>Codable</code></a> to decode our JSON responses into actual Swift model types?</p><p>One option would be to wrap the model that we’re looking to extract into a dedicated response type that we can then decode directly from our downloaded <code>Data</code>. For example, let’s say that the above JSON represents a <code>User</code> model — which might lead us to create the following nested <code>NetworkResponse</code> wrapper for decoding such a response:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> User: <span class=\"s-type\">Identifiable</span>, <span class=\"s-type\">Codable</span> {\n    <span class=\"s-keyword\">let</span> id: <span class=\"s-type\">UUID</span>\n    <span class=\"s-keyword\">var</span> name: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> twitterHandle: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> gitHubUsername: <span class=\"s-type\">String</span>\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">User</span> {\n    <span class=\"s-keyword\">struct</span> NetworkResponse: <span class=\"s-type\">Codable</span> {\n        <span class=\"s-keyword\">var</span> result: <span class=\"s-type\">User</span>\n    }\n}</code></pre><p>With the above in place, we can now load and decode a <code>User</code> instance like this (using the <a href=\"https://www.swiftbysundell.com/basics/combine\">Combine</a>-powered version of Foundation’s <a href=\"https://www.swiftbysundell.com/basics/networking\">URLSession</a> API):</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n\n    <span class=\"s-keyword\">func</span> loadUser(withID id: <span class=\"s-type\">User</span>.<span class=\"s-type\">ID</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">User</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: <span class=\"s-call\">resolveURL</span>(forID: id))\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">User</span>.<span class=\"s-type\">NetworkResponse</span>.<span class=\"s-keyword\">self</span>, decoder: <span class=\"s-type\">JSONDecoder</span>())\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>While there’s certainly nothing wrong with the above code, always having to create dedicated <code>NetworkResponse</code> wrappers for each of our models would likely lead to a fair amount of duplication — since that’d also require us to write the above kind of network request code multiple times as well. So let’s see if we can come up with a more generic, reusable abstraction instead.</p><p>Given that each of our network responses follow the same structure, let’s start by creating a generic <code>NetworkResponse</code> type that we’ll be able to use when loading any of our models:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> NetworkResponse&lt;Wrapped: <span class=\"s-type\">Decodable</span>&gt;: <span class=\"s-type\">Decodable</span> {\n    <span class=\"s-keyword\">var</span> result: <span class=\"s-type\">Wrapped</span>\n}</code></pre><p>We now no longer need to create and maintain separate wrapper types for each kind of request, but can instead specialize the above type for each concrete use case — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n\n    <span class=\"s-keyword\">func</span> loadUser(withID id: <span class=\"s-type\">User</span>.<span class=\"s-type\">ID</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">User</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">dataTaskPublisher</span>(for: <span class=\"s-call\">resolveURL</span>(forID: id))\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">NetworkResponse</span>&lt;<span class=\"s-type\">User</span>&gt;.<span class=\"s-keyword\">self</span>, decoder: <span class=\"s-type\">JSONDecoder</span>())\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>While the above is definitely an improvement, the real power of modeling things like network requests using generic types is that we can keep creating utilities and convenience APIs that let us work at much higher level when performing such tasks.</p><p>For example, apart from the return type of the above <code>loadUser</code> method, there’s really nothing that’s <code>User</code>-specific about its internal logic — in fact, we would probably write more or less the exact same code when loading <em>any</em> of our app’s models — so let’s extract that logic into a shared abstraction instead:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLSession</span> {\n    <span class=\"s-keyword\">func</span> publisher&lt;T: <span class=\"s-type\">Decodable</span>&gt;(\n        for url: <span class=\"s-type\">URL</span>,\n        responseType: <span class=\"s-type\">T</span>.<span class=\"s-type\">Type</span> = <span class=\"s-type\">T</span>.<span class=\"s-keyword\">self</span>,\n        decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>()\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">T</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-call\">dataTaskPublisher</span>(for: url)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">NetworkResponse</span>&lt;<span class=\"s-type\">T</span>&gt;.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>Note how we’re using <a href=\"https://www.swiftbysundell.com/articles/default-arguments-in-swift\">default arguments</a> for both our <code>responseType</code> and <code>decoder</code> parameters — which is especially useful for the former of the two, since that’ll enable the compiler to automatically infer the generic type <code>T</code> from the surrounding context of each call site.</p><p>So if we go back to our <code>UserLoader</code> type from before, we can now perform all of its required networking with just one line of code — since the compiler is able to infer that we’re looking to load and decode a <code>User</code> model based on our <code>loadUser</code> method’s return type:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> UserLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n\n    <span class=\"s-keyword\">func</span> loadUser(withID id: <span class=\"s-type\">User</span>.<span class=\"s-type\">ID</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">User</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">publisher</span>(for: <span class=\"s-call\">resolveURL</span>(forID: id))\n    }\n}</code></pre><p>That’s quite an improvement! So much so that we might now start to ask ourselves whether we really need dedicated types for loading each of our models — since we could just as well create a completely generic <code>ModelLoader</code> that uses our above <code>URLSession</code> extension, as well as a closure that resolves which URL to use for a given model ID, to enable us to load any model within our app — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ModelLoader&lt;Model: <span class=\"s-type\">Identifiable</span> &amp; <span class=\"s-type\">Decodable</span>&gt; {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">var</span> urlResolver: (<span class=\"s-type\">Model</span>.<span class=\"s-type\">ID</span>) -&gt; <span class=\"s-type\">URL</span>\n\n    <span class=\"s-keyword\">func</span> loadModel(withID id: <span class=\"s-type\">Model</span>.<span class=\"s-type\">ID</span>) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">Model</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">publisher</span>(for: <span class=\"s-call\">urlResolver</span>(id))\n    }\n}</code></pre><p>The above <code>ModelLoader</code> type might of course not cover all of our networking needs, but at least it could let us unify the way we load each of our main data models.</p><h2>Type-based validation</h2><p>Besides reducing boilerplate, creating generic APIs can also provide a way to make code more strongly typed, and can enable us to use Swift’s advanced type system to validate parts of our code at compile time.</p><p>To take a look at how that could be done within the context of networking in particular, let’s say that we’re working on an app that defines its various network requests using a <code>Endpoint</code> struct — such as this one from the <a href=\"https://www.swiftbysundell.com/clips/4\"><em>“Managing URLs and endpoints”</em> episode</a> of Swift Clips:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Endpoint {\n    <span class=\"s-keyword\">var</span> path: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> queryItems = [<span class=\"s-type\">URLQueryItem</span>]()\n}</code></pre><p>Especially when working on an app that calls many different endpoints, using a dedicated type to represent those endpoints is already a big step forward in terms of type safety and convenience — however, many apps also divide their endpoints up into different <em>scopes or kinds</em>. For instance, certain endpoints might only be valid to call once the user has logged in, some endpoints might require elevated permissions, while some endpoints might not require any authentication at all.</p><p>However, as our above <code>Endpoint</code> type is currently implemented, the Swift compiler can’t help us validate whether we’re actually allowed to call a given endpoint within a certain situation, and it also doesn’t provide any way for us to attach contextual data (such as access tokens or other authentication headers) to the requests that we’ll make. So let’s see if we can address both of those two issues using generics.</p><p>Let’s start by creating an <code>EndpointKind</code> protocol with two requirements — an associated type that defines what <code>RequestData</code> that’s required to perform a given kind of request, as well as a method for preparing a <code>URLRequest</code> instance using that required data:</p><pre class=\"splash\"><code><span class=\"s-keyword\">protocol</span> EndpointKind {\n    <span class=\"s-keyword\">associatedtype</span> RequestData\n    \n    <span class=\"s-keyword\">static func</span> prepare(<span class=\"s-keyword\">_</span> request: <span class=\"s-keyword\">inout</span> <span class=\"s-type\">URLRequest</span>,\n                        with data: <span class=\"s-type\">RequestData</span>)\n}</code></pre><p class=\"info\">To learn more about the <code>inout</code> keyword that’s used above, and how it relates to value types, check out <a href=\"https://www.swiftbysundell.com/articles/utilizing-value-semantics-in-swift\">“Utilizing value semantics in Swift”</a>.</p><p>Next, let’s use the above protocol to implement concrete types for each of the different kinds of endpoints that our app is calling. In this particular case we’ll simply define one type for our <em>public</em> endpoints, and one for our <em>private</em> ones — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">enum</span> EndpointKinds {\n    <span class=\"s-keyword\">enum</span> Public: <span class=\"s-type\">EndpointKind</span> {\n        <span class=\"s-keyword\">static func</span> prepare(<span class=\"s-keyword\">_</span> request: <span class=\"s-keyword\">inout</span> <span class=\"s-type\">URLRequest</span>,\n                            with <span class=\"s-keyword\">_</span>: <span class=\"s-type\">Void</span>) {\n            <span class=\"s-comment\">// Here we can do things like assign a custom cache\n            // policy for loading our publicly available data.\n            // In this example we're telling URLSession not to\n            // use any locally cached data for these requests:</span>\n            request.<span class=\"s-property\">cachePolicy</span> = .<span class=\"s-dotAccess\">reloadIgnoringLocalCacheData</span>\n        }\n    }\n\n    <span class=\"s-keyword\">enum</span> Private: <span class=\"s-type\">EndpointKind</span> {\n        <span class=\"s-keyword\">static func</span> prepare(<span class=\"s-keyword\">_</span> request: <span class=\"s-keyword\">inout</span> <span class=\"s-type\">URLRequest</span>,\n                            with token: <span class=\"s-type\">AccessToken</span>) {\n            <span class=\"s-comment\">// For our private endpoints, we'll require an\n            // access token to be passed, which we then use to\n            // assign an Authorization header to each request:</span>\n            request.<span class=\"s-call\">addValue</span>(<span class=\"s-string\">\"Bearer</span> \\(token.<span class=\"s-property\">rawValue</span>)<span class=\"s-string\">\"</span>,\n                forHTTPHeaderField: <span class=\"s-string\">\"Authorization\"</span>\n            )\n        }\n    }\n}</code></pre><p class=\"info\">Note how we’re using <code>Void</code> as our <code>Public</code> type’s <code>RequestData</code>, since it doesn’t require any specific data to be passed when making a request. We then ignore that parameter within that type’s <code>prepare</code> method by using an underscore as its internal parameter label.</p><p>With the above pieces in place, let’s now add two generic types to our <code>Endpoint</code> struct from before — one that tells us what <code>EndpointKind</code> that a given instance belongs to, and one that defines what <code>Response</code> type that each endpoint response should be decoded into:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> Endpoint&lt;Kind: <span class=\"s-type\">EndpointKind</span>, Response: <span class=\"s-type\">Decodable</span>&gt; {\n    <span class=\"s-keyword\">var</span> path: <span class=\"s-type\">String</span>\n    <span class=\"s-keyword\">var</span> queryItems = [<span class=\"s-type\">URLQueryItem</span>]()\n}</code></pre><p class=\"info\">At this point, we’re sort of using the above <code>Kind</code> and <code>Response</code> types as phantom types, since they’re not used to store any form of data within our <code>Endpoint</code> struct. For more on that topic, check out <a href=\"https://www.swiftbysundell.com/articles/phantom-types-in-swift\">“Phantom types in Swift”</a>.</p><p>Next up, we’ll need a way to convert <code>Endpoint</code> values into <code>URLRequest</code> instances — which could be done by combining Foundation’s <code>URLComponents</code> API with the <code>prepare</code> method that we defined earlier within our <code>EndpointKind</code> protocol:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Endpoint</span> {\n    <span class=\"s-keyword\">func</span> makeRequest(with data: <span class=\"s-type\">Kind</span>.<span class=\"s-type\">RequestData</span>) -&gt; <span class=\"s-type\">URLRequest</span>? {\n        <span class=\"s-keyword\">var</span> components = <span class=\"s-type\">URLComponents</span>()\n        components.<span class=\"s-property\">scheme</span> = <span class=\"s-string\">\"https\"</span>\n        components.<span class=\"s-property\">host</span> = <span class=\"s-string\">\"api.myapp.com\"</span>\n        components.<span class=\"s-property\">path</span> = <span class=\"s-string\">\"/\"</span> + path\n        components.<span class=\"s-property\">queryItems</span> = queryItems.<span class=\"s-property\">isEmpty</span> ? <span class=\"s-keyword\">nil</span> : queryItems\n\n        <span class=\"s-comment\">// If either the path or the query items passed contained\n        // invalid characters, we'll get a nil URL back:</span>\n        <span class=\"s-keyword\">guard let</span> url = components.<span class=\"s-property\">url</span> <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return nil</span>\n        }\n\n        <span class=\"s-keyword\">var</span> request = <span class=\"s-type\">URLRequest</span>(url: url)\n        <span class=\"s-type\">Kind</span>.<span class=\"s-call\">prepare</span>(&amp;request, with: data)\n        <span class=\"s-keyword\">return</span> request\n    }\n}</code></pre><p>Now that we’re no longer using raw URLs to perform our various requests, let’s once again extend <code>URLSession</code> with a convenience API for making it really easy to perform requests using our new, generic <code>Endpoint</code> type. We’ll use a very similar approach as when building our earlier <code>NetworkResponse</code>-based extension — only this time we’ll use our generic types to ensure that the correct request and response types are always used for each endpoint:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">URLSession</span> {\n    <span class=\"s-keyword\">func</span> publisher&lt;K, R&gt;(\n        for endpoint: <span class=\"s-type\">Endpoint</span>&lt;<span class=\"s-type\">K</span>, <span class=\"s-type\">R</span>&gt;,\n        using requestData: <span class=\"s-type\">K</span>.<span class=\"s-type\">RequestData</span>,\n        decoder: <span class=\"s-type\">JSONDecoder</span> = .<span class=\"s-keyword\">init</span>()\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">R</span>, <span class=\"s-type\">Error</span>&gt; {\n        <span class=\"s-keyword\">guard let</span> request = endpoint.<span class=\"s-call\">makeRequest</span>(with: requestData) <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">Fail</span>(\n                error: <span class=\"s-type\">InvalidEndpointError</span>(endpoint: endpoint)\n            ).<span class=\"s-call\">eraseToAnyPublisher</span>()\n        }\n\n        <span class=\"s-keyword\">return</span> <span class=\"s-call\">dataTaskPublisher</span>(for: request)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">data</span>)\n            .<span class=\"s-call\">decode</span>(type: <span class=\"s-type\">NetworkResponse</span>&lt;<span class=\"s-type\">R</span>&gt;.<span class=\"s-keyword\">self</span>, decoder: decoder)\n            .<span class=\"s-call\">map</span>(\\.<span class=\"s-property\">result</span>)\n            .<span class=\"s-call\">eraseToAnyPublisher</span>()\n    }\n}</code></pre><p>The power of having a completely type-safe networking pipeline and a generic <code>Endpoint</code> struct is that we can now use generic type constraints when defining our app’s various endpoints — which in turn makes it crystal clear both what kind of data that’s required to perform each request, as well as what the resulting response type will be.</p><p>Here’s how we could define two such type-constrained APIs using <a href=\"https://www.swiftbysundell.com/articles/static-factory-methods-in-swift\">static factory methods</a> — one for a public endpoint, and one for a private one:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">Endpoint</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Kind</span> == <span class=\"s-type\">EndpointKinds</span>.<span class=\"s-type\">Public</span>, <span class=\"s-type\">Response</span> == [<span class=\"s-type\">Item</span>] {\n    <span class=\"s-keyword\">static var</span> featuredItems: <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Endpoint</span>(path: <span class=\"s-string\">\"featured\"</span>)\n    }\n}\n\n<span class=\"s-keyword\">extension</span> <span class=\"s-type\">Endpoint</span> <span class=\"s-keyword\">where</span> <span class=\"s-type\">Kind</span> == <span class=\"s-type\">EndpointKinds</span>.<span class=\"s-type\">Private</span>,\n                         <span class=\"s-type\">Response</span> == <span class=\"s-type\">SearchResults</span> {\n    <span class=\"s-keyword\">static func</span> search(for query: <span class=\"s-type\">String</span>) -&gt; <span class=\"s-type\">Self</span> {\n        <span class=\"s-type\">Endpoint</span>(path: <span class=\"s-string\">\"search\"</span>, queryItems: [\n            <span class=\"s-type\">URLQueryItem</span>(name: <span class=\"s-string\">\"q\"</span>, value: query)\n        ])\n    }\n}</code></pre><p>Although making our network requests more strongly typed did require us to build a fair amount of underlying infrastructure, actually making requests is now simpler than ever — as the compiler will automatically validate that we’re passing the correct request data for each given endpoint, and that our return types match our network calls — all while giving us a really nice and concise syntax at each call site:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> SearchResultsLoader {\n    <span class=\"s-keyword\">var</span> urlSession = <span class=\"s-type\">URLSession</span>.<span class=\"s-property\">shared</span>\n    <span class=\"s-keyword\">var</span> userSession: <span class=\"s-type\">UserSession</span>\n\n    <span class=\"s-keyword\">func</span> loadResults(\n        matching query: <span class=\"s-type\">String</span>\n    ) -&gt; <span class=\"s-type\">AnyPublisher</span>&lt;<span class=\"s-type\">SearchResults</span>, <span class=\"s-type\">Error</span>&gt; {\n        urlSession.<span class=\"s-call\">publisher</span>(\n            for: .<span class=\"s-call\">search</span>(for: query),\n            using: userSession.<span class=\"s-property\">accessToken</span>\n        )\n    }\n}</code></pre><p>Of course, we could keep extending the above networking system even further, for example in order to support different HTTP methods (such as <code>POST</code> and <code>PUT</code>), various kinds of payloads, more granular error handling, and so on — so we’ll likely return to the topic of networking again in future articles.</p><h2>Conclusion</h2><p>When deployed strategically, generics can not only enable us to get rid of common sources of boilerplate, but can also help us improve certain parts of our code base with stronger typing and more rigid compile-time validation. However, it’s also always important to keep in mind that using generics <em>can</em> also make certain code more complex and harder to maintain — so striking a nice balance between simplicity and power really becomes key.</p><p>For example, some projects might not require a completely generic <code>EndpointKind</code> system, while others might not benefit much from associating each <code>Endpoint</code> with a generic <code>Response</code> type — even though both of those techniques can be incredibly useful to keep in mind as a project grows, or when handling a larger number of endpoints.</p><p>What do you think? Feel free to send me any questions, feedback or comments that you have, either via <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "A few different techniques that can help us share common networking logic, while also utilizing Swift’s advanced type system to make that kind of code more robust.",
      "date_published": "2020-09-20T16:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/tips/creating-closure-based-ui-controls-with-uiaction",
      "url": "https://www.swiftbysundell.com/tips/creating-closure-based-ui-controls-with-uiaction",
      "title": "Creating closure-based UI controls using UIAction",
      "content_html": "<p>When it was first introduced as part of iOS 13, the <code>UIAction</code> class was primarily used when constructing system-provided menus, but in iOS 14 it can now also be used to configure UIKit’s various <code>UIControl</code>-based views — such as <code>UIButton</code>, <code>UISlider</code> and <code>UISwitch</code>.</p><p>Ever since the early days of iOS (before it was even called “iOS” to begin with), we’ve been able to observe different <code>UIControl</code> events using the <em>target/action pattern</em> — which requires us to pass an Objective-C-compatible selector, along with a target object to call that selector on. For example, here’s how we might use that pattern to observe when a “Start” button within an <code>ActivityViewController</code> was tapped:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ActivityViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> activity: <span class=\"s-type\">Activity</span>\n    ...\n\n    <span class=\"s-keyword\">override func</span> viewDidLoad() {\n        <span class=\"s-keyword\">let</span> startButton = <span class=\"s-type\">UIButton</span>(type: .<span class=\"s-dotAccess\">system</span>)\n        \n        startButton.<span class=\"s-call\">addTarget</span>(<span class=\"s-keyword\">self</span>,\n            action: <span class=\"s-keyword\">#selector</span>(startActivity),\n            for: .<span class=\"s-dotAccess\">touchUpInside</span>\n        )\n        \n        startButton.<span class=\"s-call\">setImage</span>(<span class=\"s-type\">UIImage</span>(\n            systemName: <span class=\"s-string\">\"play.circle.fill\"</span>\n        ), for: .<span class=\"s-dotAccess\">normal</span>)\n        \n        startButton.<span class=\"s-call\">setTitle</span>(<span class=\"s-string\">\"Start\"</span>, for: .<span class=\"s-dotAccess\">normal</span>)\n        view.<span class=\"s-call\">addSubview</span>(startButton)\n        ...\n    }\n    \n    <span class=\"s-keyword\">@objc private func</span> startActivity() {\n        activity.<span class=\"s-call\">start</span>()\n    }\n}</code></pre><p>The above approach works perfectly fine, of course, but in iOS 14 we have another option — and that’s to instead perform our event handling using a closure wrapped in a <code>UIAction</code> instance, which we then pass as our button’s <code>primaryAction</code> when creating it:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ActivityViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> activity: <span class=\"s-type\">Activity</span>\n    ...\n\n    <span class=\"s-keyword\">override func</span> viewDidLoad() {\n        <span class=\"s-keyword\">let</span> startButton = <span class=\"s-type\">UIButton</span>(\n            primaryAction: <span class=\"s-type\">UIAction</span> { [activity] <span class=\"s-keyword\">_ in</span>\n                activity.<span class=\"s-call\">start</span>()\n            }\n        )\n        \n        startButton.<span class=\"s-call\">setImage</span>(<span class=\"s-type\">UIImage</span>(\n            systemName: <span class=\"s-string\">\"play.circle.fill\"</span>\n        ), for: .<span class=\"s-dotAccess\">normal</span>)\n\n        startButton.<span class=\"s-call\">setTitle</span>(<span class=\"s-string\">\"Start\"</span>, for: .<span class=\"s-dotAccess\">normal</span>)\n        view.<span class=\"s-call\">addSubview</span>(startButton)\n        ...\n    }\n    \n    ...\n}</code></pre><p class=\"info\">Above we’re using an underscore to ignore the argument passed into our <code>UIAction</code> closure, which is a reference to the action itself.</p><p>That’s already quite an improvement for cases like the one above, when we don’t need a reference to <code>self</code> in order to perform our event handling logic. However, <code>UIAction</code> offers a lot more than <em>just</em> a closure-based alternative to the target/action pattern — since it also lets us configure properties such as what title and image that a given control should have — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">class</span> ActivityViewController: <span class=\"s-type\">UIViewController</span> {\n    <span class=\"s-keyword\">private let</span> activity: <span class=\"s-type\">Activity</span>\n    ...\n\n    <span class=\"s-keyword\">override func</span> viewDidLoad() {\n        <span class=\"s-keyword\">let</span> startAction = <span class=\"s-type\">UIAction</span>(\n            title: <span class=\"s-string\">\"Start\"</span>,\n            image: <span class=\"s-type\">UIImage</span>(systemName: <span class=\"s-string\">\"play.circle.fill\"</span>),\n            handler: { [activity] <span class=\"s-keyword\">_ in</span>\n                activity.<span class=\"s-call\">start</span>()\n            }\n        )\n\n        <span class=\"s-keyword\">let</span> startButton = <span class=\"s-type\">UIButton</span>(primaryAction: startAction)\n        view.<span class=\"s-call\">addSubview</span>(startButton)\n        ...\n    }\n    \n    ...\n}</code></pre><p>Now, depending on what kind of app that we’re working on, we might repeat some of the above kind of configuration code quite a lot, but now that we have a built-in closure-based API at our disposal, we can build our own lightweight extensions on top of that in order to make it much easier to apply such common configurations.</p><p>For example, here’s how we could extend <code>UIButton</code> with a convenience initializer that takes a simple <code>() -&gt; Void</code> handler closure, as well as an optional title and image:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">UIButton</span> {\n    <span class=\"s-keyword\">convenience init</span>(title: <span class=\"s-type\">String</span> = <span class=\"s-string\">\"\"</span>,\n                     image: <span class=\"s-type\">UIImage</span>? = <span class=\"s-keyword\">nil</span>,\n                     handler: <span class=\"s-keyword\">@escaping</span> () -&gt; <span class=\"s-type\">Void</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(primaryAction: <span class=\"s-type\">UIAction</span>(\n            title: title,\n            image: image,\n            handler: { <span class=\"s-keyword\">_ in</span>\n                <span class=\"s-call\">handler</span>()\n            }\n        ))\n    }\n}</code></pre><p>Besides reducing boilerplate, a really neat advantage of the above convenience API is that we can now pass our <code>Activity</code> model’s <code>start</code> method directly as our button’s handler closure — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> startButton = <span class=\"s-type\">UIButton</span>(\n    title: <span class=\"s-string\">\"Start\"</span>,\n    image: <span class=\"s-type\">UIImage</span>(systemName: <span class=\"s-string\">\"play.circle.fill\"</span>),\n    handler: activity.<span class=\"s-property\">start</span>\n)</code></pre><p class=\"info\">The above works thanks to the fact that Swift supports <a href=\"https://www.swiftbysundell.com/clips/1\">first class functions</a>, which lets us pass any function as if it was a closure, given that its input and output types match that of the closure argument that we’re passing it to.</p><p>So <code>UIAction</code> is likely going to become a quite popular way to configure <code>UIButton</code> event handlers, but the cool thing is that it can also be used with any other <code>UIControl</code> subclass — such as <code>UISlider</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> slider = <span class=\"s-type\">UISlider</span>(\n    frame: .<span class=\"s-dotAccess\">zero</span>,\n    primaryAction: <span class=\"s-type\">UIAction</span> { action <span class=\"s-keyword\">in\n        let</span> slider = action.<span class=\"s-property\">sender</span> <span class=\"s-keyword\">as</span>! <span class=\"s-type\">UISlider</span>\n        <span class=\"s-keyword\">let</span> value = slider.<span class=\"s-property\">value</span>\n        \n        <span class=\"s-comment\">// Handle value</span>\n        ...\n    }\n)</code></pre><p class=\"info\">A <code>UIAction</code> can also be attached to a control after it has been created using the <code>addAction</code> method.</p><p>However, while it’s really nice that we can once again observe one of our controls using a built-in closure-based API, the fact that we have to type-cast the action’s <code>sender</code> to <code>UISlider</code> in order to retrieve its value isn’t very elegant (or <a href=\"https://www.swiftbysundell.com/articles/what-makes-code-swifty\">“swifty”</a>) — so let’s see if we can fix that problem using another convenience initializer, such as this one:</p><pre class=\"splash\"><code><span class=\"s-keyword\">extension</span> <span class=\"s-type\">UISlider</span> {\n    <span class=\"s-keyword\">typealias</span> Value = <span class=\"s-type\">Float</span>\n\n    <span class=\"s-keyword\">convenience init</span>(handler: <span class=\"s-keyword\">@escaping</span> (<span class=\"s-type\">Value</span>) -&gt; <span class=\"s-type\">Void</span>) {\n        <span class=\"s-keyword\">self</span>.<span class=\"s-keyword\">init</span>(\n            frame: .<span class=\"s-dotAccess\">zero</span>,\n            primaryAction: <span class=\"s-type\">UIAction</span> { action <span class=\"s-keyword\">in\n                let</span> slider = action.<span class=\"s-property\">sender</span> <span class=\"s-keyword\">as</span>! <span class=\"s-type\">Self</span>\n                <span class=\"s-call\">handler</span>(slider.<span class=\"s-property\">value</span>)\n            }\n        )\n    }\n}</code></pre><p class=\"info\">Note how we’re using a <code>typealias</code> above to add a bit more contextual meaning to our closure’s input type. To learn more about that approach, check out <a href=\"https://www.swiftbysundell.com/articles/the-power-of-type-aliases-in-swift\">“The power of type aliases in Swift”</a>.</p><p>With the above in place, we can now easily create a closure-based <code>UISlider</code> like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">let</span> slider = <span class=\"s-type\">UISlider</span> { value <span class=\"s-keyword\">in</span>\n    <span class=\"s-comment\">// Handle value</span>\n    ...\n}</code></pre><p>Really nice! While it’s been quite common for developers to extend UIKit with custom closure-based APIs for years, now having such an API built into all <code>UIControl</code> subclasses is definitely great news.</p><p>However, we might still want to stick to using the target/action pattern in situations in which we need access to <code>self</code>, or when we need to execute a larger code block that would be better encapsulated as a method — but for simpler event handling code, the above new <code>UIAction</code>-based suite of APIs should come very much in handy.</p><p>Thanks for reading! 🚀</p>",
      "date_published": "2020-09-15T13:15:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/articles/how-swift-5-3-enhances-swiftui-dsl",
      "url": "https://www.swiftbysundell.com/articles/how-swift-5-3-enhances-swiftui-dsl",
      "title": "How Swift 5.3 enhances SwiftUI’s DSL",
      "content_html": "<p>When SwiftUI was first introduced at WWDC 2019, it definitely pushed many aspects of both Swift and Xcode to its very limits — through its heavy use of generics, closure-based APIs, and brand new features, such as <a href=\"https://www.swiftbysundell.com/articles/property-wrappers-in-swift\">property wrappers</a> and <a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">function builders</a>.</p><p>So its therefore not very surprising that a big focus of the upcoming new version of Swift, 5.3, is to continue to expand the ways in which Swift can be used to build SwiftUI-style domain-specific languages (or <a href=\"https://www.swiftbysundell.com/articles/building-dsls-in-swift\">DSLs</a>), and to smoothen out a few “rough edges” that many developers have encountered when using SwiftUI with Swift 5.2 and earlier.</p><p>This week, let’s take a look at some of those advancements, and how they collectively enhance the overall experience of building views using SwiftUI.</p><h2>Implicit self capturing</h2><p>Since the very beginning, Swift has required us to explicitly specify <code>self</code> when accessing an instance method or property within an <a href=\"https://www.swiftbysundell.com/articles/capturing-objects-in-swift-closures/#the-great-escape\">escaping closure</a>, which sort of acts as an “opt-in” for having that closure capture the enclosing object or value — since doing so <em>could</em> end up causing retain cycles <a href=\"https://www.swiftbysundell.com/questions/is-weak-self-always-required\">in certain situations</a>.</p><p>However, since the risk of retain cycles is often quite negligible when using value types, that requirement of always having to specify <code>self</code> has been somewhat relaxed in Swift 5.3 — by enabling the compiler to implicitly capture struct instances, which SwiftUI views and modifiers are almost exclusively implemented as.</p><p>As an example, let’s say that we’ve built the following <code>FavoriteButton</code> using Swift 5.2, which requires us to use <code>self</code> when referencing its <code>isOn</code> property within its underlying button’s <code>action</code> closure:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> FavoriteButton: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> isOn: <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Button</span>(action: {\n            <span class=\"s-keyword\">self</span>.<span class=\"s-property\">isOn</span>.<span class=\"s-call\">toggle</span>()\n        }, label: {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"heart\"</span> + (isOn ? <span class=\"s-string\">\".fill\"</span> : <span class=\"s-string\">\"\"</span>))\n        })\n    }\n}</code></pre><p>When upgrading to Swift 5.3, however, that <code>self</code> reference can now be completely removed — which gives us a slightly simpler implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> FavoriteButton: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> isOn: <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Button</span>(action: {\n            isOn.<span class=\"s-call\">toggle</span>()\n        }, label: {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"heart\"</span> + (isOn ? <span class=\"s-string\">\".fill\"</span> : <span class=\"s-string\">\"\"</span>))\n        })\n    }\n}</code></pre><p>While the above might be a quite minor change in the grand scheme of things, it does make SwiftUI’s DSL feel slightly more lightweight and easier to use.</p><p>Also, as a side-effect, since explicitly specifying <code>self</code> is now only required in situations where doing so <em>really matters</em> (such as when dealing with captured reference types), that should arguably make those parts of our code base “stand out” a bit more, which in turn could make it easier to spot potential retain cycle-related issues within such code.</p><h2>View building body properties</h2><p>When building UIs in general, it’s incredibly common to want to use separate view implementations depending on what kind of state that a given app or feature is currently in.</p><p>For example, let’s say that we’re currently building an app that uses an <code>AppState</code> object to keep track of its overall state, which includes properties like whether the user has gone through the app’s onboarding flow. We then check that state within the app’s root view to determine whether we should display either a <code>HomeView</code> or an <code>OnboardingView</code> — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RootView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> state: <span class=\"s-type\">AppState</span>\n    \n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">if</span> state.<span class=\"s-property\">isOnboardingCompleted</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">AnyView</span>(<span class=\"s-type\">HomeView</span>(state: state))\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">AnyView</span>(<span class=\"s-type\">OnboardingView</span>(\n                isCompleted: <span class=\"s-property\">$state</span>.<span class=\"s-property\">isOnboardingCompleted</span>\n            ))\n        }\n    }\n}</code></pre><p>Note how we’re performing <a href=\"https://www.swiftbysundell.com/articles/different-flavors-of-type-erasure-in-swift\">type erasure</a> on both of our above view instances using SwiftUI’s <code>AnyView</code> type — which is done to give our <code>body</code> property a single, unified return type. However, using <code>AnyView</code> like that doesn’t <em>just</em> add a fair amount of “clutter” to our code, it also makes SwiftUI’s type-based diffing algorithm less efficient, since all of the type information contained within our view’s <code>body</code> is currently completely erased.</p><p>Thankfully, there’s a better way to implement conditions like the one above — even when using Swift 5.2 or earlier — and that’s to manually add the <code>@ViewBuilder</code> attribute to our view’s <code>body</code> property, which lets us make full use of SwiftUI’s <a href=\"https://www.swiftbysundell.com/articles/the-swift-51-features-that-power-swiftuis-api\">function builder-powered DSL</a> directly within that property’s implementation:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RootView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> state: <span class=\"s-type\">AppState</span>\n    \n    <span class=\"s-keyword\">@ViewBuilder var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">if</span> state.<span class=\"s-property\">isOnboardingCompleted</span> {\n            <span class=\"s-type\">HomeView</span>(state: state)\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-type\">OnboardingView</span>(isCompleted: <span class=\"s-property\">$state</span>.<span class=\"s-property\">isOnboardingCompleted</span>)\n        }\n    }\n}</code></pre><p>What’s new in Swift 5.3 is that <em>all views</em> now automatically gain the above capability, since views now directly inherit the <code>@ViewBuilder</code> attribute from the declaration of the <code>View</code> protocol itself — meaning that we can keep using the above approach without having to add any additional attributes to our view’s <code>body</code>:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> RootView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> state: <span class=\"s-type\">AppState</span>\n    \n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">if</span> state.<span class=\"s-property\">isOnboardingCompleted</span> {\n            <span class=\"s-type\">HomeView</span>(state: state)\n        } <span class=\"s-keyword\">else</span> {\n            <span class=\"s-type\">OnboardingView</span>(isCompleted: <span class=\"s-property\">$state</span>.<span class=\"s-property\">isOnboardingCompleted</span>)\n        }\n    }\n}</code></pre><p>The above might also be a relatively minor change, but it definitely makes it much simpler and more intuitive to conditionally create separate view types — which in turn should lead to fewer <code>AnyView</code> instances, and thus simpler code and better overall performance within many SwiftUI-based apps.</p><h2>Function builder control flow improvements</h2><p>Like alluded to above, SwiftUI’s overall API is to a large extent powered by Swift’s <a href=\"https://www.swiftbysundell.com/articles/deep-dive-into-swift-function-builders\">function builders feature</a> — which is what makes it possible for us to simply express the various views that we’re looking to render, and SwiftUI will then automatically combine those expressions in order to form our final UI.</p><p>However, that power and convenience also comes with certain limitations and drawbacks. For example, in Swift 5.2 and earlier, it was only possible to use a very limited set of control flow mechanisms — such as basic <code>if</code> and <code>else</code> statements — within function builder contexts.</p><p>So if we wanted to use slightly more sophisticated ways of handling multiple states, for example by using a <code>switch</code> statement, then we’d again have to resort to explicitly returning <code>AnyView</code>-wrapped views as separate expressions within our <code>body</code> implementation — like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ContentView&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">enum</span> State {\n        <span class=\"s-keyword\">case</span> loading\n        <span class=\"s-keyword\">case</span> loaded(<span class=\"s-type\">Content</span>)\n        <span class=\"s-keyword\">case</span> failed(<span class=\"s-type\">Error</span>)\n    }\n\n    <span class=\"s-keyword\">var</span> state: <span class=\"s-type\">State</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">switch</span> state {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loading</span>:\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">AnyView</span>(<span class=\"s-type\">LoadingSpinner</span>())\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loaded</span>(<span class=\"s-keyword\">let</span> content):\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">AnyView</span>(content)\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failed</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-keyword\">return</span> <span class=\"s-type\">AnyView</span>(<span class=\"s-type\">ErrorView</span>(error: error))\n        }\n    }\n}</code></pre><p>However, in Swift 5.3, <code>switch</code> statements are now fully supported within function builder contexts — meaning that we can once again remove our <code>AnyView</code> wrappers and simply express the views that we’re looking to render within each code branch:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> ContentView&lt;Content: <span class=\"s-type\">View</span>&gt;: <span class=\"s-type\">View</span> {\n    ...\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-keyword\">switch</span> state {\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loading</span>:\n            <span class=\"s-type\">LoadingSpinner</span>()\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">loaded</span>(<span class=\"s-keyword\">let</span> content):\n            content\n        <span class=\"s-keyword\">case</span> .<span class=\"s-dotAccess\">failed</span>(<span class=\"s-keyword\">let</span> error):\n            <span class=\"s-type\">ErrorView</span>(error: error)\n        }\n    }\n}</code></pre><p>Along the same lines, optional-unwrapping <code>if let</code> conditions are now also fully supported — which means that we no longer need to come up with our own techniques for rendering views that rely on some form of optional data. One such technique that’s been commonly used in Swift 5.2 and earlier is to combine a regular <code>if</code> statement with force unwrapping — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> HomeView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> userController: <span class=\"s-type\">UserController</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-keyword\">if</span> userController.<span class=\"s-property\">loggedInUser</span> != <span class=\"s-keyword\">nil</span> {\n                <span class=\"s-type\">ProfileView</span>(user: userController.<span class=\"s-property\">loggedInUser</span>!)\n            }\n            ...\n        }\n    }\n}</code></pre><p class=\"info\">For a few alternatives to the above pattern that are all fully Swift 5.2-compatible, check out <a href=\"https://www.swiftbysundell.com/tips/optional-swiftui-views\">“Optional SwiftUI views”</a>.</p><p>Now, once we’re ready to upgrade to Swift 5.3, we can simply write the above type of expression using a standard <code>if let</code> condition — which both makes that sort of code much simpler, and removes a force-unwrapped optional (big win!):</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> HomeView: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@ObservedObject var</span> userController: <span class=\"s-type\">UserController</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">VStack</span> {\n            <span class=\"s-keyword\">if let</span> user = userController.<span class=\"s-property\">loggedInUser</span> {\n                <span class=\"s-type\">ProfileView</span>(user: user)\n            }\n            ...\n        }\n    }\n}</code></pre><h2>Multiple trailing closures</h2><p>Swift 5.3 also introduces a new (somewhat controversial) feature called <em>multiple trailing closures</em>, which — like its name implies — enables us to attach multiple trailing closures when calling a function or initializer that takes more than one closure.</p><p>While the exact syntax of that feature has been heavily debated on the Swift forums ever since it was first introduced, it does arguably make the call sites of certain APIs slightly cleaner and easier to read. For example, here’s what our <code>FavoriteButton</code> implementation from before would look like if we were to use multiple trailing closures when creating its underlying <code>Button</code> instance:</p><pre class=\"splash\"><code><span class=\"s-keyword\">struct</span> FavoriteButton: <span class=\"s-type\">View</span> {\n    <span class=\"s-keyword\">@Binding var</span> isOn: <span class=\"s-type\">Bool</span>\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">View</span> {\n        <span class=\"s-type\">Button</span> {\n            isOn.<span class=\"s-call\">toggle</span>()\n        } label: {\n            <span class=\"s-type\">Image</span>(systemName: <span class=\"s-string\">\"heart\"</span> + (isOn ? <span class=\"s-string\">\".fill\"</span> : <span class=\"s-string\">\"\"</span>))\n        }\n    }\n}</code></pre><p>The main advantage of the above syntax is that it makes APIs that use multiple closures (which almost all SwiftUI views that offer some form of event handling do) feel more “at home” within SwiftUIs DSL, and enables us to gradually extend a given call with additional trailing closures without having to rewrite the entire expression.</p><p>However, especially in cases like the one above, it could also be argued that it’s no longer crystal clear what the first trailing (now unlabelled) closure does — so we might still want to explicitly label each closure in certain situations, which is of course still an option.</p><h2>Type-based program entry points</h2><p>Finally, let’s take a look at how the version of SwiftUI that ships with Xcode 12 makes use of Swift 5.3’s new <code>@main</code> attribute to enable us to declare an app’s main entry point in a very similar way to how we define our various views.</p><p>As a language feature, the <code>@main</code> attribute enables any Swift program to define a <em>type-based entry point</em> — that is, a type that implements a static <code>main</code> method used to run the program’s root logic:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@main struct</span> MyApp {\n    <span class=\"s-keyword\">static func</span> main() {\n        <span class=\"s-comment\">// Run our program's root logic</span>\n    }\n}</code></pre><p>While the above approach of defining an app’s main entry point might work really well for completely custom programs — such as scripts and command line tools — when it comes to things like iOS and macOS apps, we might not want to take <em>complete</em> control over everything that’s involved in getting an app up and running — and thanks to SwiftUI’s new <code>App</code> protocol, we don’t have to.</p><p>By combining the <code>@main</code> attribute with that new protocol, we can instead simply use SwiftUI’s DSL to define our app’s various scenes, as well as the root views contained within those scenes — meaning that entire apps can now be built directly using SwiftUI — for example like this:</p><pre class=\"splash\"><code><span class=\"s-keyword\">@main struct</span> MyApp: <span class=\"s-type\">App</span> {\n    <span class=\"s-keyword\">@StateObject var</span> state = <span class=\"s-type\">AppState</span>()\n\n    <span class=\"s-keyword\">var</span> body: <span class=\"s-keyword\">some</span> <span class=\"s-type\">Scene</span> {\n        <span class=\"s-type\">WindowGroup</span> {\n            <span class=\"s-keyword\">if</span> state.<span class=\"s-property\">isOnboardingCompleted</span>  {\n                <span class=\"s-type\">HomeView</span>(state: state)\n            } <span class=\"s-keyword\">else</span> {\n                <span class=\"s-type\">OnboardingView</span>(isCompleted: <span class=\"s-property\">$state</span>.<span class=\"s-property\">isOnboardingCompleted</span>)\n            }\n        }\n    }\n}</code></pre><p>While the above new API is (at the time of writing) quite limited when compared to all of the functionality that UIKit’s <code>UIApplicationDelegate</code> has to offer — the good news is that we can also easily bridge those two worlds using the <code>UIApplicationDelegateAdaptor</code> property wrapper. To learn more about that, check out <a href=\"https://www.swiftbysundell.com/tips/using-an-app-delegate-with-swiftui-app-lifecycle\">this mini-article</a>.</p><h2>Conclusion</h2><p>Swift 5.3 brings a number of very welcome enhancements to SwiftUI’s overall API, and while it might not fundamentally change the way we use Swift (which would be strange, given that it’s just a minor version bump), it shows just how tightly Swift and SwiftUI continue to simultaneously evolve.</p><p>However, being features of the language itself, rather than any specific SDK, we can both make use of these new capabilities outside of SwiftUI and Apple’s platforms all together, and we can also use them without having to increase our app’s minimum deployment target to iOS 14 or macOS Big Sur. All that we have to do is to build our projects using Xcode 12, and we can make full use of all that Swift 5.3 has to offer.</p><p>The one exception to that is the <code>App</code> protocol, which is only available on the 2020 editions of Apple’s operating systems, as its a concrete SwiftUI-specific implementation of the more generic (and backward compatible) <code>@main</code> attribute.</p><p>Got questions, comments or feedback? You’re always more than welcome to contact me. You can reach me either via <a href=\"https://twitter.com/johnsundell\">Twitter</a> or <a href=\"https://www.swiftbysundell.com/contact\">email</a>.</p><p>Thanks for reading! 🚀</p>",
      "summary": "A roundup of some of the key ways in which Swift 5.3 enhances the overall experience of building views using SwiftUI.",
      "date_published": "2020-09-13T17:30:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/podcast/81",
      "url": "https://www.swiftbysundell.com/podcast/81",
      "title": "Podcast: “How big iOS teams typically operate”, with special guest Carola Nitz",
      "content_html": "<audio controls><source src=\"https://traffic.libsyn.com/swiftbysundell/SwiftBySundell81.mp3\" type=\"audio/mpeg\"/></audio><p>Carola Nitz, iOS developer at Netflix, joins John to discuss how larger iOS development teams typically operate, and how smaller teams can prepare their code bases for future growth. Also, organizing remote conferences, balancing feature development with bug fixing, and much more.</p><h2>Sponsors</h2><ul><li><strong><a href=\"https://paw.cloud/sundell\">Paw</a>:</strong> An advanced API tool for the Mac. Paw is a full-featured HTTP client that lets you test and describe the web APIs that you build or consume. Get started for free, or get a 20% discount on your license, at <a href=\"https://paw.cloud/sundell\">paw.cloud/sundell</a>.</li><li><strong><a href=\"https://bitrise.io/swift\">Bitrise</a>:</strong> Fast, stable and highly customizable continuous integration. Automatically build, test and distribute your app on every single commit that you make. Get started for free at <a href=\"https://bitrise.io/swift\">bitrise.io/swift</a>.</li></ul><h2>Links</h2><ul><li><a href=\"https://twitter.com/_Caro_N\">Caro on Twitter</a></li><li><a href=\"https://twitter.com/johnsundell\">John on Twitter</a></li><li><a href=\"https://appbuilders.ch\">App Builders</a></li><li><a href=\"https://theswiftalps.com\">The Swift Alps</a></li><li><a href=\"https://www.swiftbysundell.com/tips/the-rule-of-threes\">The rule of threes</a></li><li><a href=\"https://www.swiftbysundell.com/articles/feature-flags-in-swift\">Feature flags</a></li><li><a href=\"https://www.carolanitz.com\">Caro’s website</a></li><li><a href=\"https://soundcloud.com/banana-drama\">Intro and outro music by Dariusz Dziuk</a></li></ul>",
      "summary": "Carola Nitz, iOS developer at Netflix, joins John to discuss how larger iOS development teams typically operate, and how smaller teams can prepare their code bases for future growth. Also, organizing remote conferences, balancing feature development with bug fixing, and much more.",
      "date_published": "2020-09-10T16:10:00.000Z"
    },
    {
      "guid": "https://www.swiftbysundell.com/sponsor/reveal-september-2020",
      "url": "https://www.swiftbysundell.com/sponsor/reveal-september-2020",
      "title": "Sponsor: Reveal",
      "content_html": "<p>Thanks a lot to the team behind the fantastic iOS development tool <em><a href=\"https://www.revealapp.com/sundell\">Reveal</a></em> for sponsoring Swift by Sundell this week. I’ve personally been using Reveal for years, both when working on huge projects, as well as smaller ones, and it’s always been fast, rock solid, and incredibly valuable.</p><p>Reveal lets you inspect, debug, and <em>modify</em> your app’s UI while the app keeps running. Not only does that mean that you no longer need to recompile and relaunch the app if you just want to see what a small tweak would look like — you don’t even need to pause the app at all!</p><p>Beyond basic view properties — such as frames, colors, fonts, and so on — Reveal also lets you inspect and modify things like Auto Layout constraints, the underlying <code>CALayer</code> instances that an app’s UI is drawn using, and much more. It even includes a super handy tool that highlights views and constraints that are affected by common Auto Layout issues, along with hints and suggestions that make it so much easier to fix such issues.</p><p>Reveal is <strong>free to try</strong>, so <a href=\"https://www.revealapp.com/sundell\">check it out today</a> if you haven’t tried it before, and they’ve also got a brand new set of pricing tiers if you’re looking to renew your license. And, like always, using that link to check out Reveal directly helps support Swift by Sundell, and helps me keep the website up and running.</p>",
      "summary": "Thanks a lot to Reveal for sponsoring Swift by Sundell.",
      "date_published": "2020-09-06T20:25:00.000Z"
    }
  ]
}